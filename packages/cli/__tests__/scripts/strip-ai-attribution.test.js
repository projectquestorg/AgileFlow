const fs = require('fs');
const os = require('os');
const path = require('path');
const { spawnSync } = require('child_process');

const SCRIPT_PATH = path.resolve(__dirname, '../../scripts/strip-ai-attribution.js');

function runHook(input) {
  const result = spawnSync('node', [SCRIPT_PATH], {
    input: JSON.stringify(input),
    encoding: 'utf8',
    timeout: 10000,
  });
  return result;
}

describe('strip-ai-attribution hook', () => {
  describe('allows non-git commands', () => {
    it('allows regular bash commands', () => {
      const result = runHook({ tool_input: { command: 'npm test' } });
      expect(result.status).toBe(0);
    });

    it('allows ls command', () => {
      const result = runHook({ tool_input: { command: 'ls -la' } });
      expect(result.status).toBe(0);
    });

    it('allows git status', () => {
      const result = runHook({ tool_input: { command: 'git status' } });
      expect(result.status).toBe(0);
    });

    it('allows git push', () => {
      const result = runHook({ tool_input: { command: 'git push origin main' } });
      expect(result.status).toBe(0);
    });

    it('allows git log', () => {
      const result = runHook({ tool_input: { command: 'git log --oneline -5' } });
      expect(result.status).toBe(0);
    });
  });

  describe('allows clean git commits', () => {
    it('allows commit with clean message', () => {
      const result = runHook({
        tool_input: { command: 'git commit -m "feat: add new feature"' },
      });
      expect(result.status).toBe(0);
    });

    it('allows commit with conventional format', () => {
      const result = runHook({
        tool_input: { command: 'git commit -m "fix: resolve login bug"' },
      });
      expect(result.status).toBe(0);
    });

    it('allows commit with multiline message', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "$(cat <<'EOF'\nfeat: add user auth\n\nImplements JWT-based authentication.\nEOF\n)"`,
        },
      });
      expect(result.status).toBe(0);
    });
  });

  describe('blocks Co-Authored-By', () => {
    it('blocks Co-Authored-By with Claude', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "$(cat <<'EOF'\nfeat: add feature\n\nCo-Authored-By: Claude <noreply@anthropic.com>\nEOF\n)"`,
        },
      });
      expect(result.status).toBe(2);
      expect(result.stderr).toContain('[BLOCKED]');
    });

    it('blocks Co-Authored-By case-insensitive', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: stuff\n\nco-authored-by: AI Bot <bot@example.com>"`,
        },
      });
      expect(result.status).toBe(2);
    });
  });

  describe('blocks email patterns', () => {
    it('blocks noreply@anthropic.com', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: stuff noreply@anthropic.com"`,
        },
      });
      expect(result.status).toBe(2);
    });

    it('blocks noreply@openai.com', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: stuff noreply@openai.com"`,
        },
      });
      expect(result.status).toBe(2);
    });

    it('blocks noreply@google.com', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: stuff noreply@google.com"`,
        },
      });
      expect(result.status).toBe(2);
    });
  });

  describe('blocks Generated with/by patterns', () => {
    it('blocks "Generated with Claude Code"', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: add stuff\n\nGenerated with Claude Code"`,
        },
      });
      expect(result.status).toBe(2);
    });

    it('blocks "Generated with [Claude Code]"', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: add stuff\n\nGenerated with [Claude Code]"`,
        },
      });
      expect(result.status).toBe(2);
    });

    it('blocks "Generated by Claude"', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: add stuff\n\nGenerated by Claude"`,
        },
      });
      expect(result.status).toBe(2);
    });

    it('blocks "Generated by GPT"', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: add stuff\n\nGenerated by GPT"`,
        },
      });
      expect(result.status).toBe(2);
    });

    it('blocks "Generated by AI"', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: add stuff\n\nGenerated by AI"`,
        },
      });
      expect(result.status).toBe(2);
    });

    it('blocks "Generated with [GPT"', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "feat: add stuff\n\nGenerated with [GPT-4]"`,
        },
      });
      expect(result.status).toBe(2);
    });
  });

  describe('blocks robot emoji', () => {
    it('blocks robot emoji in commit message', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "\u{1F916} feat: add stuff"`,
        },
      });
      expect(result.status).toBe(2);
    });
  });

  describe('handles HEREDOC commit messages', () => {
    it('blocks attribution in HEREDOC format', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "$(cat <<'EOF'\nfeat: add webhook support\n\nCo-Authored-By: Claude Opus 4 <noreply@anthropic.com>\nEOF\n)"`,
        },
      });
      expect(result.status).toBe(2);
    });

    it('allows clean HEREDOC commit', () => {
      const result = runHook({
        tool_input: {
          command: `git commit -m "$(cat <<'EOF'\nfeat: add webhook support\n\nAdds Slack and Discord webhooks.\nEOF\n)"`,
        },
      });
      expect(result.status).toBe(0);
    });
  });

  describe('fails open on errors', () => {
    it('fails open on invalid JSON', () => {
      const result = spawnSync('node', [SCRIPT_PATH], {
        input: 'not-json',
        encoding: 'utf8',
        timeout: 10000,
      });
      expect(result.status).toBe(0);
    });

    it('fails open on empty input', () => {
      const result = spawnSync('node', [SCRIPT_PATH], {
        input: '',
        encoding: 'utf8',
        timeout: 10000,
      });
      expect(result.status).toBe(0);
    });

    it('fails open on missing tool_input', () => {
      const result = runHook({});
      expect(result.status).toBe(0);
    });

    it('fails open on missing command field', () => {
      const result = runHook({ tool_input: {} });
      expect(result.status).toBe(0);
    });
  });

  describe('bootstrap behavior', () => {
    it('fails open when run from temp directory', () => {
      const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'af-naa-'));
      try {
        const result = spawnSync('node', [SCRIPT_PATH], {
          cwd: tempDir,
          input: JSON.stringify({ tool_input: { command: 'echo hello' } }),
          encoding: 'utf8',
          timeout: 10000,
        });
        expect(result.status).toBe(0);
      } finally {
        fs.rmSync(tempDir, { recursive: true, force: true });
      }
    });
  });
});
