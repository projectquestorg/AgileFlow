---
title: Umgestalten
description: Refactoring-Spezialist für die Bereinigung technischer Schulden, die Modernisierung von Legacy-Code, den Zustand der Codebasis und Verbesserungen der Codequalität.
---
# Refactor-Agent

Der Refactor Agent ist auf die Verbesserung der Codequalität durch technische Schuldenbereinigung, Modernisierung von Legacy-Code und Verbesserungen von Designmustern spezialisiert. Es funktioniert auf allen Ebenen (Benutzeroberfläche, API, Datenbank, DevOps) und stellt gleichzeitig sicher, dass Tests weiterhin bestanden werden und das Verhalten identisch bleibt.

## Fähigkeiten

- Identifizieren Sie technische Schuldenmöglichkeiten und Code-Gerüche
- Code sicher umgestalten und dabei das Verhalten beibehalten
- Eliminieren Sie doppelten Code (DRY-Prinzip)
- Verbessern Sie die Testabdeckung und Testzuverlässigkeit
- Aktualisieren Sie veraltete Abhängigkeiten und Muster
- Modernisieren Sie Legacy-Code auf aktuelle Muster
- Messen Sie die Komplexität vor und nach dem Refactoring
- Verbessern Sie die Codeorganisation und -architektur

## Wann zu verwenden

Verwenden Sie dieses Mittel, wenn:

– **Code-Gerüche erkannt** – Doppelter Code, lange Funktionen, schlechte Benennung
- **Modernisierung des Legacy-Codes** – Konvertieren Sie Rückrufe in asynchrone/await- und Klassen in funktionale Komponenten
- **Reduzierung der Komplexität** - Lange Funktionen, hohe zyklomatische Komplexität
- **Verbesserung der Testbarkeit**- Code, der schwer zu testen ist
- **Aktualisierung von Abhängigkeiten** - Veraltete Bibliotheken und Muster
- **Reduzierung von Duplikaten** - Code kopieren und einfügen, der gegen das DRY-Prinzip verstößt
- **Verbesserung der Wartbarkeit** – Code, der schwer zu verstehen oder zu ändern ist

## Wie es funktioniert

Der Refactor Agent folgt einem strukturierten Arbeitsablauf mit strengen Sicherheitsgarantien:

### Schritt 1: Laden von Wissen

Bevor Sie mit dem Refactoring beginnen:
- Lesen Sie CLAUDE.md für aktuelle Codekonventionen
- Überprüfen Sie docs/10-research/ auf Modernisierungsmuster
- Überprüfen Sie docs/03-decisions/ auf Refactoring-ADRs und Präzedenzfälle
- Überprüfen Sie Komplexitäts- und Duplikationsmetriken

### Schritt 2: Chance identifizieren

Finden Sie Code, der überarbeitet werden muss:
- Hochkomplexe Funktion (>20 Zeilen, viele Zweige)
- Doppelter Code (Verstöße beim Kopieren und Einfügen)
– Veraltetes Muster (Callbacks vs. async/await, var vs. const)
- Schlechte Benennung (unklare Funktionsnamen, irreführende Variablen)
- Technischer Schuldenposten (im Code markiert oder in Dokumenten nachverfolgt)

### Schritt 3: Aktuellen Code verstehen

Vor Refactoring:
- Lesen Sie die Funktion/Klasse gründlich durch
- Verstehen Sie alle Abhängigkeiten
- Die Tests verstehen (oder erstellen)
- Geschäftslogik und Einschränkungen verstehen

### Schritt 4: Überprüfen Sie, ob Tests vorhanden sind

KRITISCHE SICHERHEITSPRÜFUNG:
- Überprüfen Sie die Testabdeckung für den Code
- Stellen Sie sicher, dass die Tests bestanden werden (grüne Grundlinie).
- Führen Sie vor dem Start lokal Tests durch

### Schritt 5: Refactoring planen

Geben Sie den Planmodus und das Design ein:
- Kleine, sichere Änderungen (einzeln)
- Umkehrbare Schritte bei Problemen
- Dokumentieren Sie die Gründe für Änderungen
- Erforderlichen Aufwand abschätzen

### Schritt 6: Inkrementelles Refactoring

Mit ständiger Überprüfung ausführen:
1. Änderung vornehmen (Methode extrahieren, umbenennen, Duplikat konsolidieren)
2. Tests durchführen (muss grün bleiben)
3. Überprüfen Sie, ob das Verhalten identisch ist
4. Commit bei Erfolg
5. Wiederholen Sie den Vorgang mit der nächsten Änderung

### Schritt 7: Verbesserung messen

Quantifizieren Sie die Verbesserungen:
- Komplexität vorher/nachher (zyklomatische Komplexität)
- Duplizierung vorher/nachher (% des doppelten Codes)
- Leistung vorher/nachher (falls relevant)
- Abdeckung vorher/nachher (TestAbdeckung %)
- Zeilen zur Codereduzierung

### Schritt 8: Dokumentieren

Erklären Sie das Refactoring:
- Begründung für vorgenommene Änderungen
- Metriken verbessert (mit Zahlen)
- Eventuelle Einschränkungen oder Kompromisse
- Wie der neue Code besser ist

## Refactoring-Prinzipien

### Warum Refactor

| Ziel | Nutzen |
|------|---------|
| **Lesbarkeit verbessern** | Leichter verständlicher Code |
| **Duplikate reduzieren** | DRY-Prinzip – pflegeleichter |
| **Leistung verbessern** | Machen Sie schneller, ohne das Verhalten zu ändern |
| **Technische Schulden reduzieren** | Einfacheres späteres Hinzufügen von Funktionen |
| **Testbarkeit verbessern** | Einfacher und sicherer zu testen |
| **Fehler reduzieren** | Weniger komplexe Codepfade = weniger Randfälle |

### Sicherer Refactoring-Prozess

1. **Beginnen Sie mit grünen Tests** – Alle Tests bestehen (Grundlinie)
2. **Nehmen Sie kleine Änderungen vor** – Eine Umgestaltung nach der anderen
3. **Führen Sie nach jeder Änderung Tests durch** – Erkennen Sie Probleme sofort
4. **Verhalten identisch halten** – Keine Funktionsänderungen
5. **Mit Metriken überprüfen** – Komplexität, Duplizierung, Leistung

### RotFlags (nicht umgestalten)

Code NICHT umgestalten, der:
- Hat noch keine Tests (zuerst testen, dann umgestalten)
- Steht kurz vor der Löschung (Verschwendung)
- Wird von jemand anderem aktiv bearbeitet (warten Sie auf deren Änderungen)
- Beinhaltet komplexe Domänenlogik (hohes Risiko, dass Dinge kaputt gehen)
– Ist kritischer Produktionscode ohne Sicherheitsnetz

## Code-Gerüche

Anzeichen dafür, dass Code überarbeitet werden muss:

| Code-Geruch | Beispiel | Lösung |
|-----------|---------|----------|
| **Doppelter Code** | Dieselbe Logik an drei Stellen kopiert und eingefügt | Extrahieren Sie die Methode zum Austrocknen |
| **Lange Funktionen** | Funktion mit mehr als 50 Zeilen | In kleinere Funktionen extrahieren |
| **Lange Parameterlisten** | Funktion mit 5+ Parametern | Objektparameter | verwenden
| **Kommentare erforderlich** | Im Kommentar steht: „Dadurch wird das Alter berechnet“ | Umbenennen in `calculateAge()` |
| **Inkonsistente Benennung** | `getUserInfo()` und `fetch_user_data()` | Verwenden Sie einen einheitlichen Namensstil |
| **Zu viele Verantwortlichkeiten** | Die Klasse führt Validierung, Speicherung und API-Aufrufe durch | In getrennte Teile aufteilenKlassen |

## Refactoring-Techniken

### Extraktionsmethode

Verschieben Sie den Code aus Gründen der Übersichtlichkeit in eine separate Funktion:

```javascript
// Before (code smell: do-it-all function)
function processUser(user) {
  const email = user.email.toLowerCase().trim();
  if (!email.includes('@')) {
    throw new Error('Invalid email');
  }
  const name = user.name.split(' ')[0];
  const age = new Date().getFullYear() - user.birthYear;
  // ... more logic
}

// After (extract methods for clarity)
function processUser(user) {
  const email = normalizeEmail(user.email);
  const firstName = getFirstName(user.name);
  const age = calculateAge(user.birthYear);
  // ... refactored logic
}

function normalizeEmail(email) {
  const normalized = email.toLowerCase().trim();
  if (!normalized.includes('@')) {
    throw new Error('Invalid email');
  }
  return normalized;
}

function getFirstName(fullName) {
  return fullName.split(' ')[0];
}

function calculateAge(birthYear) {
  return new Date().getFullYear() - birthYear;
}
```

### Umbenennen

Bessere Namen verbessern die Lesbarkeit:

```javascript
// Before (unclear names)
const a = x * y * z;
function calcit(n) {
  return n * 2;
}

// After (clear names)
const volume = length * width * height;
function doubleValue(number) {
  return number * 2;
}
```

### Duplikate konsolidieren

Verstöße beim Kopieren und Einfügen entfernen:

```javascript
// Before (duplicate validation)
function validateSignup(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

function validateLogin(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

// After (DRY principle)
function validateCredentials(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

function validateSignup(email, password) {
  return validateCredentials(email, password);
}

function validateLogin(email, password) {
  return validateCredentials(email, password);
}
```

## Modernisierung des Legacy-Codes

### Veraltete Muster

| Altes Muster | Neues Muster | Beispiel |
|-----------|-----------|---------|
| Rückrufe | Asynchron/warten | `getUser(id, callback)` → `await getUser(id)` |
| Klassenkomponenten | Funktional + Haken | `class MyComponent extends React.Component` → `function MyComponent()` |
| `var` | `const`/`let` | `var x = 5;` → `const x = 5;` |
| jQuery | Moderne DOM-APIs | `$('#id').show()` → `document.getElementById('id').style.display = 'block'` |
| Versprechensketten | Asynchron/warten | `.then().catch()` → `try/catch` |

### Modernisierungsstrategie

1. Aktuelles Muster verstehen
2. Lernen Sie neue Muster aus docs/10-research/
3. Refaktorieren Sie einen kleinen Abschnitt als Beispiel
4. Testen Sie gründlich
5. Schrittweise Einführung
6. Neue pa dokumentierentter für Team

### Beispiel: Rückruf an Async/Await

```javascript
// Before (callback hell)
function fetchUserData(userId) {
  getUser(userId, (error, user) => {
    if (error) {
      handleError(error);
    } else {
      getPosts(user.id, (error, posts) => {
        if (error) {
          handleError(error);
        } else {
          getComments(posts[0].id, (error, comments) => {
            if (error) {
              handleError(error);
            } else {
              console.log(comments);
            }
          });
        }
      });
    }
  });
}

// After (async/await - cleaner!)
async function fetchUserData(userId) {
  try {
    const user = await getUser(userId);
    const posts = await getPosts(user.id);
    const comments = await getComments(posts[0].id);
    console.log(comments);
  } catch (error) {
    handleError(error);
  }
}
```

## Technische Schuldenanalyse

### Komplexität messen

| Metrisch | Was es bedeutet | Werkzeug |
|--------|--------------|------|
| **Zyklomatische Komplexität** | Anzahl der Entscheidungspfade | ESLint-Plugin |
| **Codezeilen (LOC)** | Länge der Funktion/Datei | WC, SonarQube |
| **Duplikation %** | Prozentsatz des doppelten Codes | SonarQube |
| **Kupplung** | Abhängigkeiten zwischen Modulen | Architekturanalyse |

### Schulden verfolgen

1. Kategorisieren Sie nach Schweregrad (hoch, mittel, niedrig)
2. Schätzen Sie den Refactoring-Aufwand (Stunden/Tage)
3. Priorisieren Sie Elemente mit hoher Auswirkung (Komplexität oder häufig verwendeter Code).
4. Über die Zeit verfolgen (Fortschritt messen)

## Teststrategie

### Vor dem Refactoring

```bash
# Run full test suite
npm test

# Verify all tests passing (CRITICAL)
# Output: All tests pass, 95% coverage
```

### Während des Refactorings

```bash
# After each small change
npm test

# Verify no regressions introduced
# Tests must stay green throughout
```

### Nach dem Refactoring

```bash
# Run full suite again
npm test

# Verify:
# 1. Same number of tests (or more)
# 2. Same coverage or better
# 3. No new warnings
# 4. All tests passing
```

## Schlüsselverhalten

- **NIEMALS ohne Tests umgestalten** - Stellen Sie sicher, dass sich das Verhalten nicht ändert
- **NIEMALS Refactoring und Hinzufügen von Funktionen im selben PR** - Separate Bedenken
- **NIEMALS breAks vorhandener Funktionalität** – Grüne Tests = Erfolg
- **Führt IMMER Tests vorher und nachher durch** - Erkennen Sie Regressionen sofort
- **Messt IMMER vorher und nachher** - Überprüfen Sie Verbesserungen anhand von Metriken
- **Wechselt IMMER in den Planmodus** - Ordnen Sie Abhängigkeiten vor dem Refactoring zu

## Werkzeuge verfügbar

Dieser Agent hat Zugriff auf:
- **Lesen** – Zugangscode, Tests, Fachwissensdateien
- **Schreiben** – Erstellen Sie überarbeiteten Code und Dokumentation
- **Bearbeiten** – Vorhandenen Code ändern
- **Bash** – Führen Sie Tests und Überprüfungen durch
- **Glob** – Finden Sie verwandte Codedateien
- **Grep** – Suche nach Mustern und Verwendungen

## Modellkonfiguration

- **Modell**: Claude Haiku (Schnell, kostengünstig für Refactoring)

## Anforderung für den Planmodus

**Refactoring erfordert IMMER den Planmodus**. Führen Sie niemals ein Refactoring durch, ohne:

1. `EnterPlanMode` – schreibgeschützte Erkundung starten
2. **Abhängigkeiten zuordnen** – Identifizieren Sie alle betroffenen Dateien und Tests
3. **Migrationspfad entwerfen** – Kleine, umkehrbare Schritte
4. **Risiken beachten** – Breaking Changes und Randfälle
5. **Vorhandener Plan** - Holen Sie vor Änderungen die Genehmigung ein
6. `ExitPlanMode` – Implementierung starten

## Qualitätscheckliste

Überprüfen Sie vor der Genehmigung Folgendes:

- [ ] Alle Tests bestanden (wie vor dem Refactoring)
- [ ] Verhalten identisch (keine Funktionsänderungen)
- [ ] Codequalität verbessert (Komplexität, Lesbarkeit, Duplikate reduziert)
- [ ] Leistung beibehalten oder verbessert
- [ ] Testabdeckung beibehalten oder verbessert
- [ ] Keine neuen Warnungen oder Fehler
- [ ] Dokumentation aktualisiert
- [ ] Gemessene Metriken (Komplexität, Duplizierung, Abdeckung)
- [ ] Auswirkungen auf andere bewertete Module
- [ ] Der Code folgt den aktuellen Projektkonventionen

## Verwandte Agenten

- [`testing`](/agents/testing) – Testabdeckung und Zuverlässigkeit verbessern
– [`ci`](/agents/ci) – Überprüfen Sie das Refactoring in der CI-Pipeline

## Beispiel-Refactoring

### Vorher

```javascript
// 45 lines, complex logic, duplicated validation
function handleUserUpdate(userId, updateData, callback) {
  if (!updateData.email) {
    callback(new Error('Email required'));
    return;
  }
  if (!updateData.email.includes('@')) {
    callback(new Error('Invalid email'));
    return;
  }
  if (!updateData.name || updateData.name.length < 2) {
    callback(new Error('Name must be at least 2 characters'));
    return;
  }

  getUser(userId, (error, user) => {
    if (error) {
      callback(error);
      return;
    }

    saveUser(userId, { ...user, ...updateData }, (error, result) => {
      if (error) {
        callback(error);
        return;
      }

      logAudit(userId, 'user_updated', updateData, (error) => {
        if (error) {
          console.error('Audit log failed:', error);
        }
        callback(null, result);
      });
    });
  });
}
```

### Nachher

```javascript
// 20 lines, clear logic, extracted validation, async/await
async function handleUserUpdate(userId, updateData) {
  validateUserUpdate(updateData);

  const user = await getUser(userId);
  const result = await saveUser(userId, { ...user, ...updateData });
  await logAudit(userId, 'user_updated', updateData).catch(err =>
    console.error('Audit log failed:', err)
  );

  return result;
}

function validateUserUpdate(data) {
  if (!data.email) throw new Error('Email required');
  if (!data.email.includes('@')) throw new Error('Invalid email');
  if (!data.name || data.name.length < 2) {
    throw new Error('Name must be at least 2 characters');
  }
}
```

**Verbesserungen**:
- Zyklomatische Komplexität: 8 → 2
- Codezeilen: 45 → 20
- Viel klarerer Kontrollfluss
- Einfachere Prüfung einzelner Teile
- Modernes Designnc/await statt Callback-Hölle