---
title: API
description: Especialista en servicios y capa de datos para implementar API de backend, lógica de negocios y modelos de datos.
---
# Agente API

El agente API (AG-API) es su especialista en servicios backend. Implementa API REST/GraphQL, lógica empresarial, modelos de datos, acceso a bases de datos, integraciones de servicios externos y gestión de estado. Garantiza que su capa de datos sea segura, eficaz y esté bien probada.

## Capacidades

- Implementar puntos finales de API REST/GraphQL/tRPC
- Escribir lógica de negocios y reglas de validación.
- Diseñar y mantener modelos y esquemas de datos.
- Optimice las consultas de la base de datos y evite problemas N+1
- Integrar servicios externos (Stripe, SendGrid, analítica, etc.)
- Implementar autenticación y autorización.
- Escribir pruebas API integrales (unitarias, de integración, de contrato)
- Documentar los puntos finales de la API y el manejo de errores.
- Coordinar con AG-UI en dependencias de puntos finales API
- Monitorear y registrar solicitudes de API con contexto

## Cuándo utilizar

Utilice el agente API cuando:

- Necesita implementar un nuevo punto final API
- Es necesario agregar lógica empresarial para manejar una función.
- Es necesario integrar un servicio externo (pago, correo electrónico, etc.)
-Necesita optimizar las consultas de la base de datos o solucionar problemas N+1
- Necesita implementar autenticación o autorización.
- Estás diseñando modelos de datos para una nueva función.
- Necesitas escribir pruebas API completas.
- Quiere asegurarse de que las historias de AG-UI no se bloqueen en espera de puntos finales.

## Cómo funciona

1. **Carga de contexto**: el agente lee documentos de experiencia, CLAUDE.md y arquitectura.
2. **Verificación de estado**: el agente encuentra historias listas y verifica si hay bloqueadores AG-UI
3. **Definición de Listo**: el agente valida los criterios de aceptación y los talones de prueba
4. **Modo Planificación**: Para trabajos complejos, el agente diseña el enfoque antes de implementar
5. **Implementación**: el agente escribe validación, manejo de errores y lógica empresarial
6. **Pruebas**: el agente escribe pruebas unitarias, de integración y de contrato.
7. **Coordinación**: el agente desbloquea historias de AG-UI cuando los puntos finales están listos
8. **Verificación**: el agente ejecuta pruebas para garantizar que se apruebe la línea base.
9. **Documentación**: El agente actualiza CLAUDE.md y agrega mensajes de bus

## Ejemplo

```bash
# Via /babysit (recommended)
/agileflow:babysit
> "I need a user profile API endpoint"
```

El agente API:
1. Consulte docs/06-stories/ para EE. UU. con el propietario==AG-API
2. Busque historias de AG-UI bloqueadas en espera en este punto final
3. Implementar el punto final POST /api/users:
   - Validación de entrada (campos obligatorios, verificación de tipo)
   - Lógica empresarial (contraseña hash, configuración predeterminada)
   - Acceso a la base de datos (insertar en la tabla de usuarios)
   - Manejo de errores (correo electrónico duplicado, errores de validación)
   - Registro con ID de solicitud
4. Escriba pruebas completas:
   - Camino feliz (los datos válidos crean al usuario)
   - Errores de validación (falta correo electrónico)
   - Casos extremos (correo electrónico muy largo)
5. Actualizar documentos API (OpenAPI/Swagger)
6. Enviar mensaje de desbloqueo a AG-UI: "GET /api/users/:id ready"
7. Marcar en revisión cuando se aprueben las pruebas

O generar directamente:

```text
Task(
  description: "Implement payment webhook endpoint",
  prompt: "Add Stripe webhook handler for payment.success and payment.failed events",
  subagent_type: "agileflow-api"
)
```

## Comportamientos clave

- **Cargar experiencia primero**: lee experticia.yaml antes de cualquier trabajo.
- **Priorizar el desbloqueo de AG-UI**: verifique las historias de AG-UI bloqueadas en los puntos finales de API; esas son la máxima prioridad
- **Coordinación proactiva**: envía mensajes de desbloqueo a AG-UI cuando finalizants están listos
- **Validación de entrada**: valida siempre tipos, formatos, rangos y autorización
- **Manejo de errores**: esquema de error coherente con códigos de estado HTTP
- **Basado en pruebas**: escribe pruebas antes de la implementación, garantiza que las pruebas se aprueben antes de la revisión
- **Actualizaciones de CLAUDE.md**: documenta nuevos patrones de API descubiertos durante la implementación
- **Integración del arnés de sesión**: verifica el estado de la prueba antes de comenzar, requiere pasar las pruebas antes de la revisión
- **Comandos autónomos**: invoca directamente /agileflow:ai-code-review, /agileflow:adr-new, etc.
- **Coordinación de bus**: envía mensajes de estado, bloqueado, desbloqueado y de preguntas a bus/log.jsonl
- **Preservación del contexto**: utiliza compact_context (prioridad: crítica) para mantener el enfoque durante conversaciones largas, preservando las reglas de carga de experiencia y el seguimiento de bloqueadores a través de la compactación del contexto.

## Configuración de contexto compacto

El agente API utiliza **prioridad crítica** compact_context para garantizar que se mantenga el enfoque durante conversaciones prolongadas:

```yaml
compact_context:
  priority: critical
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
    - "CHECK FOR AG-UI BLOCKERS: Search bus/log.jsonl for UI stories waiting on API endpoints"
    - "VERIFY TEST BASELINE: Session harness required - check test_status before starting"
    - "DIFF-FIRST FOR FILE CHANGES: Show all edits with YES/NO confirmation"
    - "NEVER hardcode secrets - use environment variables only"
  state_fields:
    - current_story
    - endpoints_implemented
    - blocked_ui_stories
    - test_status_baseline
```

Esto garantiza que las reglas críticas (carga de experiencia, priorización de bloqueadores, verificación de pruebas) y el estado actual (qué puntos finales están listos, qué historias de UI están bloqueadas) se conservan incluso después de la compactación del contexto.

## Herramientas disponibles

Este agente tiene acceso a: Leer, Escribir, Editar, Bash, Glob, Grep

## Patrones de puntos finales de API

**Convenciones REST**:

```text
GET    /api/users           → List users
POST   /api/users           → Create user
GET    /api/users/:id       → Get user
PATCH  /api/users/:id       → Update user
DELETE /api/users/:id       → Delete user
```

**Formato de solicitud/respuesta**:

```json
// Request
POST /api/users
{
  "email": "user@example.com",
  "password": "secure-password",
  "name": "John Doe"
}

// Success Response (201 Created)
{
  "id": "user_123",
  "email": "user@example.com",
  "name": "John Doe",
  "createdAt": "2025-01-15T10:00:00Z"
}

// Error Response (422 Unprocessable Entity)
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": {
      "email": "Email already exists"
    }
  }
}
```

## Validación de entrada

Cada punto final debe validar las entradas:

```javascript
// Validate required fields
if (!email || !password) {
  throw new ValidationError('Email and password required');
}

// Validate format
if (!email.includes('@')) {
  throw new ValidationError('Invalid email format');
}

// Validate range
if (password.length < 8) {
  throw new ValidationError('Password must be 8+ characters');
}

// Validate authorization
if (userId !== req.user.id) {
  throw new AuthorizationError('Cannot access other users');
}
```

## Manejo de errores

Esquema de error coherente en todos los puntos finales:

```javascript
// Error class (example)
class AppError extends Error {
  constructor(code, message, statusCode = 500, details = {}) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
  }
}

// Usage
throw new AppError(
  'VALIDATION_ERROR',
  'Email is required',
  422,
  { field: 'email' }
);
```

## Estándares de prueba

Cada punto final de API necesita pruebas exhaustivas:

```javascript
describe('POST /api/users', () => {
  test('creates user with valid data', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ email: 'test@example.com', password: 'password123' });
    expect(response.status).toBe(201);
    expect(response.body.email).toBe('test@example.com');
  });

  test('returns validation error for missing email', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ password: 'password123' });
    expect(response.status).toBe(422);
    expect(response.body.error.code).toBe('VALIDATION_ERROR');
  });

  test('returns error for duplicate email', async () => {
    // Create first user
    await request(app)
      .post('/api/users')
      .send({ email: 'test@example.com', password: 'password123' });

    // Try to create duplicate
    const response = await request(app)
      .post('/api/users')
      .send({ email: 'test@example.com', password: 'password123' });
    expect(response.status).toBe(409);
    expect(response.body.error.code).toBe('DUPLICATE_EMAIL');
  });
});
```

## Archivos clave

- **Experiencia**: `packages/cli/src/core/experts/api/expertise.yaml` (memoria del agente)
- **Flujo de trabajo**: `packages/cli/src/core/experts/api/workflow.md` (Planificar → Construir → Automejorar)
- **Estado**: `docs/09-agents/status.json` (seguimiento de la historia)
- **Bus**: `docs/09-agents/bus/log.jsonl` (mensajes de coordinación)
- **CLAUDE.md**: arquitectura API, ORM, enfoque de validación
- **Investigación**: `docs/10-research/` (verificar patrones API)
- **ADR**: `docs/03-decisions/` (decisiones de arquitectura API)

## Pasos del flujo de trabajo

1. **Cargar experiencia**: leer experiencia.yaml
2. **Verificar estado**: busque historias LISTAS donde propietario==AG-API
3. **Priorizar bloqueadores AG-UI**: verifique el bus para ver si hay historias AG-UI bloqueadas en los puntos finales
4. **Validar definición de Listo**: existe AC, código auxiliar de prueba en docs/07-testing/test-cases/
5. **Verifique el arnés de la sesión**: verifique que test_status== haya pasado antes de comenzar
6. **Crear sucursal**: `feature/<US_ID>-<slug>`
7. **Estado de actualización**: marcar "en curso", agregar mensaje de bus
8. **Implementar**: Validación, manejo de errores, lógica de negocios, pruebas.
9. **Ejecutar verificación**: /agileflow:verify para garantizar que se aprueben las pruebas
10. **Actualizar CLAUDE.md**: Si se establecen nuevos patrones (documentarlos)
11. **Marcar en revisión**: solo si test_status==aprobado
12. **Enviar mensajes de desbloqueo**: si AG-UI estaba esperando en este punto final
13. **Generar PR**: Utilice /agileflow:pr-template
14. **Automejora**: ejecute self-improve.md una vez completado

## QuaLista de verificación de la ciudad

Antes de marcar en revisión:

- [ ] Entradas validadas (tipo, formato, rango, autenticación)
- [] Respuestas de error consistentes (códigos HTTP, esquema de error)
- [] Autenticación/autorización aplicada en rutas protegidas
- [ ] No hay consultas N+1 (acceso optimizado a la base de datos)
- [] Secretos en env vars (nunca codificados)
- [] Registro con ID de solicitud y contexto
- [] Documentos API actualizados (OpenAPI/Swagger/README)
- [] Las pruebas cubren: camino feliz, errores de validación, fallas de autenticación, casos extremos
- [] Estado de la prueba: aprobado (verificado mediante /agileflow:verify)
- [] Historias de AG-UI desbloqueadas (mensaje de desbloqueo enviado si corresponde)

## Coordinación con Otros Agentes

**AG-UI (Frontal)**:
- Consulte docs/09-agents/bus/log.jsonl para ver historias de UI bloqueadas en espera en los puntos finales
- Cuando el punto final esté listo, envíe un mensaje de desbloqueo con el método, la ruta y el formato de solicitud/respuesta.
- Ejemplo: `"API endpoint GET /api/users/:id ready (200 OK, user object), unblocking US-0042"`

**AG-DATABASE (Capa de datos)**:
- Coordinar el diseño del esquema antes de implementar consultas.
- Revisar las migraciones antes de usarlas en el código.
- Compartir patrón de consultarns para optimización

**AG-CI (Pruebas)**:
- Coordinar la configuración de la base de datos de prueba.
- Solicitar contrato de infraestructura de pruebas (Pact, MSW)
- Garantizar pruebas API en CI

**MENTOR (Orquestación)**:
- Solicitar aclaración sobre una lógica empresarial poco clara.
- Informar si falta una historia Definición de Listo

## Agentes relacionados

- [`ui`](/agents/ui) - Componentes frontend que consumen puntos finales API
- [`database`](/agents/database) - Diseño de esquema y capa de datos
- [`mentor`](/agents/mentor) - Orquesta el trabajo de API como parte de la implementación de funciones