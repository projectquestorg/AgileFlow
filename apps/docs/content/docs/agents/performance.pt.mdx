---
title: Desempenho
description: Especialista em desempenho para otimização, criação de perfil, benchmarking, escalabilidade e recursos críticos de desempenho.
---
# Agente de Desempenho

O Agente de Desempenho (AG-PERFORMANCE) é um especialista em otimização de desempenho que identifica gargalos, otimiza caminhos críticos e garante que os aplicativos atendam às metas de desempenho. Este agente se concentra na otimização que prioriza a medição, e não em suposições prematuras.

## Capacidades

- **Perfil de desempenho**: identifique gargalos reais com ferramentas de criação de perfil
- **Criação de benchmark**: meça o desempenho antes e depois das otimizações
- **Otimização de banco de dados**: elimine consultas N+1, adicione índices, otimize consultas
- **Estratégias de cache**: implementar cache na memória, Redis, CDN e HTTP
- **Otimização de front-end**: redução do tamanho do pacote, divisão de código, carregamento lento
- **Otimização de API**: reduza os tempos de resposta e elimine operações caras
- **Teste de carga**: teste limites de escalabilidade e encontre pontos de ruptura
- **Monitoramento de desempenho**: configure alertas para regressões de desempenho
- **Análise de escalabilidade**: entenda como o sistema é dimensionado com carga
- **Documentaçãon**: Crie ADRs para compensações de desempenho

## Quando usar

Use o Agente de Desempenho quando:

- Os tempos de resposta são lentos e precisam de otimização
- As consultas ao banco de dados são lentas ou há problemas N+1
- O tamanho do pacote de front-end é grande
- Necessidade de testar limites de escalabilidade
- O uso de memória é alto ou crescente
- Os endpoints da API excedem as metas de desempenho
- Necessidade de implementar estratégias de cache
- Estabelecer linhas de base de desempenho
- Criação de monitoramento de desempenho e alertas
- Necessidade de documentar decisões de desempenho

## Como funciona

1. **Carregamento de conhecimento**: o agente lê a experiência e as metas de desempenho
2. **Análise**: o agente analisa a história em busca de implicações no desempenho
3. **Criação de perfil**: o agente mede o desempenho atual com ferramentas apropriadas
4. **Identificação de gargalos**: o agente descobre onde o tempo é realmente gasto
5. **Design de otimização**: o agente planeja diversas abordagens de otimização
6. **Implementação**: Agente implementa otimização com medições
7. **Benchmarking**: Agente verifica melhoriasatinge a meta
8. **Documentação**: Agente cria ADR documentando compensações
9. **Monitoramento**: o agente configura alertas para regressões de desempenho

## Exemplo

```bash
# Via babysit - optimize slow API endpoint
/agileflow:babysit
> "The user list API endpoint is taking 5 seconds. It needs to be <200ms."

# Agent output:
# Performance Analysis: GET /api/users
#
# Current Performance: 5.2 seconds
# Target Performance: <200ms
#
# Profiling Results:
# ├── Database query: 4.8s (92% of time)
# │   └── N+1 problem: Fetching user details in loop
# ├── JSON serialization: 0.3s (6%)
# └── Network overhead: 0.1s (2%)
#
# Optimization Strategy:
# 1. Fix N+1: Use JOIN instead of loop (estimated: 4.8s → 0.2s)
# 2. Add database index on users.created_at
# 3. Implement caching with 5 minute TTL
#
# Estimated Result: <200ms after optimizations
# Correctness: All tests will still pass
# Trade-offs: Slight memory overhead for cache
#
# Status: Ready for implementation
```

## Principais comportamentos

- **Medir primeiro**: código de perfil para encontrar gargalos reais (não adivinhe)
- **Benchmark antes/depois**: sempre avalie a melhoria
- **Sem otimização prematura**: não otimize código raramente usado
- **Correção em primeiro lugar**: Nunca sacrifique a correção pelo desempenho
- **Documente compensações**: registre por que as decisões foram tomadas
- **Verificar sob carga**: teste o desempenho sob carga realista

## Ferramentas disponíveis

- Ler, escrever, editar (operações de arquivo)
- Bash (executar perfis/testes de carga)
- Glob (encontre código lento)
- Grep (pesquisa por problemas de desempenho)

## Métricas de desempenho

**Métricas principais**:
- **Tempo de Resposta (Latência)**: Quanto tempo leva a operação?
- **Rendimento**: quantas operações por segundo?
- **Uso de recursos**: CPU, memória, disco, rede
- **Escalabilidade**: como o desempenho é dimensionado com a carga?

**PMetas de desempenho** (ajustar por contexto):
- Endpoints da API: abaixo da média de 200 ms, abaixo de 500 ms p95
- Carregamento da página do frontend: menos de 2s na primeira pintura, menos de 5s no carregamento total
- Consultas de banco de dados: abaixo da média de 10ms, abaixo de 100ms p95
- Memória: Estável, sem vazamentos, crescimento previsível

## Ferramentas de criação de perfil

**JavaScript/Node.js**:
- Chrome DevTools: criador de perfil de desempenho integrado
- Criador de perfil Node.js: __NOTRASLATE_5__
- clinic.js: ferramenta de perfil profissional
- canhão automático: teste de carga HTTP
- Gráficos de chama: visualize o tempo gasto em cada função

**Píton**:
- cProfile: perfil de CPU
- memory_profiler: análise de uso de memória
- py-spy: perfilador de amostragem estatística

**Banco de dados**:
- EXPLICAR ANÁLISE: Plano de consulta e tempo de execução
- Log de consultas lentas: capture consultas acima do limite
- Monitoramento: rastreie contagem de consultas, tempo e uso de recursos

**Front-end**:
- Chrome DevTools: desempenho, guias de rede
- Farol: Auditoria de desempenho
- Web Vitals: métricas principais (LCP, FID, CLS)

## Gargalos e soluções comuns

| Gargalo | Causa| Solução |
|------------|-------|----------|
| Banco de dados | Consultas N+1, índices ausentes, não otimizados | Use JOIN, adicione índices, desnormalize |
| Resposta da API | Endpoints lentos, chamadas externas | Armazenar em cache, otimizar consultas, paralelizar |
| Renderização de front-end | Refluxos, repinturas, grandes pacotes | Divisão de código, carregamento lento, compactação |
| Memória | Vazamentos de memória, grandes estruturas de dados | Corrigir vazamentos, paginar grandes conjuntos de dados |
| CPU | Algoritmos caros, trabalho desnecessário | Otimização de algoritmo, paralelização |

## Técnicas de otimização

**Otimização de banco de dados**:
```sql
-- Bad: N+1 queries (1 for users, N for details)
SELECT * FROM users;
for each user:
  SELECT * FROM user_details WHERE user_id = user.id;

-- Good: Single JOIN query
SELECT u.*, ud.* FROM users u
JOIN user_details ud ON u.id = ud.user_id;
```

**Estratégias de cache**:
- **Cache na memória**: tamanho rápido, mas limitado (Redis)
- **Cache CDN**: ativos estáticos em pontos de presença
- **Cache HTTP**: cache do navegador com ETag, última modificação
- **Cache de banco de dados**: cache de resultados de consulta

**Otimização de front-end**:
```javascript
// Code splitting: Load only needed code
import { lazy, Suspense } from 'react';
const HeavyComponent = lazy(() => import('./HeavyComponent'));

// Lazy loading: Load images on demand
<img loading="lazy" src="image.jpg" alt="...">

// Tree shaking: Remove unused code
import { usedFunction } from 'library'; // Only usedFunction included
```

## Teste de carga

**Cenários de teste de carga**:
- **Aumentar**: Aumente gradualmente a carga para encontrar o ponto de ruptura
- **Sustentado**: Carga constante ao longo do tempo- **Spike**: Aumento repentino na carga
- **Teste de absorção**: Carga sustentada por um período prolongado

**Métricas a serem capturadas**:
- Distribuição do tempo de resposta (média, p50, p95, p99)
- Taxa de transferência (solicitações/segundo)
- Taxa de erro (% de solicitações com falha)
- Uso de recursos (CPU, memória, rede)

## Análise de escalabilidade

Sistema de teste sob carga crescente:

__NOTRADUZIR_3__

## Integração de chicote de sessão

O Agente de Desempenho integra-se ao Session Harness:

__NÃOTRADUZIR_4__

## Lista de verificação de qualidade

Antes de marcar o trabalho como concluído:

- [] Desempenho atual medido e documentado
- [] Gargalo identificado com dados de criação de perfil
- [] Causa raiz compreendida
- [] Estratégia de otimização documentada
- [ ] Antes/depois das medições realizadas
- [] A melhoria atende à meta de desempenho
- [] Correção verificada (os testes ainda passam)
- [] Compensações documentadas
- [] Monitoramento/alertas em vigor
- [] Métricas de desempenho adicionadas à documentação

## Modo de planejamento (obrigatório para otimização)

A otimização do desempenho requer medição-primeiro planejamento:

| Situação | Ação |
|-----------|--------|
| "Tornar mais rápido" (vago) | → EnterPlanMode: Perfil primeiro! |
| Operação lenta conhecida | → EnterPlanMode: Otimização do projeto |
| Cache necessário | → EnterPlanMode: invalidação do plano |
| Otimização de consulta | → EnterPlanMode: Medir antes/depois |
| Problema de tamanho do pacote | → EnterPlanMode: Analisar dependências |

**Fluxo de trabalho do modo de planejamento**:
1. Perfil do desempenho atual
2. Identifique o gargalo real
3. Otimização de design com benchmarks
4. Planeje a estratégia de verificação
5. Obtenha aprovação
6. Implementar, medir, verificar

## Agentes Relacionados

- [`database`__NOTRASLATE_17__ - Otimização de consultas e índices
- [__NOTRASLATE_7____NOTRASLATE_18__ - Otimização do tempo de resposta da API
- [`ui`](/agents/ui) - Desempenho de front-end e divisão de código
- [`devops`__NOTRASLATE_20__ - Desempenho da infraestrutura, escalonamento
- [__NOTRASLATE_10____NOTRASLATE_21__ - Automação de teste de desempenho

## Coordenação

O desempenho Acoordenadas de gent com:

- **AG-DATABASE**: identifique consultas lentas e revise índices
- **AG-API**: perfil de desempenho do endpoint
- **AG-UI**: analise gargalos de front-end
- **AG-DEVOPS**: monitoramento de solicitações, escalonamento de coordenadas
- **Equipe de monitoramento**: configure alertas de desempenho

## Comandos de barra

- __NOTRASLATE_11__ - Técnicas de otimização de pesquisa
- __NOTRASLATE_12__ - Revise o código em busca de problemas de desempenho
- __NOTRASLATE_13__ - Documentar decisões de desempenho
- __NOTRASLATE_14__ - Documentar dívida de desempenho
- __NOTRASLATE_15__ - Analisar o impacto no desempenho
- __NOTRASLATE_16__ - Atualizar status da história

## Princípios de Desempenho

- **Meça, não adivinhe**: a criação de perfil revela gargalos reais
- **Otimização prematura é má**: otimize onde for importante
- **Meta 80/20**: corrigir problemas que afetam 80% do impacto
- **Otimize o pior primeiro**: resolva o maior gargalo primeiro
- **Verificar com carga**: teste sob condições de carga realistas
- **Monitore sempre**: configure alertas para regressões