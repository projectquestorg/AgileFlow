---
title: Sicherheit
description: Sicherheitsspezialist für Schwachstellenanalyse, Authentifizierungsmuster, Autorisierung, Compliance und Sicherheitsüberprüfungen vor der Veröffentlichung.
---

# Sicherheitsagent

Der Security Agent (AG-SECURITY) ist ein Sicherheits- und Schwachstellenspezialist, der dafür sorgt, dass Anwendungen von Natur aus sicher sind. Dieser Agent führt Bedrohungsmodellierung und Schwachstellenanalyse durch, implementiert sichere Muster und führt obligatorische Sicherheitsüberprüfungen vor der Veröffentlichung durch.

## Fähigkeiten

- **Vulnerability Analysis**: Identifizieren Sie Sicherheitsprobleme in Anforderungen und Code
- **Threat Modeling**: Bedrohungen modellieren und Verteidigungsstrategien entwerfen
- **Authentication Patterns**: Sichere Authentifizierung implementieren (JWT, OAuth, Sitzungsverwaltung)
- **Authorization**: Rollenbasierte und attributbasierte Zugriffskontrolle erzwingen
- **Input Validation**: Verhindern Sie XSS-, SQL-Injection- und Command-Injection-Angriffe
- **Secrets Management**: Stellen Sie sicher, dass Geheimnisse niemals fest codiert oder offengelegt werden
- **Security Testing**: Schreiben Sie Tests für Authentifizierungsfehler, Injektionsversuche und Rechteausweitung
- **Dependency Scanning**: Identifizieren Sie anfällige Abhängigkeiten
- **Compliance**: Überprüfen Sie die OWASP Top 10, CWE und Industriestandards
- **Pre-Release Audits**: Obligatorische Sicherheitsüberprüfung vor jeder Veröffentlichung

## Wann zu verwenden

Verwenden Sie den Security Agent, wenn:

- Implementierung von Authentifizierungs- oder Autorisierungsfunktionen
- Umgang mit sensiblen Benutzerdaten (PII, Zahlungsinformationen)
- Verarbeitung von Benutzereingaben (Formulare, APIs)
- Integration mit externen Diensten
- Implementierung von Verschlüsselung oder Geheimnisverwaltung
- Vor der Zusammenführung muss der Sicherheitscode überprüft werden
- Planung einer Veröffentlichung (obligatorisches Pre-Release-Audit)
- Notwendigkeit, Sicherheitsentscheidungen über ADR zu dokumentieren
- Die Sicherheitslücke wurde entdeckt und muss behoben werden

## Wie es funktioniert

1. **Knowledge Loading**: Agent liest Fachwissen und Sicherheitsrecherchen
2. **Story Review**: Agent analysiert die Story auf Sicherheitsauswirkungen
3. **Threat Modeling**: Agent modelliert Bedrohungen für sicherheitskritische Funktionen
4. **Vulnerability Analysis**: Der Agent identifiziert Angriffsvektoren und Gegenmaßnahmen
5. **Security Testing**: Agent schreibt Sicherheitstests (Authentifizierungsfehler, Injektionen, Eskalation)
6. **Verification**: Agent wird ausgeführt `/agileflow:verify` um sicherzustellen, dass die Tests bestanden werden
7. **Documentation**: Agent erstellt ADRs für Sicherheitsentscheidungen
8. **Clearance Decision**: Agent meldet GENEHMIGT / GENEHMIGT MIT MITIGATIONEN / ABGELEHNT
9. **Coordination**: Agent aktualisiert status.json und kommuniziert Ergebnisse

## Beispiel

```bash
# Via babysit - security review of authentication feature
/agileflow:babysit
> "We're implementing JWT-based authentication. Need security review."

# Agent output:
# Security Review: US-0042 - JWT Authentication
#
# Vulnerabilities Found:
# - HIGH: Tokens stored in localStorage (XSS exposure)
# - MEDIUM: No token refresh mechanism (long-lived tokens)
# - MEDIUM: Missing CSRF protection
#
# Recommendations:
# 1. Move tokens to httpOnly cookies (not accessible to JS)
# 2. Implement token refresh with short-lived access tokens
# 3. Add CSRF tokens for state-changing requests
# 4. Validate tokens on every protected endpoint
#
# Security Tests Required:
# - Test invalid token rejection
# - Test expired token handling
# - Test CSRF token validation
# - Test privilege escalation prevention
#
# Clearance: APPROVED WITH MITIGATIONS
# - Implement recommendations above
# - Re-run security tests
# - ADR documenting JWT strategy required
```

## Schlüsselverhalten

- **Security First**: Überspringen Sie niemals Sicherheitskontrollen, um Fristen einzuhalten
- **Defense in Depth**: Mehrere Sicherheitsebenen, kein Single Point of Failure
- **Fail Secure**: Standardmäßig verweigern, explizit zulassen
- **Threat Modeling**: Denken Sie wie ein Angreifer
- **Zero Trust**: Vertrauen Sie niemals Benutzereingaben oder externen Daten
- **Principle of Least Privilege**: Users have minimum necessary permissions
- **Transparency**: Dokumentieren Sie alle Sicherheitsentscheidungen und Abhilfemaßnahmen
- **Context Preservation**: Verwendet „compact_context“ (Priorität: hoch), um den Sicherheitsfokus bei langen Gesprächen beizubehalten und Bedrohungsmodelle und Sicherheitsanforderungen durch Kontextkomprimierung beizubehalten

## Kompakte Kontextkonfiguration

Der Sicherheitsagent verwendet **high priority** compact_context, um sicherzustellen, dass die Sicherheitsüberwachung im Fokus bleibt:

```yaml
compact_context:
  priority: high
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/security/expertise.yaml"
    - "SECURITY FIRST: Never skip security checks to meet deadlines"
    - "DEFENSE IN DEPTH: Multiple layers, not single point of failure"
    - "FAIL SECURE: Default deny, explicit allow (principle of least privilege)"
    - "THREAT MODELING: Think like an attacker, anticipate exploits"
    - "ZERO TRUST: Never trust user input or external data"
    - "NO SECRETS: No hardcoded API keys, credentials, or sensitive data"
  state_fields:
    - current_story
    - threat_model
    - security_requirements
    - vulnerability_findings
    - mitigation_progress
```

Dadurch wird sichergestellt, dass sicherheitskritische Regeln (Bedrohungsmodellierung, Zero Trust, Geheimschutz, Tiefenverteidigung) und der aktuelle Status (bekannte Schwachstellen, Bedrohungsmodelle, Mitigationsstatus) durch Kontextkomprimierung im Fokus bleiben.

## Verfügbare Werkzeuge

- Lesen, Schreiben, Bearbeiten (Dateioperationen)
- Bash (Sicherheitsscans ausführen)
- Glob (sicherheitsrelevante Dateien finden)
- Grep (Suche nach Geheimnissen oder Schwachstellen)

## Sicherheitscheckliste (vor der Veröffentlichung obligatorisch)

Bevor Sie eine Veröffentlichung genehmigen:

- [ ] Keine fest codierten Geheimnisse, API-Schlüssel oder Anmeldeinformationen
- [ ] Alle Benutzereingaben validiert (Typ, Länge, Format, Bereich)
- [ ] Alle Ausgaben codiert/escaped (verhindert XSS, Injektion)
- [ ] Authentifizierung wird auf geschützten Endpunkten erzwungen
- [ ] Autorisierungsprüfungen überprüfen Berechtigungen
- [ ] Ratenbegrenzung verhindert Brute Force und DoS
- [ ] HTTPS erzwungen (kein HTTP in der Produktion)
- [ ] CORS richtig konfiguriert (nicht `*` für Zeugnisse)
- [ ] CSRF-Tokens für Statusänderungsanforderungen erforderlich
- [ ] Abhängigkeiten werden auf Schwachstellen überprüft
- [ ] Fehlermeldungen geben keine Systemdetails preis
- [ ] Bei der Protokollierung werden keine Passwörter/Tokens/PII erfasst
- [ ] SQL verwendet parametrisierte Anweisungen
- [ ] Sicherheitstests umfassen Authentifizierungsfehler, Rechteausweitung und Injektionen
- [ ] Compliance-Anforderungen dokumentiert

## Gemeinsame Sicherheitsmuster

**Authentication (JWT)**:
```javascript
// Good: Secure JWT with expiration
const token = jwt.sign(
  { userId: user.id },
  process.env.JWT_SECRET,
  { algorithm: 'RS256', expiresIn: '1h' }
);

// Bad: No expiration, weak algorithm
const token = jwt.sign(
  { userId: user.id, password: user.password },
  'hardcoded-secret',
  { algorithm: 'HS256' }
);
```

**Authorization (Role-Based)**:
```javascript
// Good: Check permissions on backend
function protectedRoute(req, res) {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden' });
  }
  // ... handle request
}

// Bad: Trust frontend role
if (user.role === 'admin') {
  // ... always true on frontend
}
```

**Input Validation**:
```javascript
// Good: Whitelist valid inputs
const email = req.body.email;
if (!/^[^@]+@[^@]+\.[^@]+$/.test(email)) {
  return res.status(400).json({ error: 'Invalid email' });
}

// Bad: No validation, vulnerable to injection
const query = `SELECT * FROM users WHERE email = '${email}'`;
```

**Secrets Management**:
```javascript
// Good: Load from environment variables
const dbPassword = process.env.DB_PASSWORD;

// Bad: Hardcoded credentials
const dbPassword = 'supersecretpassword123';
```

## Häufige Schwachstellen, die es zu verhindern gilt

| Vulnerability | Risk | Prevention |
|---------------|------|-----------|
| SQL Injection | Data breach | Parameterized queries |
| XSS (Cross-Site Scripting) | Session hijacking | Input sanitization, output encoding |
| CSRF (Cross-Site Request Forgery) | Unauthorized actions | CSRF tokens, SameSite cookies |
| Weak Authentication | Account takeover | Strong passwords, MFA, JWT |
| Hardcoded Secrets | Credential exposure | Environment variables |
| Missing HTTPS | Man-in-the-middle | Enforce HTTPS, HSTS |
| Privilege Escalation | Unauthorized access | Authorization checks |
| Dependency Vulnerabilities | Supply chain attacks | Regular scanning, updates |

## Fehlerschweregrade

| Severity | Description | Example |
|----------|-------------|---------|
| Critical | Security breach, data loss | Unauthenticated API access |
| High | Significant vulnerability | Weak password policy |
| Medium | Notable weakness | Missing CSRF tokens |
| Low | Minor issue | Verbose error messages |

## Bedrohungsmodellierungs-Framework

Fragen Sie nach den wichtigsten Funktionen:

1. **What assets are we protecting?** (Benutzerdaten, Zahlungsinformationen, IP)
2. **Who are the threats?** (Hacker, böswillige Benutzer, Insider)
3. **What attacks are possible?** (SQL-Injection, XSS, Credential Stuffing)
4. **How do we prevent each attack?** (Validierung, Verschlüsselung, Ratenbegrenzung)
5. **What's our defense depth?** (Sicherheitsebenen)
6. **Can we detect attacks?** (Protokollierung, Überwachung, Warnungen)

## Abhängigkeitsscan

Führen Sie vor jeder Veröffentlichung Folgendes aus:

```bash
npm audit              # Find vulnerable packages
npm audit fix         # Update vulnerable packages
npm update            # Update all packages
```

Dokumentergebnisse:
- Welche Pakete sind anfällig?
- Wie hoch ist der Schweregrad?
- Können wir ein Update durchführen oder gibt es einen Workaround?
- Wann wurde dies zuletzt überprüft?

## Verwandte Agenten

- [„Testen“.](/agents/testing) - Implementierung von Sicherheitstests
- [„api“.](/agents/api) - API-Sicherheit und -Validierung
- [„Datenbank“.](/agents/database) - Datenbanksicherheit und Zugriffskontrolle
- [„Entwickler“.](/agents/devops) - Infrastruktursicherheit
- [„ci“.](/agents/ci) - Sicherheitsscan in der CI-Pipeline

## Koordinierung

Der Sicherheitsagent koordiniert sich mit:

- **AG-API**: Stellen Sie die Authentifizierung/Validierung auf Endpunkten sicher
- **AG-UI**: XSS und CSRF im Frontend verhindern
- **AG-DATABASE**: Abfragesicherheit und Zugriffskontrolle überprüfen
- **AG-DEVOPS**: Infrastruktursicherheit, Geheimhaltung
- **AG-TESTING**: Koordinieren Sie die Abdeckung von Sicherheitstests
- **All Agents**: Sicherheitsimplikationen proaktiv kennzeichnen

## Slash-Befehle

- `/agileflow:research:ask TOPIC=...` - Erforschen Sie Sicherheitsmuster
- `/agileflow:ai-code-review` - Überprüfen Sie den Code auf Sicherheitsprobleme
- `/agileflow:adr-new` - Sicherheitsentscheidungen dokumentieren
- `/agileflow:tech-debt` - Sicherheitsschulden dokumentieren
- `/agileflow:impact-analysis` - Analysieren Sie die Sicherheitsauswirkungen von Änderungen
- `/agileflow:status STORY=... STATUS=...` - Aktualisieren Sie den Story-Status

## Sicherheitsprinzipien

- **Never skip security** für Fristen
- **Measure before you fix** - die Verwundbarkeit verstehen
- **Defense in depth** - mehrere Schichten, kein Single Point of Failure
- **Zero trust** - Vertrauen Sie niemals Benutzereingaben oder externen Daten
- **Least privilege** - Erteilen Sie die erforderlichen Mindestberechtigungen
- **Transparent** - alle Sicherheitsentscheidungen dokumentieren
- **Err on side of caution** - Seien Sie im Zweifelsfall restriktiver
