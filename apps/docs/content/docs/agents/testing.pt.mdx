---
title: Teste
description: Especialista em testes para estratégia de teste, padrões de teste, otimização de cobertura e design abrangente de conjunto de testes.
---

# Agente de teste

O Agente de Teste (AG-TESTING) é um especialista especializado em garantia de qualidade que projeta estratégias de teste abrangentes, elimina antipadrões de teste e otimiza a cobertura de teste. Ao contrário da configuração da infraestrutura de CI, este agente concentra-se nas questões “o que testar” e “como testar”.

## Capacidades

- **Test Strategy Design**: Crie planos de teste abrangentes cobrindo testes de unidade, integração e E2E
- **Coverage Optimization**: Analise a cobertura do código e identifique lacunas em caminhos críticos
- **Test Anti-Pattern Detection**: Identifique e elimine testes escamosos, lentos e quebradiços
- **Test Infrastructure**: Crie equipamentos de teste, fábricas e funções auxiliares
- **Coverage Analysis**: Meça e relate métricas de cobertura com recomendações acionáveis
- **Test Pattern Documentation**: Documente padrões de testes reutilizáveis ​​e práticas recomendadas
- **Performance Testing**: Projetar e executar benchmarks de desempenho
- **Mutation Testing**: Teste os próprios testes para garantir a qualidade

## Quando usar

Use o agente de teste quando:

- Iniciando um novo recurso e precisa definir o que precisa ser testado
- A cobertura atual dos testes está abaixo de 70% e precisa de melhorias
- Os testes são instáveis ​​(falhas intermitentes) ou lentos (>1 segundo cada)
- Necessidade de projetar equipamentos de teste ou fábricas para dados de teste complexos
- Configurando infraestrutura de testes automatizados
- Criação de ADRs para testar decisões
- Implementando suítes de testes abrangentes para caminhos críticos

## Como funciona

1. **Knowledge Loading**: O agente lê o arquivo de experiência e o estado de teste do projeto
2. **Story Review**: Agente analisa a história em busca de requisitos de testabilidade
3. **Test Planning**: O agente projeta casos de teste (caminho feliz, casos de erro, casos extremos)
4. **Infrastructure Setup**: O agente cria acessórios de teste, simulações e auxiliares
5. **Test Implementation**: O agente escreve testes seguindo o padrão AAA (Arrange-Act-Assert)
6. **Coverage Measurement**: Agente mede a cobertura e identifica lacunas
7. **Anti-Pattern Elimination**: Agente identifica e corrige testes instáveis/lentos/frágeis
8. **Verification**: Agente é executado `/agileflow:verify` para garantir que todos os testes sejam aprovados
9. **Coordination**: O agente atualiza status.json e se comunica via bus/log.jsonl

## Exemplo

```bash
# Via babysit - identify testing work
/agileflow:babysit
> "We need comprehensive testing for the payment processing feature"

# Agent output:
# Test Strategy Created:
# - Unit tests: Payment validation, transaction formatting (80% coverage)
# - Integration tests: Database saves, external API calls (15% coverage)
# - E2E tests: Complete payment workflow (5% coverage)
# - Coverage target: 85% critical path
# - Expected test count: 47 tests
# - Estimated time: 4 hours
```

## Comportamentos-chave

- **AAA Pattern**: Todos os testes seguem a estrutura Arrange-Act-Assert para maior clareza
- **Test Isolation**: testes unitários de dependências simuladas; testes de integração usam dependências reais
- **Behavior-Focused**: os testes validam o comportamento, não os detalhes da implementação
- **Fast Execution**: testes unitários são executados em milissegundos; suíte completa em minutos
- **Clear Naming**: Os nomes dos testes descrevem exatamente o que está sendo testado
- **Coverage Thresholds**: 70% no mínimo, 80%+ para caminhos críticos (100% para autenticação/pagamento)
- **No Flaky Tests**: Falhas intermitentes são sinais de alerta; aleatoriedade e tempo removidos
- **Performance Awareness**: Os testes não são mais lentos que o código que testam
- **Context Preservation**: Usa compact_context (prioridade: alta) para manter o foco do teste durante longas conversas, preservando alvos de cobertura e detecção de antipadrão por meio de compactação de contexto

## Configuração de contexto compacto

O agente de teste usa **high priority** compact_context para garantir que a cobertura e a qualidade do teste permaneçam em foco:

```yaml
compact_context:
  priority: high
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/testing/expertise.yaml"
    - "AAA PATTERN: All tests follow Arrange-Act-Assert structure"
    - "COVERAGE MINIMUM: 70% coverage required, 80%+ for critical paths"
    - "NO FLAKY TESTS: Eliminate randomness, timing issues, intermittent failures"
    - "TEST ISOLATION: Unit tests mock, integration tests use real dependencies"
    - "VERIFY PASSES: Run /agileflow:verify before marking in-review"
  state_fields:
    - current_story
    - coverage_percentage
    - critical_paths_count
    - flaky_tests_found
    - test_status_baseline
```

Isso garante que as regras críticas de teste (padrão AAA, mínimos de cobertura, práticas de teste anti-instáveis) e o estado atual (lacunas de cobertura, contagens de testes instáveis, status de teste de caminho crítico) permaneçam em foco por meio da compactação de contexto.

## Ferramentas disponíveis

- Ler, escrever, editar (operações de arquivo)
- Bash (executa comandos de teste)
- Glob (encontrar arquivos de teste)
- Grep (código de teste de pesquisa)

## Integração de chicote de sessão

O Agente de Teste integra-se ao Session Harness para garantir a qualidade:

```text
Pre-Implementation:
├── Check environment.json exists
├── Verify test_status: "passing" baseline
└── Run /agileflow:session:resume

During Implementation:
├── Run tests incrementally
├── Fix failures immediately
└── Update test_status in real-time

Post-Implementation:
├── Run /agileflow:verify US-XXXX (must pass)
├── Verify test_status: "passing"
└── Mark story "in-review" ONLY if tests pass
```

## Categorias e alvos de teste

| Category | Percentage | Speed | Scope |
|----------|-----------|-------|-------|
| Unit Tests | 80% | under 1ms each | Single function, mocked dependencies |
| Integration Tests | 15% | Slower | Multiple components, real dependencies |
| E2E Tests | 5% | Very slow | Full user workflows |
| Contract Tests | 0-5% | Fast | API schema validation |

## Lista de verificação de qualidade

Antes de marcar uma história como concluída:

- [ ] Cobertura de teste ≥70% (caminhos críticos 100%)
- [] Todos os cenários de caminho feliz testados
- [] Todos os cenários de erro testados
- [] Casos extremos identificados e testados
- [] Sem testes instáveis ​​(executar 10x, todos passam)
- [] Sem testes lentos (cada teste em 1s, conjunto completo em 5min)
- [] Testa o comportamento do teste, não a implementação
- [] Os nomes dos testes descrevem claramente o que foi testado
- [] Dispositivos de teste reutilizáveis ​​e bem documentados
- [] Relatório de cobertura gerado e revisado
- [] test_status: "aprovado" verificado

## Padrões de teste comuns

**AAA Pattern (Arrange-Act-Assert)**:
```javascript
describe('validateEmail', () => {
  it('rejects invalid formats', () => {
    // Arrange
    const email = 'invalid@';

    // Act
    const result = validateEmail(email);

    // Assert
    expect(result).toBe(false);
  });
});
```

**Test Fixtures (Reusable test data)**:
```javascript
const validUser = { id: 1, email: 'user@example.com', name: 'John' };
const invalidUser = { id: 2, email: 'invalid@', name: 'Jane' };
```

**Parameterized Tests**:
```javascript
test.each([
  ['valid@example.com', true],
  ['invalid@', false],
  ['no-at-sign.com', false],
])('validates email %s', (email, expected) => {
  expect(validateEmail(email)).toBe(expected);
});
```

## Antipadrões para eliminar

| Anti-Pattern | Problem | Fix |
|--------------|---------|-----|
| Flaky tests | Intermittent failures, unpredictable | Remove randomness, add waits for conditions |
| Slow tests | >1 second each | Use mocks, parallelize, optimize queries |
| Brittle tests | Break on refactoring | Test behavior, not implementation details |
| Over-mocking | Unrealistic isolation | Balance unit and integration tests |

## Agentes Relacionados

- [`qa`](/agents/qa) - Estratégia de teste e prontidão para lançamento (escopo diferente)
- [`ci`](/agents/ci) - Infraestrutura de teste e configuração de pipeline de CI
- [`api`](/agents/api) - Teste de API e validação de contrato
- [`ui`](/agents/ui) - Teste de componentes e testes de interação do usuário
- [`banco de dados`](/agents/database) - Teste de camada de dados e otimização de consultas

## Coordenação

O Agente de Teste coordena com outros agentes:

- **AG-API**: Certifique-se de que os casos de erro da API sejam testados
- **AG-UI**: Coordenação de testes de componentes e E2E
- **AG-DATABASE**: Teste a camada de dados e o desempenho da consulta
- **AG-CI**: Solicitar infraestrutura de teste (execução paralela, relatórios de cobertura)
- **AG-QA**: Alinhar métricas de qualidade e metas de cobertura de teste

## Comandos de barra

- `/agileflow:verify US-XXXX` - Execute testes para uma história específica
- `/agileflow:research:ask TOPIC=...` - Padrões de teste de pesquisa
- `/agileflow:ai-code-review` - Revise o código de teste para antipadrões
- `/agileflow:adr-new` - Documentar decisões de teste
- `/agileflow:status STORY=... STATUS=...` - Atualizar status da história
