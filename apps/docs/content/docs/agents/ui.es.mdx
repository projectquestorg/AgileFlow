---
title: interfaz de usuario
description: Especialista en UI/capa de presentación para implementar componentes front-end, estilo, accesibilidad y experiencia de usuario.
---

# Agente de interfaz de usuario

El agente UI (AG-UI) es su especialista en frontend. Implementa componentes responsivos, sistemas de estilo, tokens de diseño, funciones de accesibilidad (WCAG 2.1 AA) y aplica principios de psicología UX para crear interfaces que sean hermosas y utilizables.

## Capacidades

- Cree componentes responsivos (de 320 px a 1920 px+)
- Implementar sistemas de diseño con tokens (colores, espaciado, tipografía)
- Garantizar la accesibilidad WCAG 2.1 AA (navegación por teclado, lectores de pantalla, contraste)
- Aplicar leyes de UX (Jakob's, Hick's, Fitts's, Gestalt, Von Restorff, Peak-End, Doherty)
- Escribir pruebas de componentes (unidad, integración, accesibilidad con axe-core)
- Construya con un diseño centrado en los dispositivos móviles
- Integre con puntos finales API
- Crear temas y soporte para modo oscuro
- Mantenga la coherencia del diseño en todas las aplicaciones
- Escribir microcopia y texto de ayuda.

## Cuando usar

Utilice el agente UI cuando:

- Necesita implementar un nuevo componente o característica
- Necesitas crear un sistema de diseño o tokens de diseño.
- Quieres mejorar la accesibilidad (navegación por teclado, lectores de pantalla)
- Debe hacer que la interfaz de usuario responda a través de puntos de interrupción
- Quieres aplicar las mejores prácticas y principios psicológicos de UX
- Necesita integrar componentes con puntos finales API
- Necesita escribir pruebas integrales de componentes.
- Quiere mejorar el rendimiento percibido y los comentarios de los usuarios.

## Cómo funciona

1. **Context Loading**: El agente lee los documentos de experiencia, CLAUDE.md y el sistema de diseño.
2. **Design System Check**: El agente verifica si existe el sistema de diseño (solo el primer piso)
3. **Status Check**: El agente encuentra historias listas y busca bloqueadores de API
4. **Definition of Ready**: El agente valida los criterios de aceptación y los talones de prueba.
5. **Plan Mode**: Para funciones complejas, el agente diseña la estructura de componentes.
6. **Implementation**: El agente crea componentes utilizando tokens de diseño.
7. **Accessibility**: El agente garantiza la compatibilidad con la navegación por teclado y el lector de pantalla.
8. **UX Laws**: El agente aplica principios psicológicos de la investigación UX.
9. **Testing**: El agente escribe pruebas unitarias, de integración y de accesibilidad.
10. **Verification**: El agente ejecuta pruebas para garantizar que se apruebe la línea base.

## Ejemplo

```bash
# Via /babysit (recommended)
/agileflow:babysit
> "I need to implement a user profile page"
```

El agente de UI:
1. Verifique el sistema de diseño (créelo si falta)
2. Busque dependencia de API (GET /api/users/:id)
3. Componentes de diseño:
   - ProfileCard (muestra información del usuario)
   - ProfileForm (editar información de usuario)
   - AvatarUpload (cambiar avatar)
4. Implementar con tokens de diseño:
   - Colores del sistema de diseño (sin #colores codificados)
   - Espaciado desde la escala del token (sin codificación fija de 16 píxeles)
   - Tipografía del sistema de diseño.
5. Garantizar la accesibilidad:
   - Navegación con teclado (tabulación a través de campos de formulario)
   - Lector de pantalla (etiquetas de formulario asociadas)
   - Contraste de color (4,5:1 para texto)
6. Aplicar las leyes de UX:
   - Jakob's: diseño de formulario familiar
   - Compatible con objetivos táctiles grandes (44 px+)
   - Peak-End: animación exitosa al guardar
7. Escribir pruebas (unitarias + integración + accesibilidad)
8. Marcar en revisión cuando pasen las pruebas

O generar directamente:

```text
Task(
  description: "Implement product card component",
  prompt: "Create reusable card for products with image, price, rating. Mobile-first design.",
  subagent_type: "agileflow-ui"
)
```

## Comportamientos clave

- **Load Expertise First**: Lee expert.yaml antes de cualquier trabajo.
- **Design System Proactive**: Comprueba el sistema de diseño en el primer piso, crea si falta
- **Refactor to Tokens**: Ofertas para migrar estilos codificados al sistema de diseño
- **Mobile-First**: Estilos base para dispositivos móviles (320 px), luego agrega puntos de interrupción
- **Accessibility Default**: Cada componente incluye soporte para navegación por teclado y lector de pantalla
- **UX Laws Applied**: Utiliza principios psicológicos (proximidad, contraste, posibilidades)
- **Token Usage**: Todos los estilos utilizan tokens de diseño, nunca valores codificados
- **Session Harness Integration**: Verifica el estado de la prueba antes de comenzar, requiere pasar pruebas
- **Autonomous Commands**: Invoca directamente /agileflow:impact-analysis, /agileflow:adr-new, etc.
- **Bus Coordination**: Envía un mensaje bloqueado a AG-API si falta el punto final
- **README Updates**: actualiza proactivamente la documentación después de cambios significativos
- **Context Preservation**: Utiliza compact_context (prioridad: alta) para mantener el enfoque durante conversaciones largas, preservando la detección del sistema de diseño y el seguimiento de la dependencia de API a través de la compactación del contexto.

## Configuración de contexto compacto

El agente de UI usa **high priority** compact_context para garantizar que el sistema de diseño y las dependencias de API permanezcan enfocados:

```yaml
compact_context:
  priority: high
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/ui/expertise.yaml"
    - "CHECK DESIGN SYSTEM FIRST: Detect if design tokens exist; create if missing"
    - "VERIFY SESSION HARNESS: Check environment.json and test_status baseline"
    - "ONLY in-review if tests pass: test_status:passing required"
    - "CHECK FOR API DEPENDENCIES: Search status.json for blocked UI stories"
    - "APPLY UX LAWS: Jakob's, Hick's, Fitts's, Gestalt, Von Restorff, Peak-End, Doherty"
    - "ACCESSIBILITY REQUIRED: WCAG 2.1 AA minimum"
  state_fields:
    - current_story
    - design_system_status
    - api_dependencies
    - test_status_baseline
```

Esto garantiza que las reglas críticas de la interfaz de usuario (detección del sistema de diseño, estándares de accesibilidad, verificación de bloqueadores de API) y el estado actual (qué tokens de diseño existen, qué puntos finales de API se necesitan) persistan a través de la compactación del contexto.

## Herramientas disponibles

Este agente tiene acceso a: Leer, Escribir, Editar, Bash, Glob, Grep

## Fichas del sistema de diseño

Un sistema bien diseñado incluye:

```typescript
// Colors
export const colors = {
  primary: '#3b82f6',
  primaryHover: '#2563eb',
  text: '#1f2937',
  textSecondary: '#6b7280',
  background: '#ffffff',
  error: '#ef4444',
  success: '#10b981',
};

// Spacing (8px scale)
export const spacing = {
  xs: '0.25rem',  // 4px
  sm: '0.5rem',   // 8px
  md: '1rem',     // 16px
  lg: '1.5rem',   // 24px
  xl: '2rem',     // 32px
};

// Typography
export const typography = {
  fontFamily: {
    base: 'system-ui, -apple-system, sans-serif',
    mono: '"Courier New", monospace',
  },
  fontSize: {
    xs: '0.75rem',   // 12px
    sm: '0.875rem',  // 14px
    base: '1rem',    // 16px
    lg: '1.125rem',  // 18px
    xl: '1.25rem',   // 20px
  },
};

// Breakpoints
export const breakpoints = {
  sm: '640px',
  md: '768px',
  lg: '1024px',
  xl: '1280px',
};
```

## Lista de verificación de accesibilidad

WCAG 2.1 AA mínimo para todos los componentes:

**Keyboard Navigation**:
- El orden de las pestañas es lógico y visible.
- Todos los elementos interactivos accesibles a través de Tab
- Enter/Space activa los botones
- Escape cierra modales
- Teclas de flecha para navegar por listas

**Screen Readers**:
- HTML semántico (`<button>`, `<nav>`, `<main>`, `<article>`)
- Texto alternativo para imágenes (descriptivo, no decorativo)
- etiqueta-aria para botones de solo íconos
- aria-live para actualizaciones dinámicas
- Etiquetas de formulario asociadas (para = atributo)

**Color & Contrast**:
- Contraste del texto: 4,5:1 mínimo
- Contraste de los componentes de la interfaz de usuario: mínimo 3:1
- No confíes únicamente en el color (error = rojo + icono + texto)
- Prueba con simuladores daltónicos

## Leyes y principios de UX

**Jakob's Law**: Los usuarios esperan patrones familiares
- Utilice la navegación estándar (logotipo arriba a la izquierda, búsqueda arriba a la derecha)
- Interacciones y diseños de formularios familiares
- No innovar a nivel de microinteracción

**Hick's Law**: Más opciones = decisiones más lentas
- Minimizar opciones en pantallas críticas
- Divida las tareas complejas en pasos
- Utilice filtros/búsqueda de listas grandes

**Fitts's Law**: La distancia + el tamaño afectan el tiempo objetivo
- Objetivos táctiles mínimo 44×44px (móvil), 40×40px (escritorio)
- Espacio adecuado entre elementos en los que se puede hacer clic
- Acciones importantes al alcance del pulgar en el móvil

**Gestalt Principles**: Los humanos agrupan elementos visuales.
- Proximidad: Agrupar elementos relacionados muy juntos.
- Similitud: Mismo color/forma/tamaño = misma categoría
- Región común: los elementos en los bordes están agrupados
- Prägnanz: utilice la forma visual más simple

**Von Restorff Effect**: Destacan elementos distintivos
- Se destaca una CTA principal por pantalla
- El resto son de estilo secundario/terciario.
- Patrón de Netflix: botones rojos solo para acciones principales

**Peak-End Rule**: Users remember peaks and endings
- Cree momentos memorables en estados de éxito
- Haga que los finales sean agradables (celebre las victorias)
- Instagram: la animación del corazón es retroalimentación instantánea

**Doherty Threshold**: La respuesta por debajo de 400 ms resulta adictiva
- Proporciona retroalimentación visual inmediata (menos de 400 ms)
- Utilice una interfaz de usuario optimista (muestre el resultado antes de que el servidor lo confirme)
- Pantallas esqueléticas durante la carga.
- Nunca hagas esperar a los usuarios sin comentarios

**Tesler's Law**: La complejidad no se puede eliminar, sólo mover
- Absorber la complejidad en el sistema, no en el usuario
- Autocompletar campos desde el contexto
- Los valores predeterminados inteligentes reducen las decisiones
- Sugerencia basada en la historia.

## Estándares de prueba

Cada componente necesita pruebas exhaustivas:

```typescript
// Unit test (component logic)
test('Button renders with correct label', () => {
  const { getByText } = render(<Button>Click me</Button>);
  expect(getByText('Click me')).toBeInTheDocument();
});

// Integration test (user flow)
test('Form submits with valid data', async () => {
  const { getByLabelText, getByRole } = render(<UserForm />);
  const emailInput = getByLabelText('Email');
  const submitBtn = getByRole('button', { name: /submit/i });

  fireEvent.change(emailInput, { target: { value: 'test@example.com' } });
  fireEvent.click(submitBtn);

  await waitFor(() => {
    expect(mockSubmit).toHaveBeenCalled();
  });
});

// Accessibility test (axe-core)
test('Button meets accessibility standards', async () => {
  const { container } = render(<Button>Click me</Button>);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

## Enfoque móvil primero

**Base Styles** (Móvil - 320 px):

```css
.card {
  padding: var(--spacing-md);
  font-size: var(--font-size-base);
  grid-template-columns: 1fr; /* Single column */
}
```

**Tablet Breakpoint** (768 píxeles+):

```css
@media (min-width: 768px) {
  .card {
    padding: var(--spacing-lg);
    grid-template-columns: 1fr 1fr; /* 2 columns */
  }
}
```

**Desktop Breakpoint** (1024px+):

```css
@media (min-width: 1024px) {
  .card {
    padding: var(--spacing-xl);
    grid-template-columns: repeat(3, 1fr); /* 3 columns */
  }
}
```

## Puntos de interrupción responsivos

- **Mobile**: 320 px a 639 px (estilos base)
- **Tablet**: 640px a 1023px (@media min-width: 640px)
- **Desktop**: 1024px a 1279px (@media min-width: 1024px)
- **Large Desktop**: 1280px+ (@media min-width: 1280px)

## Archivos clave

- **Expertise**: `packages/cli/src/core/experts/ui/expertise.yaml` (memoria del agente)
- **Workflow**: `packages/cli/src/core/experts/ui/workflow.md` (Planificar → Construir → Automejorar)
- **Status**: `docs/09-agents/status.json` (seguimiento de la historia)
- **Bus**: `docs/09-agents/bus/log.jsonl` (mensajes de coordinación)
- **Design Tokens**: `src/theme/tokens.ts` o `src/styles/design-tokens.css`
- **Components**: `src/components/` (archivos componentes)
- **Tests**: `src/components/*.test.tsx` (archivos de prueba)
- **CLAUDE.md**: Enfoque de estilo, patrones de componentes, estándares de prueba.

## Pasos del flujo de trabajo

1. **Load Expertise**: Leer experiencia.yaml
2. **Check Design System**: Solo la primera historia; crear si falta
3. **Check Status**: Encuentra historias LISTAS donde propietario==AG-UI
4. **Check API Dependencies**: Busque bloqueadores AG-API
5. **Validate Definition of Ready**: AC existe, código auxiliar de prueba en docs/07-testing/test-cases/
6. **Check Session Harness**: Verifique test_status==pasado antes de comenzar
7. **Create Branch**: `feature/<US_ID>-<slug>`
8. **Update Status**: Marcar "en progreso", agregar mensaje de bus
9. **Implement**: Componentes que utilizan tokens de diseño (diferencia primero, SÍ/NO)
10. **Accessibility**: Garantizar la compatibilidad con la navegación por teclado y el lector de pantalla
11. **UX Laws**: Aplicar principios psicológicos
12. **Write Tests**: Unidad + integración + accesibilidad
13. **Run Verification**: /agileflow:verificar para garantizar que las pruebas pasen
14. **Update CLAUDE.md**: Si se establecen nuevos patrones de UI
15. **Update README**: Documentar proactivamente nuevos componentes o patrones
16. **Mark In-Review**: Sólo si test_status==pasando
17. **Generate PR**: Utilice /agileflow:pr-template
18. **Self-Improve**: Ejecute self-improve.md después de finalizar

## Lista de control de calidad

Antes de marcar en revisión:

**Functionality**:
- [] Responsivo en todos los puntos de interrupción (320 px a 1920 px+)
- [] Todos los elementos interactivos tienen estados de desplazamiento/enfoque/activo
- [] Se procesa correctamente en todos los estados (cargando, error, vacío, éxito)
- [] Sin errores ni advertencias de consola

**Accessibility**:
- [] Navegación con teclado completamente funcional (Tab, Enter, Escape, Flechas)
- [] Compatibilidad con lectores de pantalla (HTML semántico, etiquetas aria)
- [] Contraste de color 4.5:1 (texto), 3:1 (UI)
- [] Indicadores de enfoque claramente visibles

**Design**:
- [] Utiliza tokens de diseño (sin colores, espacios ni fuentes codificados)
- [] Jerarquía tipográfica clara
- [] Espaciado consistente (cuadrícula de 8px)
- [ ] Enfoque móvil primero

**UX**:
- [] Ley de Jakob: patrones familiares
- [] Ley de Fitts: objetivos táctiles de más de 44 px, espacio adecuado
- [] Ley de Hick: elecciones mínimas
- [] Von Restorff: Destaca una CTA principal
- [] Regla del pico final: momentos de éxito memorables

**Testing**:
- [] Pruebas unitarias para la lógica de componentes
- [ ] Pruebas de integración para flujos de usuarios
- [] Pruebas de accesibilidad (axe-core, jest-axe)
- [] Las pruebas cubren el camino feliz + casos extremos + estados de error

## Coordinación con otros agentes

**AG-API (Backend)**:
- Verifique status.json para conocer el estado del punto final de la API
- Marcar bloqueado si el punto final no está listo
- Envíe un mensaje de desbloqueo a AG-API si necesita un punto final
- Ejemplo: `"Blocked: needs GET /api/users/:id endpoint from US-0040"`

**AG-CI (Testing)**:
- Coordinar la infraestructura de prueba (axe-core, jest-axe)
- Solicite la configuración de la base de datos de prueba si es necesario
- Garantizar pruebas de componentes en CI

**MENTOR (Orchestration)**:
- Solicitar aclaración sobre requisitos poco claros
- Informar si falta una historia Definición de Listo

## Agentes Relacionados

- [`api`](/agents/api) - Puntos finales de backend que alimentan los componentes de la interfaz de usuario
- [`base de datos`](/agents/database) - API subyacente de la capa de datos
- [`mentor`](/agents/mentor) - Orquesta el trabajo de la interfaz de usuario como parte de la implementación de funciones.
