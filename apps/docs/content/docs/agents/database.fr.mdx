---
title: Base de données
description: Spécialiste des bases de données pour la conception de schémas, les migrations, l'optimisation des requêtes et la modélisation des données.
---
#Agent de base de données

L'agent de base de données (AG-DATABASE) est votre spécialiste des bases de données pour concevoir des schémas efficaces, écrire des migrations sécurisées, optimiser les requêtes et gérer l'intégrité des données. Il garantit que votre couche de base de données est performante, maintenable et fiable.

## Capacités

- Concevoir des schémas de bases de données efficaces (tables, relations, contraintes)
- Écrire des scripts de migration réversibles avec des stratégies de restauration
- Optimiser les requêtes lentes (identifier les index manquants, améliorer la structure des requêtes)
- Prévenir les problèmes de requêtes N+1 et les anti-modèles SELECT *
- Assurer l'intégrité des données grâce aux contraintes et à la validation
- Examiner les requêtes d'AG-API pour les problèmes de performances
- Documenter les modèles de données et les relations avec les ADR d'architecture
- Coordonner avec AG-API sur l'utilisation d'ORM et les modèles de requêtes
- Surveiller les performances et la santé de la base de données

## Quand l'utiliser

Utilisez l'agent de base de données lorsque :

- Vous devez concevoir une nouvelle table ou structure de relation
- Vous devez créer un script de migration pour les modifications de schéma
- Vous remarquezfaibles requêtes ou problèmes de performances
- Vous souhaitez optimiser une requête de base de données complexe
- Vous devez ajouter des index aux colonnes fréquemment interrogées
- Vous concevez des modèles de données pour une nouvelle fonctionnalité
- Vous souhaitez empêcher les modèles de requête N+1 avant qu'ils ne se produisent
- Vous devez coordonner le travail de la couche de données avec AG-API

## Comment ça marche

1. **Chargement du contexte** : l'agent lit l'expertise, CLAUDE.md et la configuration de la base de données
2. **Revue de l'histoire** : l'agent identifie les exigences et les relations en matière de données
3. **Mode Plan** : l'agent conçoit un schéma et une stratégie de migration (pour les modifications à haut risque)
4. **Conception de schéma** : l'agent crée des diagrammes entité-relation et normalise les données
5. **Création de migration** : l'agent écrit des scripts up/down réversibles avec tests
6. **Coordination** : l'agent partage le schéma avec AG-API et examine ses requêtes
7. **Optimisation** : l'agent ajoute des index et empêche les modèles de requête N+1
8. **Vérification** : l'agent exécute des tests pour s'assurer que tout réussit
9. **Documentation** : l'agent met à jour status.json et l'applicationtermine les messages du bus

## Exemple

```bash
# Via /babysit (recommended)
/agileflow:babysit
> "I need to design the database schema for users and posts"
```

L'agent de base de données :
1. Renseignez-vous sur les relations entre les données (un utilisateur vers plusieurs publications ?)
2. Concevoir un schéma normalisé :
   - Table `users` : identifiant, email, nom d'utilisateur, mot de passe_hash, créé_at, mis à jour_at
   - Table `posts` : id, user_id, titre, contenu, créé_at, mis à jour_at
   - Contrainte de clé étrangère : posts.user_id → users.id
3. Index du plan : idx_users_email (pour la connexion), idx_posts_user_id (pour les requêtes)
4. Créez un script de migration avec des opérations haut/bas
5. Coordonner avec AG-API sur les modèles et requêtes ORM
6. Testez l’annulation de la migration avant la fin

Ou apparaissez directement :

```text
Task(
  description: "Optimize slow user profile query",
  prompt: "Query is taking 2+ seconds. Need to analyze and add missing indexes.",
  subagent_type: "agileflow-database"
)
```

## Comportements clés

- **Ne jamais apporter de modifications sans migration** : toutes les modifications de schéma nécessitent des scripts de migration réversibles
- **Mode Plan pour les modifications à haut risque** : utilise toujours le mode Plan pour concevoir une stratégie de schéma/migration
- **Migrations réversibles** : chaque migration « vers le haut » correspond à un « vers le bas » pour la restauration.
- **Optimisation des requêtes** : analyse les requêtespour les problèmes N+1, index manquants, SELECT * anti-modèles
- **Conventions de dénomination** : tableaux en minuscules pluriels (utilisateurs, publications), colonnes Snake_case (user_id, Create_at)
- **Colonnes obligatoires** : chaque table a un identifiant, create_at, update_at (et delete_at pour les suppressions logicielles)
- **Coordination avec AG-API** : examine leurs requêtes et l'utilisation de l'ORM ; suggère des optimisations
- **Intégration du harnais de session** : vérifie l'état des tests avant de commencer, nécessite la réussite des tests avant la révision
- **Documentation proactive** : crée des ADR pour les décisions de schéma majeures
- **Préservation du contexte** : utilise compact_context (priorité : élevée) pour rester concentré pendant les longues conversations, en préservant les décisions de schéma et le suivi de l'optimisation des performances grâce au compactage du contexte.

## Configuration du contexte compact

L'agent de base de données utilise compact_context **haute priorité** pour garantir que les décisions de conception et d'optimisation du schéma restent préservées :

```yaml
compact_context:
  priority: high
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/database/expertise.yaml"
    - "NEVER CHANGE SCHEMA WITHOUT MIGRATION: All changes require reversible up/down scripts"
    - "PLAN MODE FOR HIGH-RISK CHANGES: Design schema/migration strategy before implementation"
    - "VERIFY TEST BASELINE: Check test_status before starting new work"
    - "REQUIRED COLUMNS: Every table needs id, created_at, updated_at"
    - "COORDINATION WITH AG-API: Review their queries and ORM patterns"
  state_fields:
    - current_story
    - schema_changes_planned
    - migration_strategy
    - api_query_reviews
    - test_status_baseline
```

Cela garantit les règles critiques pour la base de données (exigences de migration, nom de schéma)g conventions, required columns) and current state (what schema changes are planned, which API queries need review) remain in focus through context compaction.

## Tools Available

This agent has access to: Read, Write, Edit, Bash, Glob, Grep

## Schema Design Principles

**Normalization**: Reduce data redundancy while improving data integrity

- Minimize duplicate data
- One source of truth per field
- Denormalize only when performance demands justify it (document why)

**Naming Conventions**:

- Tables: lowercase, plural (users, products, orders)
- Columns: lowercase, snake_case (first_name, created_at)
- Foreign keys: table_id format (user_id, product_id)
- Indexes: idx_table_column format (idx_users_email)

**Required Columns**:

- `id`: Primary key (UUID or auto-increment)
- `created_at`: When record was created
- `updated_at`: When record was last modified
- `deleted_at`: Soft delete timestamp (if using soft deletes)

**Relationships**:

- One-to-many: Foreign key in many table
- Many-to-many: Junction table with two foreign keys
- One-to-one: Foreign key with unique constraint

## Query Optimization Patterns

**Identify Slow Queries**:

```sql
-- Enable query logging for queries > 100ms
-- Use database explain plan
EXPLAIN ANALYZE SELECT ...
```

**Optimize Queries**:

- Add indexes on frequently queried columns (WHERE, JOIN, ORDER BY)
- Use EXPLAIN PLAN to verify index usage
- Batch queries (load multiple records in single query)
- Use CTEs/window functions for complex aggregations

**Common Issues**:

```sql
-- BAD: N+1 problem
SELECT * FROM users;
-- Loop: SELECT * FROM posts WHERE user_id = $1;

-- GOOD: Single query with JOIN
SELECT users.*, posts.*
FROM users
LEFT JOIN posts ON users.id = posts.user_id;

-- BAD: Missing index
SELECT * FROM users WHERE email = $1;

-- GOOD: Add index on email
CREATE INDEX idx_users_email ON users(email);
```

## Migration Best Practices

**Safe Migrations**:

1. Add new columns as nullable (can backfill gradually)
2. Create indexes before dropping old columns
3. Test rollback plan before deploying
4. Backup before running destructive migration
5. Run in maintenance window if production impact possible

**Reversible Migrations**:

- Every "up" migration has corresponding "down"
- Down migration tested before deploying up
- Example: Add column (up) / Drop column (down)

## Coordination with AG-API

**Schema DesPhase d'allumage** :

- AG-API décrit les besoins en données
- Schéma de conception AG-DATABASE
- Examiner ensemble les opportunités d'optimisation

**Phase de mise en œuvre** :

- AG-DATABASE crée un script de migration
- AG-API implémente des modèles ORM
- Coordonner le chargement des relations (impatients ou paresseux)

**Phase d'optimisation des requêtes** :

- AG-API développe des requêtes
- Revues AG-DATABASE pour N+1 et optimisation
- Ajouter des index si nécessaire

## Fichiers clés

- **Expertise** : `packages/cli/src/core/experts/database/expertise.yaml` (mémoire des agents)
- **Workflow** : `packages/cli/src/core/experts/database/workflow.md` (Planifier → Construire → Auto-amélioration)
- **Statut** : `docs/09-agents/status.json` (suivi de l'histoire)
- **Bus** : `docs/09-agents/bus/log.jsonl` (messages de coordination)
- **CLAUDE.md** : Type de base de données et informations ORM
- **Recherche** : `docs/10-research/` (vérifier les modèles de conception de schéma)
- **ADR** : `docs/03-decisions/` (décisions d'architecture de base de données)

## Étapes du flux de travail

1. **Charger l'expertise** : lisez expertise.yaml pour charger les connaissances sur le schéma
2. **Revoir l'histoire** : identifier les exigences et les relations en matière de données
3. **Entrez en mode Plan** : Dconcevoir un schéma, une stratégie de migration, analyser l'impact
4. **Créer un schéma** : définissez des tables, des colonnes, des contraintes et des relations
5. **Créer une migration** : écrivez des scripts haut/bas réversibles
6. **Statut de la mise à jour** : marquez "en cours"
7. **Ajouter un message de bus** : coordonner avec AG-API
8. **Test de migration** : testez les opérations de montée et de descente
9. **Optimiser** : ajoutez des index basés sur des modèles de requête
10. **Vérifier** : exécutez des tests pour garantir la réussite de la ligne de base
11. **Mark In-Review** : mettre à jour le statut uniquement lorsque test_status==réussite
12. **Self-Improve** : exécutez self-improve.md une fois terminé

## Liste de contrôle qualité

Avant de marquer en révision :

- [ ] Le schéma suit les conventions de dénomination
- [ ] Toutes les colonnes obligatoires présentes (id, create_at, update_at)
- [ ] Relations correctement définies (clés étrangères, contraintes)
- [ ] Les migrations sont réversibles
- [ ] Migrations testées (montantes et descendantes)
- [ ] Index sur les colonnes fréquemment interrogées
-[ ] Aucun modèle de requête N+1 prévu
- [ ] Contraintes d'intégrité des données appliquées
- [ ] Les commentaires expliquent le complexe ddécisions
- [ ] Procédure de sauvegarde et de récupération documentée
- [ ] Statut du test : réussite (vérifié via /agileflow:verify)

## Agents associés

- [`api`](/agents/api) - Implémente des modèles et des requêtes ORM basés sur un schéma
- [`mentor`](/agents/mentor) - Orchestre le travail de base de données dans le cadre de la mise en œuvre des fonctionnalités
- [`ci`](/agents/ci) - Configure les bases de données de test et l'infrastructure de test de migration