---
title: Performance
description: Spécialiste des performances pour l'optimisation, le profilage, l'analyse comparative, l'évolutivité et les fonctionnalités critiques en termes de performances.
---
# Agent de performances

L'agent de performance (AG-PERFORMANCE) est un spécialiste de l'optimisation des performances qui identifie les goulots d'étranglement, optimise les chemins critiques et garantit que les applications atteignent les objectifs de performances. Cet agent se concentre d’abord sur l’optimisation des mesures, et non sur des suppositions prématurées.

## Capacités

- **Profilage des performances** : identifiez les goulots d'étranglement réels avec des outils de profilage
- **Création de benchmark** : mesurez les performances avant et après les optimisations
- **Optimisation de la base de données** : éliminez les requêtes N+1, ajoutez des index, optimisez les requêtes
- **Stratégies de mise en cache** : implémentez la mise en cache en mémoire, Redis, CDN et HTTP
- **Optimisation du frontend** : réduction de la taille du bundle, fractionnement du code, chargement paresseux
- **Optimisation de l'API** : réduisez les temps de réponse, éliminez les opérations coûteuses
- **Test de charge** : testez les limites d'évolutivité et trouvez les points de rupture
- **Surveillance des performances** : configurez des alertes pour les régressions de performances
- **Analyse d'évolutivité** : comprenez comment le système évolue avec la charge
- **Documentationn** : Créez des ADR pour les compromis en matière de performances

## Quand l'utiliser

Utilisez l'agent de performances dans les cas suivants :

- Les temps de réponse sont lents et doivent être optimisés
- Les requêtes de base de données sont lentes ou il y a des problèmes N+1
- La taille du bundle frontend est grande
- Nécessité de tester les limites d'évolutivité
- L'utilisation de la mémoire est élevée ou en croissance
- Les points de terminaison de l'API dépassent les objectifs de performances
- Nécessité de mettre en œuvre des stratégies de mise en cache
- Établir des référentiels de performances
- Création d'un suivi des performances et d'alertes
- Nécessité de documenter les décisions de performance

## Comment ça marche

1. **Chargement des connaissances** : l'agent lit les objectifs d'expertise et de performance
2. **Analyse** : l'agent examine l'histoire pour déterminer les implications en termes de performances
3. **Profilage** : l'agent mesure les performances actuelles avec les outils appropriés
4. **Identification des goulots d'étranglement** : l'agent découvre où le temps est réellement passé
5. **Conception d'optimisation** : l'agent planifie plusieurs approches d'optimisation
6. **Mise en œuvre** : l'agent implémente l'optimisation avec des mesures
7. **Benchmarking** : l'agent vérifie l'améliorationatteint l'objectif
8. **Documentation** : l'agent crée des compromis en matière de documentation ADR
9. **Surveillance** : l'agent configure des alertes pour les régressions de performances

## Exemple

```bash
# Via babysit - optimize slow API endpoint
/agileflow:babysit
> "The user list API endpoint is taking 5 seconds. It needs to be <200ms."

# Agent output:
# Performance Analysis: GET /api/users
#
# Current Performance: 5.2 seconds
# Target Performance: <200ms
#
# Profiling Results:
# ├── Database query: 4.8s (92% of time)
# │   └── N+1 problem: Fetching user details in loop
# ├── JSON serialization: 0.3s (6%)
# └── Network overhead: 0.1s (2%)
#
# Optimization Strategy:
# 1. Fix N+1: Use JOIN instead of loop (estimated: 4.8s → 0.2s)
# 2. Add database index on users.created_at
# 3. Implement caching with 5 minute TTL
#
# Estimated Result: <200ms after optimizations
# Correctness: All tests will still pass
# Trade-offs: Slight memory overhead for cache
#
# Status: Ready for implementation
```

## Comportements clés

- **Mesurer d'abord** : code de profil pour trouver les goulots d'étranglement réels (ne devinez pas)
- **Benchmark Avant/Après** : mesurez toujours l'amélioration
- **Pas d'optimisation prématurée** : n'optimisez pas le code rarement utilisé
- **L'exactitude d'abord** : ne sacrifiez jamais l'exactitude pour la performance
- **Document compromis** : enregistrez les raisons pour lesquelles les décisions ont été prises
- **Vérifier sous charge** : testez les performances sous une charge réaliste

## Outils disponibles

- Lire, écrire, modifier (opérations sur les fichiers)
- Bash (exécuter des tests de profilage/chargement)
- Glob (trouver du code lent)
- Grep (recherche de problèmes de performances)

## Mesures de performances

**Mesures clés** :
- **Temps de réponse (latence)** : combien de temps prend l'opération ?
- **Débit** : combien d'opérations par seconde ?
- **Utilisation des ressources** : CPU, mémoire, disque, réseau
- **Évolutivité** : comment les performances évoluent-elles avec la charge ?

**PObjectifs de performance** (ajustables selon le contexte) :
- Points de terminaison API : moins de 200 ms en moyenne, moins de 500 ms p95
- Chargement de la page frontale : moins de 2 s pour la première peinture, moins de 5 s pour le chargement complet
- Requêtes base de données : moins de 10 ms en moyenne, moins de 100 ms p95
- Mémoire : Stable, pas de fuites, croissance prévisible

## Outils de profilage

**JavaScript/Node.js** :
- Chrome DevTools : profileur de performances intégré
- Profileur Node.js : `node --prof`
- clinic.js : outil de profilage professionnel
- canon automatique : tests de charge HTTP
- Graphiques de flamme : visualisez le temps passé dans chaque fonction

**Python** :
- cProfile : profilage du processeur
- memory_profiler : analyse de l'utilisation de la mémoire
- py-spy : profileur d'échantillonnage statistique

**Base de données** :
- EXPLIQUER ANALYSER : plan de requête et temps d'exécution
- Journal des requêtes lent : capturez les requêtes dépassant le seuil
- Surveillance : suivez le nombre de requêtes, la durée et l'utilisation des ressources

**Frontend** :
- Chrome DevTools : onglets Performances, Réseau
- Phare : Audit de performance
- Web Vitals : métriques de base (LCP, FID, CLS)

## Goulots d'étranglement et solutions courants

| Goulot d'étranglement | Cause| Solutions |
|------------|-------|--------------|
| Base de données | Requêtes N+1, index manquants, non optimisés | Utilisez JOIN, ajoutez des index, dénormalisez |
| Réponse API | Points de terminaison lents, appels externes | Cacher, optimiser les requêtes, paralléliser |
| Rendu frontal | Refusions, repeints, gros paquets | Fractionnement de code, chargement différé, compression |
| Mémoire | Fuites de mémoire, grandes structures de données | Corrigez les fuites, paginer de grands ensembles de données |
| Processeur | Algorithmes coûteux, travail inutile | Optimisation d'algorithmes, parallélisation |

## Techniques d'optimisation

**Optimisation de la base de données** :
```sql
-- Bad: N+1 queries (1 for users, N for details)
SELECT * FROM users;
for each user:
  SELECT * FROM user_details WHERE user_id = user.id;

-- Good: Single JOIN query
SELECT u.*, ud.* FROM users u
JOIN user_details ud ON u.id = ud.user_id;
```

**Stratégies de mise en cache** :
- **Cache en mémoire** : rapide mais de taille limitée (Redis)
- **Cache CDN** : ressources statiques aux emplacements périphériques
- **Cache HTTP** : cache du navigateur avec ETag, Last-Modified
- **Cache de base de données** : cache des résultats de requête

**Optimisation du front-end** :
```javascript
// Code splitting: Load only needed code
import { lazy, Suspense } from 'react';
const HeavyComponent = lazy(() => import('./HeavyComponent'));

// Lazy loading: Load images on demand
<img loading="lazy" src="image.jpg" alt="...">

// Tree shaking: Remove unused code
import { usedFunction } from 'library'; // Only usedFunction included
```

## Tests de charge

**Scénarios de test de charge** :
- **Ramp up** : augmentez progressivement la charge pour trouver le point de rupture
- **Sustained** : Charge constante dans le temps- **Spike** : Augmentation soudaine de la charge
- **Test de trempage** : charge soutenue pendant une période prolongée

**Mesures à capturer** :
- Répartition des temps de réponse (moyenne, p50, p95, p99)
- Débit (requêtes/seconde)
- Taux d'erreur (% de demandes ayant échoué)
- Utilisation des ressources (CPU, mémoire, réseau)

## Analyse d'évolutivité

Test du système sous charge croissante :

```text
Load Test Results:
├── 10 users: 150ms avg, 0% errors ✅
├── 100 users: 180ms avg, 0% errors ✅
├── 1000 users: 500ms avg, 2% errors ⚠️
├── 5000 users: 5s avg, 15% errors ❌
│
└── Bottleneck: Database can't handle 5000 concurrent connections
    Solution: Connection pooling, read replicas, caching
```

## Intégration du harnais de session

L'agent de performance s'intègre à Session Harness :

```text
Pre-Implementation:
├── Baseline performance measured
├── Bottleneck identified with data
└── Optimization plan reviewed

Post-Implementation:
├── Run /agileflow:verify (tests pass)
├── Benchmark improvement (meets target)
└── Verify correctness (tests still pass)
```

## Liste de contrôle qualité

Avant de terminer le travail de marquage :

-[ ] Performance actuelle mesurée et documentée
-[ ] Goulot d'étranglement identifié avec les données de profilage
-[ ] Cause profonde comprise
-[ ] Stratégie d'optimisation documentée
- [ ] Mesures avant/après prises
- [ ] L'amélioration atteint l'objectif de performance
- [ ] Exactitude vérifiée (les tests réussissent toujours)
- [ ] Compromis documentés
- [ ] Surveillance/alertes en place
- [ ] Mesures de performances ajoutées à la documentation

## Mode Plan (obligatoire pour l'optimisation)

L’optimisation des performances nécessite des mesures-première planification :

| Situation | Actions |
|-----------|--------|
| "Rendez-le plus rapide" (vague) | → EnterPlanMode : Profil d'abord ! |
| Fonctionnement lent connu | → EnterPlanMode : Optimisation de la conception |
| Mise en cache nécessaire | → EnterPlanMode : Invalidation du plan |
| Optimisation des requêtes | → EnterPlanMode : Mesurer avant/après |
| Problème de taille de paquet | → EnterPlanMode : Analyser les dépendances |

**Flux de travail en mode Planification** :
1. Profil des performances actuelles
2. Identifiez le véritable goulot d’étranglement
3. Optimisation de la conception avec des benchmarks
4. Stratégie de vérification du plan
5. Obtenez l'approbation
6. Mettre en œuvre, mesurer, vérifier

## Agents associés

- [`database`](/agents/database) - Optimisation des requêtes et index
- [`api`](/agents/api) - Optimisation du temps de réponse de l'API
- [`ui`](/agents/ui) - Performances du frontend et fractionnement du code
- [`devops`](/agents/devops) - Performances de l'infrastructure, mise à l'échelle
- [`testing`](/agents/testing) - Automatisation des tests de performances

##Coordination

La performance Agent se coordonne avec :

- **AG-DATABASE** : identifiez les requêtes lentes, examinez les index
- **AG-API** : performances du point de terminaison du profil
- **AG-UI** : Analyser les goulots d'étranglement du frontend
- **AG-DEVOPS** : suivi des demandes, mise à l'échelle des coordonnées
- **Équipe de surveillance** : configurer des alertes de performances

## Commandes barre oblique

- `/agileflow:research:ask TOPIC=...` - Techniques d'optimisation de la recherche
- `/agileflow:ai-code-review` - Vérifier le code pour les problèmes de performances
- `/agileflow:adr-new` - Documenter les décisions de performance
- `/agileflow:tech-debt` - Documenter la dette de performance
- `/agileflow:impact-analysis` - Analyser l'impact sur les performances
- `/agileflow:status STORY=... STATUS=...` - Mettre à jour le statut de l'histoire

## Principes de performance

- **Mesurez, ne devinez pas** : le profilage révèle de véritables goulots d'étranglement
- **L'optimisation prématurée est mauvaise** : optimisez là où cela compte
- **Objectif 80/20** : résolution de problèmes affectant 80 % de l'impact
- **Optimisez d'abord le pire** : résolvez d'abord le plus gros goulot d'étranglement
- **Vérifier avec charge** : Test dans des conditions de charge réalistes
- **Surveiller toujours** : configurez des alertes pour les régressions