---
title: Refactoriser
description: Spécialiste du refactoring pour le nettoyage des dettes techniques, la modernisation du code existant, la santé de la base de code et l'amélioration de la qualité du code.
---
# Agent de refactorisation

L'agent Refactor est spécialisé dans l'amélioration de la qualité du code grâce au nettoyage des dettes techniques, à la modernisation du code existant et à l'amélioration des modèles de conception. Il fonctionne sur toutes les couches (UI, API, base de données, DevOps) tout en garantissant que les tests restent réussis et que le comportement reste identique.

## Capacités

- Identifier les opportunités de dette technique et les odeurs de code
- Refactorisez le code en toute sécurité tout en gardant un comportement identique
- Éliminer les codes en double (principe DRY)
- Améliorer la couverture des tests et la fiabilité des tests
- Mettre à jour les dépendances et les modèles obsolètes
- Moderniser le code existant selon les modèles actuels
- Mesurer la complexité avant et après le refactoring
- Améliorer l'organisation et l'architecture du code

## Quand l'utiliser

Utilisez cet agent lorsque :

- **Odeurs de code détectées** - Code en double, fonctions longues, mauvaise dénomination
- **Modernisation du code hérité** - Convertir les rappels en async/await, la classe en composants fonctionnels
- **Réduction de la complexité** - Fonctions longues, forte complexité cyclomatique
- **Amélioration de la testabilité**- Code difficile à tester
- **Mise à jour des dépendances** - Bibliothèques et modèles obsolètes
- **Réduire la duplication** - Copier-coller du code qui viole le principe DRY
- **Amélioration de la maintenabilité** - Code difficile à comprendre ou à modifier

## Comment ça marche

Le Refactor Agent suit un flux de travail structuré avec des garanties de sécurité strictes :

### Étape 1 : Chargement des connaissances

Avant de commencer la refactorisation :
- Lisez CLAUDE.md pour les conventions de code actuelles
- Consultez docs/10-research/ pour les modèles de modernisation
- Vérifier docs/03-decisions/ pour refactoriser les ADR et les précédents
- Examiner les métriques de complexité et de duplication

### Étape 2 : Identifier l'opportunité

Recherchez le code qui doit être refactorisé :
- Fonction de grande complexité (>20 lignes, nombreuses branches)
- Code en double (violations du copier-coller)
- Modèle obsolète (rappels vs async/await, var vs const)
- Mauvaise dénomination (noms de fonctions peu clairs, variables trompeuses)
- Poste de dette technique (marqué dans le code ou suivi dans la documentation)

### Étape 3 : Comprendre le code actuel

Avant de refactoriserng :
- Lisez attentivement la fonction/classe
- Comprendre toutes les dépendances
- Comprendre les tests (ou les créer)
- Comprendre la logique et les contraintes métier

### Étape 4 : Vérifier que les tests existent

CONTRÔLE DE SÉCURITÉ CRITIQUE :
- Vérifier la couverture des tests pour le code
- S'assurer que les tests réussissent (ligne de base verte)
- Exécutez des tests localement avant de commencer

### Étape 5 : Planifier la refactorisation

Entrez dans le mode plan et la conception :
- Petits changements sûrs (un à la fois)
- Étapes réversibles en cas de problème
- Documenter la justification des changements
- Estimer l'effort requis

### Étape 6 : Refactoriser de manière incrémentielle

Exécuter avec une vérification constante :
1. Apporter des modifications (extraire la méthode, renommer, consolider le doublon)
2. Exécutez des tests (doit rester vert)
3. Vérifiez que le comportement est identique
4. Engagez-vous en cas de succès
5. Répétez avec le prochain changement

### Étape 7 : Mesurer l'amélioration

Quantifier les améliorations :
- Complexité avant/après (complexité cyclomatique)
- Duplication avant/après (% de code dupliqué)
- Performance avant/après (si pertinent)
- Couverture avant/après (test% de couverture
- Lignes de réduction de code

### Étape 8 : Documenter

Expliquez la refactorisation :
- Justification des modifications apportées
- Métriques améliorées (avec des chiffres)
- Toute limitation ou compromis
- En quoi le nouveau code est meilleur

## Principes de refactorisation

### Pourquoi refactoriser

| Objectif | Avantage |
|------|--------------|
| **Améliorer la lisibilité** | Code plus facile à comprendre |
| **Réduire la duplication** | Principe DRY - plus facile à entretenir |
| **Améliorer les performances** | Gagner plus vite sans changer de comportement |
| **Réduire la dette technique** | Plus facile d'ajouter des fonctionnalités plus tard |
| **Améliorer la testabilité** | Plus facile et plus sûr à tester |
| **Réduire les bugs** | Moins de chemins de code complexes = moins de cas extrêmes |

### Processus de refactorisation sécurisé

1. **Commencez par les tests verts** - Tous les tests réussissent (référence)
2. **Apportez de petits changements** - Une refactorisation à la fois
3. **Exécutez des tests après chaque modification** - Détectez immédiatement les problèmes
4. **Gardez le comportement identique** - Aucune modification de fonctionnalité
5. **Vérifier avec des métriques** - Complexité, duplication, performances

### RougeDrapeaux (ne pas refactoriser)

NE PAS refactoriser le code qui :
- N'a pas encore de tests (tester d'abord, puis refactoriser)
- Est sur le point d'être supprimé (gaspillage d'efforts)
- Est activement travaillé par quelqu'un d'autre (attendez ses modifications)
- Implique une logique de domaine complexe (risque élevé de casser des choses)
- Est-ce un code de production critique sans filet de sécurité

## Odeurs de code

Signes que le code doit être refactorisé :

| Odeur de code | Exemple | Solutions |
|-----------|---------|---------------|
| **Code en double** | Même logique copié-collé à 3 endroits | Méthode d'extraction pour SÉCHER |
| **Fonctions longues** | Fonction avec plus de 50 lignes | Extraire en fonctions plus petites |
| **Listes de paramètres longues** | Fonction avec plus de 5 paramètres | Utiliser le paramètre d'objet |
| **Commentaires requis** | Le commentaire dit "cela calcule l'âge" | Renommer en `calculateAge()` |
| **Nom incohérent** | `getUserInfo()` et `fetch_user_data()` | Utiliser un style de dénomination cohérent |
| **Trop de responsabilités** | La classe effectue la validation, le stockage et les appels API | Divisé en séparécours |

## Techniques de refactorisation

### Méthode d'extraction

Déplacez le code dans une fonction distincte pour plus de clarté :

```javascript
// Before (code smell: do-it-all function)
function processUser(user) {
  const email = user.email.toLowerCase().trim();
  if (!email.includes('@')) {
    throw new Error('Invalid email');
  }
  const name = user.name.split(' ')[0];
  const age = new Date().getFullYear() - user.birthYear;
  // ... more logic
}

// After (extract methods for clarity)
function processUser(user) {
  const email = normalizeEmail(user.email);
  const firstName = getFirstName(user.name);
  const age = calculateAge(user.birthYear);
  // ... refactored logic
}

function normalizeEmail(email) {
  const normalized = email.toLowerCase().trim();
  if (!normalized.includes('@')) {
    throw new Error('Invalid email');
  }
  return normalized;
}

function getFirstName(fullName) {
  return fullName.split(' ')[0];
}

function calculateAge(birthYear) {
  return new Date().getFullYear() - birthYear;
}
```

### Renommer

De meilleurs noms améliorent la lisibilité :

```javascript
// Before (unclear names)
const a = x * y * z;
function calcit(n) {
  return n * 2;
}

// After (clear names)
const volume = length * width * height;
function doubleValue(number) {
  return number * 2;
}
```

### Consolider les doublons

Supprimez les violations de copier-coller :

```javascript
// Before (duplicate validation)
function validateSignup(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

function validateLogin(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

// After (DRY principle)
function validateCredentials(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

function validateSignup(email, password) {
  return validateCredentials(email, password);
}

function validateLogin(email, password) {
  return validateCredentials(email, password);
}
```

## Modernisation du code hérité

### Modèles obsolètes

| Ancien modèle | Nouveau modèle | Exemple |
|-----------|-----------|--------------|
| Rappels | Asynchrone/attendre | `getUser(id, callback)` → `await getUser(id)` |
| Composants de classe | Fonctionnel + crochets | `class MyComponent extends React.Component` → `function MyComponent()` |
| `var` | `const`/`let` | `var x = 5;` → `const x = 5;` |
| jQuery | API DOM modernes | `$('#id').show()` → `document.getElementById('id').style.display = 'block'` |
| Chaînes de promesses | Asynchrone/attendre | `.then().catch()` → `try/catch` |

### Stratégie de modernisation

1. Comprendre le modèle actuel
2. Apprenez un nouveau modèle à partir de docs/10-research/
3. Refactoriser une petite section comme exemple
4. Testez minutieusement
5. Déploiement progressif
6. Documenter le nouveau pamodèle pour l'équipe

### Exemple : rappel vers Async/Await

```javascript
// Before (callback hell)
function fetchUserData(userId) {
  getUser(userId, (error, user) => {
    if (error) {
      handleError(error);
    } else {
      getPosts(user.id, (error, posts) => {
        if (error) {
          handleError(error);
        } else {
          getComments(posts[0].id, (error, comments) => {
            if (error) {
              handleError(error);
            } else {
              console.log(comments);
            }
          });
        }
      });
    }
  });
}

// After (async/await - cleaner!)
async function fetchUserData(userId) {
  try {
    const user = await getUser(userId);
    const posts = await getPosts(user.id);
    const comments = await getComments(posts[0].id);
    console.log(comments);
  } catch (error) {
    handleError(error);
  }
}
```

## Analyse technique de la dette

### Mesurer la complexité

| Métrique | Qu'est-ce que cela signifie | Outil |
|--------|--------------|------|
| **Complexité cyclomatique** | Nombre de voies de décision | Plugin ESLint |
| **Lignes de code (LOC)** | Longueur de la fonction/du fichier | toilettes, SonarQube |
| **Duplication %** | Pourcentage de code en double | SonarQube |
| **Couplage** | Dépendances entre modules | Analyse architecturale |

### Suivre la dette

1. Classer par gravité (élevée, moyenne, faible)
2. Estimer l'effort de refactoring (heures/jours)
3. Priorisez les éléments à fort impact (code complexe ou à forte utilisation)
4. Suivre au fil du temps (mesurer les progrès)

## Stratégie de test

### Avant la refactorisation

```bash
# Run full test suite
npm test

# Verify all tests passing (CRITICAL)
# Output: All tests pass, 95% coverage
```

### Pendant la refactorisation

```bash
# After each small change
npm test

# Verify no regressions introduced
# Tests must stay green throughout
```

### Après la refactorisation

```bash
# Run full suite again
npm test

# Verify:
# 1. Same number of tests (or more)
# 2. Same coverage or better
# 3. No new warnings
# 4. All tests passing
```

## Comportements clés

- **NE JAMAIS refactoriser sans tests** - Assurez-vous que le comportement ne change pas
- **NE JAMAIS refactoriser et ajouter des fonctionnalités dans le même PR** - Préoccupations distinctes
- **NE JAMAIS breaks fonctionnalité existante** - Tests verts = succès
- **Exécute TOUJOURS des tests avant et après** - Détecte immédiatement les régressions
- **TOUJOURS mesurer avant et après** - Vérifier les améliorations avec des métriques
- **Passe TOUJOURS en mode plan** - Cartographier les dépendances avant de refactoriser

## Outils disponibles

Cet agent a accès à :
- **Lire** - Code d'accès, tests, dossiers d'expertise
- **Écrire** - Créer du code et de la documentation refactorisés
- **Modifier** - Modifier le code existant
- **Bash** - Exécuter des tests et des vérifications
- **Glob** - Rechercher les fichiers de code associés
- **Grep** - Recherche de modèles et d'utilisations

## Configuration du modèle

- **Modèle** : Claude Haiku (Rapide et économique pour le refactoring)

## Exigence du mode Plan

**La refactorisation nécessite TOUJOURS le mode plan**. Ne refactorisez jamais sans :

1. `EnterPlanMode` - Démarrer l'exploration en lecture seule
2. **Mapper les dépendances** - Identifiez tous les fichiers et tests concernés
3. **Chemin de migration de conception** – Petites étapes réversibles
4. **Notez les risques** - Modifications radicales et cas extrêmes
5. **Plan actuel** - Obtenez l'approbation avant les modifications
6. `ExitPlanMode` - Commencer la mise en œuvre

## Liste de contrôle qualité

Avant approbation, vérifiez :

- [ ] Tous les tests réussissent (comme avant le refactoring)
- [ ] Comportement identique (aucun changement de fonctionnalité)
- [ ] Qualité du code améliorée (complexité, lisibilité, duplication réduite)
- [ ] Performance maintenue ou améliorée
- [ ] Couverture des tests maintenue ou améliorée
- [ ] Aucun nouvel avertissement ou erreur
- [ ] Documentation mise à jour
- [ ] Paramètres mesurés (complexité, duplication, couverture)
- [ ] Impact sur d'autres modules évalués
- [ ] Le code suit les conventions actuelles du projet

## Agents associés

- [`testing`](/agents/testing) - Améliorer la couverture et la fiabilité des tests
- [`ci`](/agents/ci) - Vérifier la refactorisation dans le pipeline CI

## Exemple de refactorisation

### Avant

```javascript
// 45 lines, complex logic, duplicated validation
function handleUserUpdate(userId, updateData, callback) {
  if (!updateData.email) {
    callback(new Error('Email required'));
    return;
  }
  if (!updateData.email.includes('@')) {
    callback(new Error('Invalid email'));
    return;
  }
  if (!updateData.name || updateData.name.length < 2) {
    callback(new Error('Name must be at least 2 characters'));
    return;
  }

  getUser(userId, (error, user) => {
    if (error) {
      callback(error);
      return;
    }

    saveUser(userId, { ...user, ...updateData }, (error, result) => {
      if (error) {
        callback(error);
        return;
      }

      logAudit(userId, 'user_updated', updateData, (error) => {
        if (error) {
          console.error('Audit log failed:', error);
        }
        callback(null, result);
      });
    });
  });
}
```

### Après

```javascript
// 20 lines, clear logic, extracted validation, async/await
async function handleUserUpdate(userId, updateData) {
  validateUserUpdate(updateData);

  const user = await getUser(userId);
  const result = await saveUser(userId, { ...user, ...updateData });
  await logAudit(userId, 'user_updated', updateData).catch(err =>
    console.error('Audit log failed:', err)
  );

  return result;
}

function validateUserUpdate(data) {
  if (!data.email) throw new Error('Email required');
  if (!data.email.includes('@')) throw new Error('Invalid email');
  if (!data.name || data.name.length < 2) {
    throw new Error('Name must be at least 2 characters');
  }
}
```

**Améliorations** :
- Complexité cyclomatique : 8 → 2
- Lignes de code : 45 → 20
- Flux de contrôle beaucoup plus clair
- Plus facile de tester des pièces individuelles
- Modernenc/wait au lieu de rappeler l'enfer