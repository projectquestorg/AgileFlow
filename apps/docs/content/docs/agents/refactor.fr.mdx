---
title: Refactor
description: Spécialiste refactor pour le nettoyage de dette technique, la modernisation du code legacy, la santé de la base de code et les améliorations de qualité du code.
---

# Agent refactor

L'agent refactor se spécialise dans l'amélioration de la qualité du code via le nettoyage de dette technique, la modernisation du code legacy, et les améliorations de modèle de design. Il travaille à travers toutes les couches (UI, API, BD, DevOps) tout en gardant les tests passants et le comportement identique.

## Capacités

- Identifier les opportunités de dette technique et code smells
- Refactoriser en toute sécurité le code en gardant le comportement identique
- Éliminer le code dupliqué (principe DRY)
- Améliorer la couverture de test et la fiabilité de test
- Mettre à jour les dépendances et modèles obsolètes
- Moderniser le code legacy vers les modèles actuels
- Mesurer la complexité avant et après refactoring
- Améliorer l'organisation du code et l'architecture

## Quand l'utiliser

Utiliser cet agent quand:

- **Détection de code smells**: Code dupliqué, fonctions longues, poor naming
- **Modernisation du code legacy**: Convertir callbacks en async/await, classes en composants fonctionnels
- **Réduction de complexité**: Fonctions longues, complexité cyclomatique élevée
- **Amélioration de testabilité**: Code qui est difficile à tester
- **Mise à jour de dépendances**: Bibliothèques obsolètes et modèles
- **Réduction de duplication**: Code copy-paste qui viole le principe DRY
- **Amélioration de maintenabilité**: Code qui est difficile à comprendre ou changer

## Comment ça marche

L'agent refactor suit un workflow structuré avec des garanties de sécurité strictes:

### Étape 1: Chargement du contexte

Avant de commencer le refactoring:
- Lire CLAUDE.md pour les conventions de code actuelles
- Vérifier docs/10-research/ pour les modèles de modernisation
- Vérifier docs/03-decisions/ pour les ADRs de refactor et précédents
- Revoir la complexité et métriques de duplication

### Étape 2: Identifier l'opportunité

Trouver le code qui a besoin de refactoring:
- Fonction haute-complexité (>20 lignes, beaucoup de branches)
- Code dupliqué (violations copy-paste)
- Modèle obsolète (callbacks vs async/await, var vs const)
- Poor naming (noms de fonction peu clairs, variables trompeuses)
- Item de dette technique (marqué dans le code ou suivi dans la docs)

### Étape 3: Comprendre le code actuel

Avant le refactoring:
- Lire la fonction/classe complètement
- Comprendre toutes les dépendances
- Comprendre les tests (ou les créer)
- Comprendre la logique métier et contraintes

### Étape 4: Vérifier que les tests existent

VÉRIFICATION DE SÉCURITÉ CRITIQUE:
- Vérifier la couverture de test pour le code
- Assurer que les tests passent (baseline vert)
- Exécuter les tests localement avant de commencer

### Étape 5: Planifier le refactoring

Entrer le mode plan et concevoir:
- Changements petits et sûrs (un à la fois)
- Étapes réversibles en cas de problèmes
- Documenter le rationale pour les changements
- Estimer l'effort requis

### Étape 6: Refactoriser de manière incrémentale

Exécuter avec vérification constante:
1. Faire le changement (extraire méthode, renommer, consolider dupliqué)
2. Exécuter les tests (doivent rester verts)
3. Vérifier le comportement est identique
4. Commiter si réussi
5. Répéter avec le changement suivant

### Étape 7: Mesurer l'amélioration

Quantifier les améliorations:
- Complexité avant/après (complexité cyclomatique)
- Duplication avant/après (% code dupliqué)
- Performance avant/après (si relevant)
- Couverture avant/après (couverture de test %)
- Réduction lignes de code

### Étape 8: Documenter

Expliquer le refactoring:
- Rationale pour les changements faits
- Métriques améliorées (avec nombres)
- N'importe quelles limitations ou compromis
- Comment le nouveau code est meilleur

## Principes du refactoring

### Pourquoi refactoriser

| Objectif | Bénéfice |
|----------|----------|
| **Améliorer la lisibilité** | Code plus facile à comprendre |
| **Réduire la duplication** | Principe DRY - plus facile à maintenir |
| **Améliorer la performance** | Rendre plus rapide sans changer le comportement |
| **Réduire la dette technique** | Plus facile d'ajouter des fonctionnalités plus tard |
| **Améliorer la testabilité** | Plus facile et sûr de tester |
| **Réduire les bugs** | Chemins de code moins complexes = moins de cas limites |

### Processus de refactoring sûr

1. **Commencer avec les tests verts**: Tous les tests passent (baseline)
2. **Faire les petits changements**: Un refactoring à la fois
3. **Exécuter les tests après chaque changement**: Attraper les problèmes immédiatement
4. **Garder le comportement identique**: Pas de changements de fonctionnalité
5. **Vérifier avec les métriques**: Complexité, duplication, performance

### Red flags (Ne pas refactoriser)

NE PAS refactoriser le code qui:
- N'a pas encore de tests (tester d'abord, puis refactoriser)
- Est sur le point d'être supprimé (gaspillage d'effort)
- Est activement travaillé par quelqu'un d'autre (attendre leurs changements)
- Implique la logique complexe de domaine (haut risque de casser)
- Est du code critique de production avec pas de filet de sécurité

## Code smells

Les signes que le code a besoin de refactoring:

| Code smell | Exemple | Solution |
|-----------|---------|----------|
| **Code dupliqué** | La même logique copy-pasted dans 3 places | Extraire la méthode pour DRY |
| **Fonctions longues** | Fonction avec 50+ lignes | Extraire dans des fonctions plus petites |
| **Listes de paramètres longues** | Fonction avec 5+ paramètres | Utiliser le paramètre objet |
| **Commentaires requis** | Le commentaire dit "this calculates the age" | Renommer en `calculateAge()` |
| **Naming incohérent** | `getUserInfo()` et `fetch_user_data()` | Utiliser le style de naming cohérent |
| **Trop de responsabilités** | Classe fait validation, stockage, et appels API | Diviser en classes séparées |

## Techniques de refactoring

### Extraire la méthode

Déplacer le code dans une fonction séparée pour la clarté:

```javascript
// Avant (code smell: fonction qui fait tout)
function processUser(user) {
  const email = user.email.toLowerCase().trim();
  if (!email.includes('@')) {
    throw new Error('Invalid email');
  }
  const name = user.name.split(' ')[0];
  const age = new Date().getFullYear() - user.birthYear;
  // ... plus de logique
}

// Après (extraire les méthodes pour la clarté)
function processUser(user) {
  const email = normalizeEmail(user.email);
  const firstName = getFirstName(user.name);
  const age = calculateAge(user.birthYear);
  // ... logique refactorisée
}
```

### Renommer

Les meilleurs noms améliorent la lisibilité:

```javascript
// Avant (noms peu clairs)
const a = x * y * z;
function calcit(n) {
  return n * 2;
}

// Après (noms clairs)
const volume = length * width * height;
function doubleValue(number) {
  return number * 2;
}
```

### Consolider les dupliqués

Supprimer les violations copy-paste:

```javascript
// Avant (validation dupliquée)
function validateSignup(email, password) {
  if (!email.includes('@')) return false;
  if (password.length \< 8) return false;
  return true;
}

function validateLogin(email, password) {
  if (!email.includes('@')) return false;
  if (password.length \< 8) return false;
  return true;
}

// Après (principe DRY)
function validateCredentials(email, password) {
  if (!email.includes('@')) return false;
  if (password.length \< 8) return false;
  return true;
}
```

## Modernisation du code legacy

### Modèles obsolètes

| Ancien modèle | Nouveau modèle | Exemple |
|-----------|-----------|---------|
| Callbacks | Async/await | `getUser(id, callback)` → `await getUser(id)` |
| Composants class | Fonctionnels + hooks | `class MyComponent extends React.Component` → `function MyComponent()` |
| `var` | `const`/`let` | `var x = 5;` → `const x = 5;` |
| jQuery | APIs DOM modernes | `$('#id').show()` → `document.getElementById('id').style.display = 'block'` |
| Chaîne de promises | Async/await | `.then().catch()` → `try/catch` |

### Stratégie de modernisation

1. Comprendre le modèle actuel
2. Apprendre le nouveau modèle de docs/10-research/
3. Refactoriser une petite section comme exemple
4. Tester complètement
5. Rollout graduellement
6. Documenter le nouveau modèle pour l'équipe

## Analyse de dette technique

### Mesurer la complexité

| Métrique | Ce que ça signifie | Outil |
|--------|--------------|------|
| **Complexité cyclomatique** | Nombre de chemins de décision | ESLint plugin |
| **Lignes de code (LOC)** | Longueur de fonction/fichier | wc, SonarQube |
| **Duplication %** | Pourcentage de code dupliqué | SonarQube |
| **Coupling** | Dépendances entre modules | Analyse d'architecture |

### Suivre la dette

1. Catégoriser par sévérité (haute, moyen, bas)
2. Estimer l'effort de refactoring (heures/jours)
3. Prioriser les items haute-impact (complexité ou code haute-utilisation)
4. Suivre dans le temps (mesurer la progression)

## Stratégie de test

### Avant le refactoring

```bash
# Exécuter la suite complète de test
npm test

# Vérifier que tous les tests passent (CRITIQUE)
# Output: All tests pass, 95% coverage
```

### Pendant le refactoring

```bash
# Après chaque petit changement
npm test

# Vérifier pas de regressions introduites
# Les tests doivent rester verts partout
```

### Après le refactoring

```bash
# Exécuter la suite complète à nouveau
npm test

# Vérifier:
# 1. Même nombre de tests (ou plus)
# 2. Même couverture ou meilleure
# 3. Pas d'avertissements nouveaux
# 4. Tous les tests passants
```

## Comportements clés

- **JAMAIS refactoriser sans tests**: Assurer le comportement ne change pas
- **JAMAIS refactoriser et ajouter des fonctionnalités dans la même PR**: Séparer les préoccupations
- **JAMAIS casser la fonctionnalité existante**: Tests verts = succès
- **TOUJOURS exécuter les tests avant et après**: Attraper les regressions immédiatement
- **TOUJOURS mesurer avant et après**: Vérifier les améliorations avec les métriques
- **TOUJOURS entrer le mode plan**: Mapper les dépendances avant le refactoring

## Outils disponibles

Cet agent a accès à:
- **Read**: Accéder au code, tests, fichiers d'expertise
- **Write**: Créer le code refactorisé et la documentation
- **Edit**: Modifier le code existant
- **Bash**: Exécuter les tests et vérification
- **Glob**: Trouver les fichiers de code associés
- **Grep**: Rechercher les modèles et utilisations

## Configuration du modèle

- **Modèle**: Claude Haiku (rapide, cost-effective pour le refactoring)

## Exigence de mode plan

**Le refactoring TOUJOURS necessite le mode plan**. Jamais refactoriser sans:

1. `EnterPlanMode`: Démarrer l'exploration read-only
2. **Mapper les dépendances**: Identifier tous les fichiers et tests affectés
3. **Concevoir le chemin de migration**: Petites étapes réversibles
4. **Noter les risques**: Changements potentiellement cassants et cas limites
5. **Présenter le plan**: Obtenir l'approbation avant les changements
6. `ExitPlanMode`: Démarrer l'implémentation

## Checklist de qualité

Avant l'approbation, vérifier:

- [ ] Tous les tests passants (même que le refactoring)
- [ ] Comportement identique (pas de changements de fonctionnalité)
- [ ] Qualité du code améliorée (complexité, lisibilité, duplication réduite)
- [ ] Performance maintenue ou améliorée
- [ ] Couverture de test maintenue ou améliorée
- [ ] Pas d'avertissements ou erreurs nouveaux
- [ ] Documentation mise à jour
- [ ] Métriques mesurées (complexité, duplication, couverture)
- [ ] Impact sur les autres modules évalué
- [ ] Le code suit les conventions actuelles du projet

## Agents associés

- [`testing`](/agents/testing) - Améliorer la couverture de test et la fiabilité
- [`ci`](/agents/ci) - Vérifier le refactoring dans le pipeline CI

## Exemple de refactoring

### Avant

```javascript
// 45 lignes, logique complexe, validation dupliquée
function handleUserUpdate(userId, updateData, callback) {
  if (!updateData.email) {
    callback(new Error('Email required'));
    return;
  }
  if (!updateData.email.includes('@')) {
    callback(new Error('Invalid email'));
    return;
  }
  if (!updateData.name || updateData.name.length \< 2) {
    callback(new Error('Name must be at least 2 characters'));
    return;
  }

  getUser(userId, (error, user) => {
    if (error) {
      callback(error);
      return;
    }

    saveUser(userId, { ...user, ...updateData }, (error, result) => {
      if (error) {
        callback(error);
        return;
      }

      logAudit(userId, 'user_updated', updateData, (error) => {
        if (error) {
          console.error('Audit log failed:', error);
        }
        callback(null, result);
      });
    });
  });
}
```

### Après

```javascript
// 20 lignes, logique claire, validation extraite, async/await
async function handleUserUpdate(userId, updateData) {
  validateUserUpdate(updateData);

  const user = await getUser(userId);
  const result = await saveUser(userId, { ...user, ...updateData });
  await logAudit(userId, 'user_updated', updateData).catch(err =>
    console.error('Audit log failed:', err)
  );

  return result;
}

function validateUserUpdate(data) {
  if (!data.email) throw new Error('Email required');
  if (!data.email.includes('@')) throw new Error('Invalid email');
  if (!data.name || data.name.length \< 2) {
    throw new Error('Name must be at least 2 characters');
  }
}
```

**Améliorations**:
- Complexité cyclomatique: 8 → 2
- Lignes de code: 45 → 20
- Flux de contrôle beaucoup plus clair
- Plus facile de tester des pièces individuelles
- Async/await moderne au lieu de callback hell
