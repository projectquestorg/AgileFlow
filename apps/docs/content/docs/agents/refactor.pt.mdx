---
title: Refatorar
description: Especialista em refatoração para limpeza técnica de dívidas, modernização de código legado, integridade da base de código e melhorias na qualidade do código.
---
# Agente de refatoração

O Refactor Agent é especializado em melhorar a qualidade do código por meio de limpeza técnica de dívidas, modernização de código legado e melhorias nos padrões de design. Ele funciona em todas as camadas (IU, API, banco de dados, DevOps), garantindo que os testes continuem sendo aprovados e que o comportamento permaneça idêntico.

## Capacidades

- Identificar oportunidades de dívida técnica e cheiros de código
- Refatore o código com segurança, mantendo o comportamento idêntico
- Elimine código duplicado (princípio DRY)
- Melhorar a cobertura e a confiabilidade dos testes
- Atualizar dependências e padrões desatualizados
- Modernize o código legado para os padrões atuais
- Medir a complexidade antes e depois da refatoração
- Melhorar a organização e arquitetura do código

## Quando usar

Use este agente quando:

- **Odores de código detectados** - Código duplicado, funções longas, nomenclatura inadequada
- **Modernização de código legado** - Converter retornos de chamada em assíncronos/aguardar, classe em componentes funcionais
- **Reduzindo a complexidade** - Funções longas, alta complexidade ciclomática
- **Melhorando a testabilidade**- Código difícil de testar
- **Atualizando dependências** - Bibliotecas e padrões desatualizados
- **Reduzindo a duplicação** - Copiar e colar código que viola o princípio DRY
- **Melhorando a capacidade de manutenção** - Código difícil de entender ou alterar

## Como funciona

O Refactor Agent segue um fluxo de trabalho estruturado com garantias de segurança rigorosas:

### Etapa 1: Carregamento de conhecimento

Antes de começar a refatorar:
- Leia CLAUDE.md para convenções de código atuais
- Verifique docs/10-research/ para padrões de modernização
- Verifique docs/03-decisions/ para refatorar ADRs e precedentes
- Revise as métricas de complexidade e duplicação

### Etapa 2: Identificar oportunidade

Encontre o código que precisa de refatoração:
- Função de alta complexidade (>20 linhas, muitas ramificações)
- Código duplicado (violações de copiar e colar)
- Padrão desatualizado (callbacks vs async/await, var vs const)
- Nomenclatura inadequada (nomes de funções pouco claros, variáveis enganosas)
- Item de dívida técnica (marcado em código ou rastreado em documentos)

### Etapa 3: Entenda o código atual

Antes de refatorarnão:
- Leia a função/classe cuidadosamente
- Entenda todas as dependências
- Compreender os testes (ou criá-los)
- Compreender a lógica e as restrições de negócios

### Etapa 4: verificar a existência de testes

VERIFICAÇÃO CRÍTICA DE SEGURANÇA:
- Verifique a cobertura do teste para o código
- Certifique-se de que os testes sejam aprovados (linha de base verde)
- Execute testes localmente antes de começar

### Etapa 5: Planejar a refatoração

Entre no modo de plano e design:
- Mudanças pequenas e seguras (uma de cada vez)
- Etapas reversíveis em caso de problemas
- Documentar a justificativa para as mudanças
- Estimar o esforço necessário

### Etapa 6: refatorar incrementalmente

Execute com verificação constante:
1. Faça alterações (extrair método, renomear, consolidar duplicado)
2. Execute testes (deve permanecer verde)
3. Verifique se o comportamento é idêntico
4. Confirme se for bem-sucedido
5. Repita com a próxima alteração

### Etapa 7: Medir a melhoria

Quantifique as melhorias:
- Complexidade antes/depois (complexidade ciclomática)
- Duplicação antes/depois (% de código duplicado)
- Desempenho antes/depois (se relevante)
- Cobertura antes/depois (testecobertura %)
- Linhas de redução de código

### Etapa 8: Documento

Explique a refatoração:
- Justificativa para as alterações feitas
- Métricas melhoradas (com números)
- Quaisquer limitações ou compensações
- Como o novo código é melhor

## Princípios de Refatoração

### Por que refatorar

| Meta | Benefício |
|------|---------|
| **Melhorar a legibilidade** | Código mais fácil de entender |
| **Reduza a duplicação** | Princípio DRY – mais fácil de manter |
| **Melhorar o desempenho** | Torne mais rápido sem alterar comportamento |
| **Reduzir a dívida técnica** | Mais fácil de adicionar recursos posteriormente |
| **Melhorar a testabilidade** | Mais fácil e seguro de testar |
| **Reduza bugs** | Menos caminhos de código complexos = menos casos extremos |

### Processo de refatoração segura

1. **Começar com testes verdes** - Todos os testes foram aprovados (linha de base)
2. **Faça pequenas alterações** – Uma refatoração de cada vez
3. **Execute testes após cada alteração** - Detecte problemas imediatamente
4. **Mantenha o comportamento idêntico** - Sem alterações de recursos
5. **Verifique com métricas** – Complexidade, duplicação, desempenho

### VermelhoSinalizadores (não refatorar)

NÃO refatore código que:
- Ainda não possui testes (teste primeiro e depois refatore)
- Está prestes a ser excluído (desperdício de esforço)
- Está sendo trabalhado ativamente por outra pessoa (aguarde pelas alterações)
- Envolve lógica de domínio complexa (alto risco de quebrar coisas)
- É um código de produção crítico sem rede de segurança

## Código cheira

Sinais de que o código precisa de refatoração:

| Cheiro de código | Exemplo | Solução |
|-----------|---------|----------|
| **Código duplicado** | Mesma lógica copiada e colada em 3 lugares | Método de extração para DRY up |
| **Funções longas** | Função com mais de 50 linhas | Extrair em funções menores |
| **Longas listas de parâmetros** | Função com mais de 5 parâmetros | Usar parâmetro de objeto |
| **Comentários necessários** | Comentário diz "isto calcula a idade" | Renomeie para __NOTRASLATE_9__ |
| **Nomenclatura inconsistente** | `getUserInfo()` e `fetch_user_data()` | Use um estilo de nomenclatura consistente |
| **Muitas responsabilidades** | Classe faz validação, armazenamento e chamadas de API | Dividir em separadoaulas |

## Técnicas de Refatoração

### Método de extração

Mova o código para uma função separada para maior clareza:

```javascript
// Before (code smell: do-it-all function)
function processUser(user) {
  const email = user.email.toLowerCase().trim();
  if (!email.includes('@')) {
    throw new Error('Invalid email');
  }
  const name = user.name.split(' ')[0];
  const age = new Date().getFullYear() - user.birthYear;
  // ... more logic
}

// After (extract methods for clarity)
function processUser(user) {
  const email = normalizeEmail(user.email);
  const firstName = getFirstName(user.name);
  const age = calculateAge(user.birthYear);
  // ... refactored logic
}

function normalizeEmail(email) {
  const normalized = email.toLowerCase().trim();
  if (!normalized.includes('@')) {
    throw new Error('Invalid email');
  }
  return normalized;
}

function getFirstName(fullName) {
  return fullName.split(' ')[0];
}

function calculateAge(birthYear) {
  return new Date().getFullYear() - birthYear;
}
```

### Renomear

Nomes melhores melhoram a legibilidade:

```javascript
// Before (unclear names)
const a = x * y * z;
function calcit(n) {
  return n * 2;
}

// After (clear names)
const volume = length * width * height;
function doubleValue(number) {
  return number * 2;
}
```

### Consolidar duplicatas

Remova violações de copiar e colar:

```javascript
// Before (duplicate validation)
function validateSignup(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

function validateLogin(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

// After (DRY principle)
function validateCredentials(email, password) {
  if (!email.includes('@')) return false;
  if (password.length < 8) return false;
  return true;
}

function validateSignup(email, password) {
  return validateCredentials(email, password);
}

function validateLogin(email, password) {
  return validateCredentials(email, password);
}
```

## Modernização de código legado

### Padrões desatualizados

| Padrão antigo | Novo padrão | Exemplo |
|-----------|-----------|--------|
| Retornos de chamada | Assíncrono/aguarda | `getUser(id, callback)` → `await getUser(id)` |
| Componentes de classe | Funcional + ganchos | `class MyComponent extends React.Component` → `function MyComponent()` |
| `var` | `const`/`let` | `var x = 5;` → `const x = 5;` |
| jQuery | APIs DOM modernas | `$('#id').show()` → `document.getElementById('id').style.display = 'block'` |
| Correntes de promessa | Assíncrono/aguarda | `.then().catch()` → `try/catch` |

### Estratégia de Modernização

1. Entenda o padrão atual
2. Aprenda o novo padrão em docs/10-research/
3. Refatore uma pequena seção como exemplo
4. Teste minuciosamente
5. Implementação gradual
6. Documente o novo papadrão para equipe

### Exemplo: retorno de chamada para Async/Await

__NOTRADUZIR_3__

## Análise Técnica da Dívida

### Medir a complexidade

| Métrica | O que significa | Ferramenta |
|--------|--------------|------|
| **Complexidade ciclomática** | Número de caminhos de decisão | Plug-in ESLint |
| **Linhas de código (LOC)** | Comprimento da função/arquivo | wc, SonarQube |
| **Duplicação %** | Percentagem de código duplicado | SonarQube |
| **Acoplamento** | Dependências entre módulos | Análise de arquitetura |

### Rastrear dívidas

1. Categorize por gravidade (alta, média, baixa)
2. Estime o esforço de refatoração (horas/dias)
3. Priorize itens de alto impacto (complexidade ou código de alto uso)
4. Acompanhe ao longo do tempo (medir o progresso)

## Estratégia de teste

### Antes de refatorar

__NÃOTRADUZIR_4__

### Durante a refatoração

__NOTRADUZIR_5__

### Após refatoração

__NOTRADUZIR_6__

## Principais comportamentos

- **NUNCA refatore sem testes** - Garanta que o comportamento não mude
- **NUNCA refatora e adiciona recursos no mesmo PR** - Preocupações separadas
- **NUNCA quebreaks funcionalidade existente** - Testes verdes = sucesso
- **SEMPRE executa testes antes e depois** - Captura regressões imediatamente
- **SEMPRE mede antes e depois** - Verifique melhorias com métricas
- **SEMPRE entra no modo de planejamento** - Mapeie dependências antes de refatorar

## Ferramentas disponíveis

Este agente tem acesso a:
- **Ler** - Acesse código, testes, arquivos de expertise
- **Escrever** - Criar código refatorado e documentação
- **Editar** - Modificar código existente
- **Bash** - Execute testes e verificação
- **Glob** - Encontre arquivos de código relacionados
- **Grep** - Pesquisa de padrões e usos

## Configuração do modelo

- **Modelo**: Claude Haiku (rápido e econômico para refatoração)

## Requisito do Modo de Plano

**A refatoração SEMPRE requer modo de planejamento**. Nunca refatore sem:

1. __NOTRASLATE_25__ - Iniciar exploração somente leitura
2. **Mapear dependências** – Identifique todos os arquivos e testes afetados
3. **Caminho de migração do projeto** – Etapas pequenas e reversíveis
4. **Observe os riscos** - Mudanças significativas e casos extremos
5. **Plano atual** - Obtenha aprovação antes das alterações
6. __NOTRASLATE_26__ - Iniciar implementação

## Lista de verificação de qualidade

Antes da aprovação, verifique:

- [] Todos os testes foram aprovados (o mesmo que antes da refatoração)
- [] Comportamento idêntico (sem alterações de recursos)
- [] Qualidade do código melhorada (complexidade, legibilidade, duplicação reduzida)
- [] Desempenho mantido ou melhorado
- [] Cobertura de teste mantida ou melhorada
- [] Sem novos avisos ou erros
- [ ] Documentação atualizada
- [] Métricas medidas (complexidade, duplicação, cobertura)
- [ ] Impacto em outros módulos avaliados
- [] O código segue as convenções atuais do projeto

## Agentes Relacionados

- [`testing`__NOTRASLATE_29__ - Melhorar a cobertura e a confiabilidade do teste
- [`ci`__NOTRASLATE_30__ - Verifique a refatoração no pipeline de CI

## Exemplo de refatoração

### Antes

__NÃOTRADUZIR_7__

### Depois

__NÃOTRADUZIR_8__

**Melhorias**:
- Complexidade ciclomática: 8 → 2
- Linhas de código: 45 → 20
- Fluxo de controle muito mais claro
- Mais fácil de testar peças individuais
- Asy modernonc/await em vez de callback hell