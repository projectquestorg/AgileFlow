---
title: Orchestrator
description: Multi-Experten-Koordinator, der Fachexperten parallel einsetzt und Ergebnisse synthetisiert. Verfügt NUR über Task/TaskOutput-Tools – alle Arbeiten müssen delegiert werden.
---
# Orchestrator-Agent

Der Orchestrator-Agent ist ein Koordinator für mehrere Domänen, der komplexe Anfragen analysiert, relevante Expertendomänen identifiziert und parallel spezialisierte Agenten bereitstellt, um Arbeiten auszuführen. Anschließend werden alle Ergebnisse zu einer einheitlichen Antwort zusammengefasst.

## Fähigkeiten

- Analysiert komplexe Anfragen, um mehrere Domänen zu identifizieren (API, UI, Datenbank, Tests, Sicherheit, CI usw.)
– Stellt 2–8 Domänenexperten parallel für die gleichzeitige Ausführung bereit
- Koordiniert die Arbeitsausführung ausschließlich mithilfe der Task- und TaskOutput-Tools
- Führt Expertenergebnisse zu einheitlichen, konfliktbewussten Antworten zusammen
- Bewältigt sowohl parallele unabhängige Arbeiten als auch sequenzielle abhängige Arbeitsmuster
- Verwaltet Integrationspunkte zwischen mehreren spezialisierten Implementierungen

## Wann zu verwenden

Verwenden Sie dieses Mittel, wenn:

– **Full-Stack-Funktionen** – „Benutzerprofil mit API, Datenbankschema, UI-Komponente und Tests hinzufügen“ erfordert eine Koordination über mehrere Domänen hinweg
– **Komplexe Multi-Domain-Anfragen** – Einzelne Anfragen über API, Benutzeroberfläche und DatenbankAse- und Bereitstellungsänderungen
- **Parallele Arbeitskoordination** – Mehrere unabhängige Arbeitsschritte, die gleichzeitig ausgeführt werden sollten
– **Sequentielle abhängige Arbeit** – Arbeit, die in der richtigen Reihenfolge abgeschlossen werden muss (Datenbankschema → API → UI → Tests)
- **Integrationskoordination** – Sicherstellen, dass mehrere Implementierungen korrekt zusammenarbeiten
- **Umfassendes Refactoring** – Datenbankänderungen, die sich auf die API, dann auf die Benutzeroberfläche und dann auf Tests übertragen
– **Feature mit Infrastruktur** – Feature-Implementierung plus CI/CD-Pipeline-Setup

## Wie es funktioniert

Der Agent folgt einem strukturierten Arbeitsablauf:

```text
USER REQUEST
     ↓
┌─────────────────────────────────────┐
│ 1. ANALYZE DOMAINS                  │ → Identify API, UI, Database, etc.
│ 2. PLAN EXECUTION                   │ → Parallel vs sequential dependencies
│ 3. DEPLOY EXPERTS                   │ → Spawn via Task in parallel
│ 4. COLLECT RESULTS                  │ → TaskOutput with block: true
│ 5. SYNTHESIZE RESPONSE              │ → Unified output with integration points
└─────────────────────────────────────┘
     ↓
COORDINATED MULTI-DOMAIN IMPLEMENTATION
```

### Schritt 1: Anfrage analysieren

Der Agent analysiert die Anfrage nach Domain-Keywords und identifiziert, welche Experten benötigt werden:

| Anfrage | Domänen | Experten |
|---------|---------|---------|
| „Benutzerprofil mit API und UI hinzufügen“ | API + Benutzeroberfläche | 2 Experten (parallel) |
| „Login mit Tests hinzufügen“ | API + Sicherheit + Tests | 3 Experten (sequentiell) |
| „Datenbank umgestalten und API aktualisieren“ | Datenbank + API | 2 Experten (sequentiell) |
|„Full-Stack-Funktion mit CI“ | Datenbank + API + UI + Testen + CI | 5 Experten (gemischt) |

### Schritt 2: Planausführung

Der Agent bestimmt die Ausführungsstrategie basierend auf Abhängigkeiten:

**Parallele Ausführung** (unabhängige Arbeit):
```
API + UI (both can work simultaneously)
Testing + Documentation (can test while docs written)
Security audit + Performance analysis (independent reviews)
```

**Sequentielle Ausführung** (abhängige Arbeit):
```
Database schema → API implementation → UI component
(Each depends on previous)
```

**Gemischte Ausführung** (einige parallel, andere sequentiell):
```
Parallel: Database schema + API tests + Documentation
Then Sequential: API implementation → UI component
```

### Schritt 3: Experten einsetzen

Alle parallelen Experten werden gleichzeitig in einer einzigen Nachricht mithilfe der Hintergrundausführung bereitgestellt:

```text
Task(
  description: "Implement user profile API",
  prompt: "Create /api/profile endpoint with GET/PUT methods...",
  subagent_type: "agileflow-api",
  run_in_background: true
)

Task(
  description: "Implement profile UI component",
  prompt: "Create ProfilePage component with form...",
  subagent_type: "agileflow-ui",
  run_in_background: true
)
```

### Schritt 4: Ergebnisse sammeln

Verwendet `TaskOutput` mit `block: true`, um auf alle Expertenantworten zu warten:

```text
TaskOutput(task_id: "<api_task_id>", block: true)
TaskOutput(task_id: "<ui_task_id>", block: true)
```

### Schritt 5: Synthetisieren

Kombiniert alle Expertenergebnisse in einer einheitlichen Antwort, die Folgendes hervorhebt:
- Was jeder Experte abgeschlossen hat
- Integrationspunkte zwischen Implementierungen
- Konflikte oder Kompatibilitätsprobleme
- Empfohlene nächste Schritte

## Domain-Experten

Der Orchestrator koordiniert sich mit diesen Domänenspezialisten:

| Domäne | Experte | Zeitpunkt der Bereitstellung |
|--------|--------|---|
| **Datenbank** | `agileflow-database` | Schemadesign, Migrationen, Abfragen, Indizierung |
| **API** | `agileflow-api` | Endpunkte, Routen, Geschäftslogik, Validierung |
| **Benutzeroberfläche** | `agileflow-ui` | Komponenten, Styling, Formen, Zugänglichkeit |
| **Testen** | `agileflow-testing` | Unit-Tests, Integrationstests, Abdeckung |
| **Sicherheit** | `agileflow-security` | Authentifizierung, Autorisierung, Schwachstellen |
| **CI/CD** | `agileflow-ci` | Pipelines, Workflows, Linting, Typprüfung |
| **DevOps** | `agileflow-devops` | Bereitstellung, Infrastruktur, Containerisierung |
| **Dokumentation** | `agileflow-documentation` | API-Dokumente, Benutzerhandbücher, READMEs |
| **Leistung** | `agileflow-performance` | Optimierung, Profilierung, Benchmarking |

## Parallele Muster

### Full-Stack-Funktion

Stellen Sie Datenbank und API parallel (unabhängig) bereit, dann UI und Tests parallel (nachdem die API vorhanden ist):

```
Phase 1 (Parallel):
  - agileflow-database (schema)
  - agileflow-api (endpoint)

Phase 2 (Parallel, after Phase 1):
  - agileflow-ui (component)
  - agileflow-testing (tests)
```

### Codeüberprüfung/-analyse

Setzen Sie mehrere Experten ein, um dieselbe Codesimulation zu analysierenGleichzeitig:

```
Parallel (same code, different perspectives):
  - agileflow-security (vulnerability analysis)
  - agileflow-performance (optimization analysis)
  - agileflow-testing (test coverage analysis)

Then:
  - Synthesize findings and prioritize issues
```

### Best-of-N-Vergleich

Verteilen Sie dieselbe Aufgabe an mehrere Experten mit unterschiedlichen Ansätzen und vergleichen Sie:

```
Parallel (same task, different approaches):
  - Expert A (approach 1: REST API)
  - Expert B (approach 2: GraphQL API)
  - Expert C (approach 3: RPC API)

Then:
  - Compare implementations
  - Select best approach for codebase
  - Provide reasoning
```

## Kritische Einschränkungen

Der Orchestrator verfügt **NUR Task- und TaskOutput-Tools**:

### Kann:
- Spawn-Experten per Task
- Sammeln Sie Ergebnisse über TaskOutput
- Analysieren Sie Anfragen und planen Sie die Ausführung
- Antworten synthetisieren und koordinieren

### Nicht möglich:
- Dateien lesen (kein Lesetool)
- Dateien schreiben (kein Schreibtool)
- Dateien bearbeiten (kein Bearbeitungstool)
- Befehle ausführen (kein Bash-Tool)
- Suchcode (keine Glob/Grep-Tools)

**MÜSSEN ALLE Arbeiten an Domänenexperten delegieren.**

## Konfliktlösung

Wenn Experten widersprüchliche Ergebnisse liefern:

1. **Beachten Sie den Konflikt** im Syntheseabschnitt
2. **Stellen Sie beide Optionen dar** mit Kompromissen
3. **Empfehlen Sie eines** basierend auf:
   - Konsistenz mit bestehenden Mustern
   - Einfachheit und Wartbarkeit
   - Auswirkungen auf die Leistung
4. **Um Entscheidung bitten**, wenn die Empfehlung unklar ist

Beispielkonflikt:
```
### Conflicts / Review Needed

API Expert recommends: PUT /api/profile for updates
UI Expert expects: PATCH /api/profile for updates

Recommendation: Use PUT (simpler, consistent with REST conventions)
UI can send full profile object without issues.
```

## Beispiel: Voll-Stack-Benutzerprofilfunktion

**Anfrage**: „Eine vollständige Benutzerprofilfunktion mit API, Datenbank, React-Komponente und Tests hinzufügen“

**Antwort des Organisators**:

```
Analyzing multi-domain request...

Domains identified:
- Database (schema for user profiles)
- API (REST endpoints)
- UI (React component)
- Testing (unit and integration tests)

Execution plan:
- Phase 1 (Parallel): Database + API (API needs schema)
- Phase 2 (Parallel): UI + Testing (both use API)

[Spawning Phase 1 experts...]
- Database Expert → User profiles schema
- API Expert → /api/profile endpoints

[Collecting Phase 1 results...]

[Spawning Phase 2 experts...]
- UI Expert → ProfilePage component
- Testing Expert → Comprehensive test suite

[Collecting Phase 2 results...]

## Orchestration Complete

### Database Expert ✅
- Created `profiles` table with columns: id, user_id, bio, avatar_url, etc.
- Added indexes on user_id and created_at
- Files: `migrations/001_create_profiles.sql`

### API Expert ✅
- GET /api/profile - Fetch user profile
- PUT /api/profile - Update profile
- DELETE /api/profile - Remove profile
- Files: `src/routes/profile.ts`, `src/controllers/ProfileController.ts`

### UI Expert ✅
- ProfilePage component with form
- Form validation and error handling
- Styling with Tailwind CSS
- Files: `src/components/ProfilePage.tsx`, `src/hooks/useProfile.ts`

### Testing Expert ✅
- Unit tests for ProfilePage component
- Integration tests for API endpoints
- Database query tests
- 87% coverage
- Files: `src/routes/__tests__/profile.test.ts`, `src/components/__tests__/ProfilePage.test.tsx`

### Integration Points
- UI imports API functions from `src/api/profile.ts`
- UI calls GET /api/profile on component mount
- Form submission sends PUT to /api/profile
- Database schema matches API data model

### Next Steps
1. Wire ProfilePage into router in App.tsx
2. Add authentication middleware to API routes
3. Add validation on API layer
4. Deploy to staging for E2E testing

Ready to proceed with integration?
```

## Schlüsselverhalten

- **Analysen IMMER für mehrere Domänen** - Geht niemals von der Arbeit einer einzelnen Domäne aus
- **Plant IMMER die Ausführungsstrategie** – Parallel vs. sequentiell basierend auf Abhängigkeiten
- **Stellt Experten IMMER parallel bereit** - Niemals nacheinander, es sei denn, Abhängigkeiten erfordern dies
- **Stellt IMMER ALLE Experten in einer EINZIGEN Nachricht bereit** - Stapelt Aufgabenaufrufe zusammen
- **Verwendet IMMER TaskOutput mit Block: true** – Wartet vor der Synthese auf alle Ergebnisse
- **Gib NIEMALS eine endgültige Antwort, ohne ALLE Expertenantworten zusammenzufassen** - Alle Perspektiven müssen integriert werden
- **Notiert IMMER Integrationspunkte** - Hebt hervor, wie Implementierungen miteinander verbunden sind

## Werkzeuge verfügbar

Dieser Agent hat **NUR** Zugriff auf:
- **Aufgabe** – Domain-Expert-Agents parallel bereitstellen
- **TaskOutput** – Sammeln Sie Expertenergebnisse und warten Sie auf den Abschluss

Es hat KEINEN Zugangss an:
- Lesen, Schreiben, Bearbeiten (Code selbst kann nicht geändert werden)
- Bash (Befehle können nicht ausgeführt werden)
- Glob, Grep (Code kann nicht gesucht werden)

Diese Einschränkung stellt sicher, dass sich der Orchestrator ausschließlich auf die Koordination und nicht auf die Implementierung konzentriert.

## Modellkonfiguration

- **Modell**: Claude Sonnet 3.5 (optimiert für Koordination)
- **Begründung**: Planung, parallele Ausführung, Syntheselogik

## Verwandte Agenten

**Domänenspezialisten** (bereitgestellt durch Orchestrator):
- [`database`](/agents/database) – Datenbankschema- und Abfrageexperte
- [`api`](/agents/api) – REST-API-Endpunktexperte
- [`ui`](/agents/ui) – Experte für Frontend-Komponenten
- [`testing`](/agents/testing) – Experte für Testabdeckung und Strategie
- [`security`](/agents/security) – Experte für Sicherheit und Authentifizierung
- [`performance`](/agents/performance) – Experte für Leistungsoptimierung
- [`ci`](/agents/ci) – CI/CD-Pipeline-Experte
- [`devops`](/agents/devops) - Infrastruktur und deBeschäftigungsexperte
- [`documentation`](/agents/documentation) – Experte für technische Dokumentation

**Andere Meta-Agenten**:
- [`multi-expert`](/agents/multi-expert) – Analysiert dasselbe Problem mit 3–5 Experten (unterschiedlicher Anwendungsfall – Analyse vs. Implementierung)
- [`mentor`](/agents/mentor) – End-to-End-Implementierungsanleitung

## Wann NICHT zu verwenden ist

- **Einfache Einzeldomänenaufgaben** - Verwenden Sie stattdessen den direkten Domänenexperten (schneller, einfacher)
- **Nur Analyse** – Verwenden Sie den Multi-Expert-Agenten für eine Analyse mit hoher Zuverlässigkeit
- **Einfache Fragen** - Wenden Sie sich direkt an spezialisierte Agenten
- **Aufgaben, die eine manuelle Koordination erfordern** – Orchestrator funktioniert nur mit Agenten