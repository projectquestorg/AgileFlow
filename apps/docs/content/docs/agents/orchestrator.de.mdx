---
title: Orchestrator
description: Multi-Experten-Koordinator, der Fachexperten parallel einsetzt und Ergebnisse synthetisiert. Verfügt NUR über Task/TaskOutput-Tools – alle Arbeiten müssen delegiert werden.
---

# Orchestrator-Agent

Der Orchestrator-Agent ist ein Koordinator für mehrere Domänen, der komplexe Anfragen analysiert, relevante Expertendomänen identifiziert und parallel spezialisierte Agenten bereitstellt, um Arbeiten auszuführen. Anschließend werden alle Ergebnisse zu einer einheitlichen Antwort zusammengefasst.

## Fähigkeiten

- Analysiert komplexe Anfragen, um mehrere Domänen zu identifizieren (API, UI, Datenbank, Tests, Sicherheit, CI usw.)
- Stellt 2–8 Domänenexperten parallel für die gleichzeitige Ausführung bereit
- Koordiniert die Arbeitsausführung ausschließlich mithilfe der Task- und TaskOutput-Tools
- Fasst Expertenergebnisse in einheitliche, konfliktbewusste Antworten zusammen
- Bewältigt sowohl parallele unabhängige Arbeit als auch sequenzielle abhängige Arbeitsmuster
- Verwaltet Integrationspunkte zwischen mehreren spezialisierten Implementierungen

## Wann zu verwenden

Verwenden Sie dieses Mittel, wenn:

- **Full-stack features** – „Benutzerprofil mit API, Datenbankschema, UI-Komponente und Tests hinzufügen“ erfordert eine Koordination über mehrere Domänen hinweg
- **Complex multi-domain requests** – Einzelne Anfragen, die API-, UI-, Datenbank- und Bereitstellungsänderungen umfassen
- **Parallel work coordination** – Mehrere unabhängige Arbeiten, die gleichzeitig ausgeführt werden sollten
- **Sequential dependent work** – Arbeiten, die in der richtigen Reihenfolge abgeschlossen werden müssen (Datenbankschema → API → UI → Tests)
- **Integration coordination** - Ensuring multiple implementations work together correctly
- **Large refactoring** – Datenbankänderungen, die sich auf die API, dann auf die Benutzeroberfläche und dann auf Tests übertragen
- **Feature with infrastructure** - Funktionsimplementierung plus Einrichtung der CI/CD-Pipeline

## Wie es funktioniert

Der Agent folgt einem strukturierten Arbeitsablauf:

```text
USER REQUEST
     ↓
┌─────────────────────────────────────┐
│ 1. ANALYZE DOMAINS                  │ → Identify API, UI, Database, etc.
│ 2. PLAN EXECUTION                   │ → Parallel vs sequential dependencies
│ 3. DEPLOY EXPERTS                   │ → Spawn via Task in parallel
│ 4. COLLECT RESULTS                  │ → TaskOutput with block: true
│ 5. SYNTHESIZE RESPONSE              │ → Unified output with integration points
└─────────────────────────────────────┘
     ↓
COORDINATED MULTI-DOMAIN IMPLEMENTATION
```

### Schritt 1: Anfrage analysieren

Der Agent analysiert die Anfrage nach Domain-Keywords und identifiziert, welche Experten benötigt werden:

| Request | Domains | Experts |
|---------|---------|---------|
| "Add user profile with API and UI" | API + UI | 2 experts (parallel) |
| "Add login with tests" | API + Security + Testing | 3 experts (sequential) |
| "Refactor database and update API" | Database + API | 2 experts (sequential) |
| "Full-stack feature with CI" | Database + API + UI + Testing + CI | 5 experts (mixed) |

### Schritt 2: Planausführung

Der Agent bestimmt die Ausführungsstrategie basierend auf Abhängigkeiten:

**Parallel Execution** (selbständige Arbeit):
```
API + UI (both can work simultaneously)
Testing + Documentation (can test while docs written)
Security audit + Performance analysis (independent reviews)
```

**Sequential Execution** (abhängige Arbeit):
```
Database schema → API implementation → UI component
(Each depends on previous)
```

**Mixed Execution** (einige parallel, einige sequentiell):
```
Parallel: Database schema + API tests + Documentation
Then Sequential: API implementation → UI component
```

### Schritt 3: Experten einsetzen

Alle parallelen Experten werden gleichzeitig in einer einzigen Nachricht mithilfe der Hintergrundausführung bereitgestellt:

```text
Task(
  description: "Implement user profile API",
  prompt: "Create /api/profile endpoint with GET/PUT methods...",
  subagent_type: "agileflow-api",
  run_in_background: true
)

Task(
  description: "Implement profile UI component",
  prompt: "Create ProfilePage component with form...",
  subagent_type: "agileflow-ui",
  run_in_background: true
)
```

### Schritt 4: Ergebnisse sammeln

Verwendungsmöglichkeiten `TaskOutput` mit `block: true` auf alle Expertenantworten warten:

```text
TaskOutput(task_id: "<api_task_id>", block: true)
TaskOutput(task_id: "<ui_task_id>", block: true)
```

### Schritt 5: Synthetisieren

Kombiniert alle Expertenergebnisse in einer einheitlichen Antwort, die Folgendes hervorhebt:
- Was jeder Experte abgeschlossen hat
- Integrationspunkte zwischen Implementierungen
- Konflikte oder Kompatibilitätsprobleme
- Empfohlene nächste Schritte

## Domain-Experten

Der Orchestrator koordiniert sich mit diesen Domänenspezialisten:

| Domain | Expert | When to Deploy |
|--------|--------|---|
| **Database** | `agileflow-database` | Schema design, migrations, queries, indexing |
| **API** | `agileflow-api` | Endpoints, routes, business logic, validation |
| **UI** | `agileflow-ui` | Components, styling, forms, accessibility |
| **Testing** | `agileflow-testing` | Unit tests, integration tests, coverage |
| **Security** | `agileflow-security` | Authentication, authorization, vulnerabilities |
| **CI/CD** | `agileflow-ci` | Pipelines, workflows, linting, type checking |
| **DevOps** | `agileflow-devops` | Deployment, infrastructure, containerization |
| **Documentation** | `agileflow-documentation` | API docs, user guides, READMEs |
| **Performance** | `agileflow-performance` | Optimization, profiling, benchmarking |

## Parallele Muster

### Full-Stack-Funktion

Stellen Sie Datenbank und API parallel (unabhängig) bereit, dann UI und Tests parallel (nachdem die API vorhanden ist):

```
Phase 1 (Parallel):
  - agileflow-database (schema)
  - agileflow-api (endpoint)

Phase 2 (Parallel, after Phase 1):
  - agileflow-ui (component)
  - agileflow-testing (tests)
```

### Codeüberprüfung/-analyse

Setzen Sie mehrere Experten ein, um denselben Code gleichzeitig zu analysieren:

```
Parallel (same code, different perspectives):
  - agileflow-security (vulnerability analysis)
  - agileflow-performance (optimization analysis)
  - agileflow-testing (test coverage analysis)

Then:
  - Synthesize findings and prioritize issues
```

### Best-of-N-Vergleich

Verteilen Sie dieselbe Aufgabe an mehrere Experten mit unterschiedlichen Ansätzen und vergleichen Sie:

```
Parallel (same task, different approaches):
  - Expert A (approach 1: REST API)
  - Expert B (approach 2: GraphQL API)
  - Expert C (approach 3: RPC API)

Then:
  - Compare implementations
  - Select best approach for codebase
  - Provide reasoning
```

## Kritische Einschränkungen

Der Orchestrator hat **ONLY Task and TaskOutput tools**:

### Kann:
- Spawn-Experten per Aufgabe
- Sammeln Sie Ergebnisse über TaskOutput
- Analysieren Sie Anfragen und planen Sie die Ausführung
- Antworten synthetisieren und koordinieren

### Nicht möglich:
- Dateien lesen (kein Lesetool)
- Dateien schreiben (kein Schreibtool)
- Dateien bearbeiten (kein Bearbeitungstool)
- Befehle ausführen (kein Bash-Tool)
- Suchcode (keine Glob/Grep-Tools)

**MUST delegate ALL work to domain experts.**

## Konfliktlösung

Wenn Experten widersprüchliche Ergebnisse liefern:

1. **Note the conflict** im Syntheseabschnitt
2. **Present both options** mit Kompromissen
3. **Recommend one** bezogen auf:
   - Konsistenz mit bestehenden Mustern
   - Einfachheit und Wartbarkeit
   - Auswirkungen auf die Leistung
4. **Ask for decision** wenn Empfehlung unklar

Beispielkonflikt:
```
### Conflicts / Review Needed

API Expert recommends: PUT /api/profile for updates
UI Expert expects: PATCH /api/profile for updates

Recommendation: Use PUT (simpler, consistent with REST conventions)
UI can send full profile object without issues.
```

## Beispiel: Full-Stack-Benutzerprofilfunktion

**Request**: „Fügen Sie eine vollständige Benutzerprofilfunktion mit API, Datenbank, React-Komponente und Tests hinzu.“

**Orchestrator Response**:

```
Analyzing multi-domain request...

Domains identified:
- Database (schema for user profiles)
- API (REST endpoints)
- UI (React component)
- Testing (unit and integration tests)

Execution plan:
- Phase 1 (Parallel): Database + API (API needs schema)
- Phase 2 (Parallel): UI + Testing (both use API)

[Spawning Phase 1 experts...]
- Database Expert → User profiles schema
- API Expert → /api/profile endpoints

[Collecting Phase 1 results...]

[Spawning Phase 2 experts...]
- UI Expert → ProfilePage component
- Testing Expert → Comprehensive test suite

[Collecting Phase 2 results...]

## Orchestration Complete

### Database Expert ✅
- Created `profiles` table with columns: id, user_id, bio, avatar_url, etc.
- Added indexes on user_id and created_at
- Files: `migrations/001_create_profiles.sql`

### API Expert ✅
- GET /api/profile - Fetch user profile
- PUT /api/profile - Update profile
- DELETE /api/profile - Remove profile
- Files: `src/routes/profile.ts`, `src/controllers/ProfileController.ts`

### UI Expert ✅
- ProfilePage component with form
- Form validation and error handling
- Styling with Tailwind CSS
- Files: `src/components/ProfilePage.tsx`, `src/hooks/useProfile.ts`

### Testing Expert ✅
- Unit tests for ProfilePage component
- Integration tests for API endpoints
- Database query tests
- 87% coverage
- Files: `src/routes/__tests__/profile.test.ts`, `src/components/__tests__/ProfilePage.test.tsx`

### Integration Points
- UI imports API functions from `src/api/profile.ts`
- UI calls GET /api/profile on component mount
- Form submission sends PUT to /api/profile
- Database schema matches API data model

### Next Steps
1. Wire ProfilePage into router in App.tsx
2. Add authentication middleware to API routes
3. Add validation on API layer
4. Deploy to staging for E2E testing

Ready to proceed with integration?
```

## Schlüsselverhalten

- **ALWAYS analyzes for multiple domains** - Geht niemals davon aus, dass es sich um eine Einzeldomänenarbeit handelt
- **ALWAYS plans execution strategy** - Parallel vs. sequentiell basierend auf Abhängigkeiten
- **ALWAYS deploys experts in parallel** - Niemals nacheinander, es sei denn, Abhängigkeiten erfordern dies
- **ALWAYS deploys ALL experts in a SINGLE message** - Sammelt Aufgabenaufrufe zusammen
- **ALWAYS uses TaskOutput with block: true** - Wartet vor der Synthese auf alle Ergebnisse
- **NEVER gives final answer without synthesizing ALL expert responses** - Alle Perspektiven müssen integriert werden
- **ALWAYS notes integration points** – Hebt hervor, wie Implementierungen miteinander verbunden sind

## Tools Available

Dieser Agent hat Zugriff auf **ONLY**:
- **Task** - Stellen Sie Domänenexpertenagenten parallel bereit
- **TaskOutput** - Sammeln Sie Expertenergebnisse und warten Sie auf den Abschluss

Es hat KEINEN Zugriff auf:
- Lesen, Schreiben, Bearbeiten (Code selbst kann nicht geändert werden)
- Bash (Befehle können nicht ausgeführt werden)
- Glob, Grep (Code kann nicht gesucht werden)

Diese Einschränkung stellt sicher, dass sich der Orchestrator ausschließlich auf die Koordination und nicht auf die Implementierung konzentriert.

## Modellkonfiguration

- **Model**: Claude Sonnet 3.5 (optimiert für Koordination)
- **Reasoning**: Planung, parallele Ausführung, Syntheselogik

## Verwandte Agenten

**Domain Specialists** (bereitgestellt durch Orchestrator):
- [„Datenbank“.](/agents/database) - Experte für Datenbankschemata und Abfragen
- [„api“.](/agents/api) - Experte für REST-API-Endpunkte
- `ui` - Experte für Frontend-Komponenten
- [„Testen“.](/agents/testing) - Experte für Testabdeckung und Strategie
- [„Sicherheit“.](/agents/security) - Experte für Sicherheit und Authentifizierung
- [„Leistung“.](/agents/performance) - Experte für Leistungsoptimierung
- [„ci“.](/agents/ci) - CI/CD-Pipeline-Experte
- [„Entwickler“.](/agents/devops) - Infrastruktur- und Bereitstellungsexperte
- [„Dokumentation“.](/agents/documentation) - Experte für technische Dokumentation

**Other Meta Agents**:
- [„Multi-Experte“.](/agents/multi-expert) - Analysiert dasselbe Problem mit 3–5 Experten (unterschiedlicher Anwendungsfall – Analyse vs. Implementierung)
- [„Mentor“.](/agents/mentor) - End-to-End-Implementierungsanleitung

## Wann NICHT zu verwenden ist

- **Simple single-domain tasks** - Verwenden Sie stattdessen den direkten Domain-Experten (schneller, einfacher)
- **Analysis only** - Verwenden Sie den Multi-Expert-Agenten für eine Analyse mit hoher Zuverlässigkeit
- **Simple questions** - Nutzen Sie direkt spezialisierte Agenten
- **Tasks requiring manual coordination** – Orchestrator funktioniert nur mit Agenten
