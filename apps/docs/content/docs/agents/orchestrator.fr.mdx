---
title: Orchestrateur
description: Coordinateur multi-experts qui déploie en parallèle les experts du domaine et synthétise les résultats. Possède UNIQUEMENT des outils Task/TaskOutput - doit déléguer tout le travail.
---
#Agent orchestrateur

L'agent Orchestrator est un coordinateur multidomaine qui analyse les demandes complexes, identifie les domaines experts pertinents et déploie des agents spécialisés en parallèle pour exécuter le travail. Il synthétise ensuite tous les résultats en une réponse unifiée.

## Capacités

- Analyse les requêtes complexes pour identifier plusieurs domaines (API, UI, Base de données, Tests, Sécurité, CI, etc.)
- Déploie 2 à 8 experts de domaine en parallèle pour une exécution simultanée
- Coordonne l'exécution du travail en utilisant uniquement les outils Task et TaskOutput
- Synthèse des résultats d'experts en réponses unifiées et tenant compte des conflits
- Gère à la fois le travail indépendant parallèle et les modèles de travail dépendants séquentiels
- Gère les points d'intégration entre plusieurs implémentations spécialisées

## Quand l'utiliser

Utilisez cet agent lorsque :

- **Fonctionnalités Full-stack** - "Ajouter un profil utilisateur avec API, schéma de base de données, composant d'interface utilisateur et tests" nécessite une coordination sur plusieurs domaines
- **Demandes multidomaines complexes** - Requêtes uniques couvrant l'API, l'interface utilisateur et la base de donnéesase et changements de déploiement
- **Coordination du travail parallèle** - Plusieurs éléments de travail indépendants qui doivent s'exécuter simultanément
- **Travail dépendant séquentiel** - Travail qui doit être terminé dans l'ordre (schéma de base de données → API → UI → tests)
- **Coordination de l'intégration** - S'assurer que plusieurs implémentations fonctionnent correctement ensemble
- **Grande refactorisation** - Modifications de la base de données qui se propagent à l'API, puis à l'interface utilisateur, puis aux tests
- **Fonctionnalité avec infrastructure** - Implémentation de fonctionnalités et configuration du pipeline CI/CD

## Comment ça marche

L'agent suit un workflow structuré :

```text
USER REQUEST
     ↓
┌─────────────────────────────────────┐
│ 1. ANALYZE DOMAINS                  │ → Identify API, UI, Database, etc.
│ 2. PLAN EXECUTION                   │ → Parallel vs sequential dependencies
│ 3. DEPLOY EXPERTS                   │ → Spawn via Task in parallel
│ 4. COLLECT RESULTS                  │ → TaskOutput with block: true
│ 5. SYNTHESIZE RESPONSE              │ → Unified output with integration points
└─────────────────────────────────────┘
     ↓
COORDINATED MULTI-DOMAIN IMPLEMENTATION
```

### Étape 1 : Analyser la demande

L'agent analyse la demande de mots-clés du domaine et identifie les experts nécessaires :

| Demande | Domaines | Experts |
|---------|---------|---------|
| "Ajouter un profil utilisateur avec API et UI" | API + interface utilisateur | 2 experts (parallèle) |
| "Ajouter une connexion avec des tests" | API + Sécurité + Tests | 3 experts (séquentiels) |
| "Refactoriser la base de données et mettre à jour l'API" | Base de données + API | 2 experts (séquentiels) |
|"Fonctionnalité full-stack avec CI" | Base de données + API + UI + Tests + CI | 5 experts (mixtes) |

### Étape 2 : Exécution du plan

L'agent détermine la stratégie d'exécution en fonction des dépendances :

**Exécution parallèle** (travail indépendant) :
```
API + UI (both can work simultaneously)
Testing + Documentation (can test while docs written)
Security audit + Performance analysis (independent reviews)
```

**Exécution séquentielle** (travail dépendant) :
```
Database schema → API implementation → UI component
(Each depends on previous)
```

**Exécution mixte** (certaines parallèles, certaines séquentielles) :
```
Parallel: Database schema + API tests + Documentation
Then Sequential: API implementation → UI component
```

### Étape 3 : Déployer des experts

Tous les experts parallèles sont déployés simultanément dans un seul message en utilisant une exécution en arrière-plan :

```text
Task(
  description: "Implement user profile API",
  prompt: "Create /api/profile endpoint with GET/PUT methods...",
  subagent_type: "agileflow-api",
  run_in_background: true
)

Task(
  description: "Implement profile UI component",
  prompt: "Create ProfilePage component with form...",
  subagent_type: "agileflow-ui",
  run_in_background: true
)
```

### Étape 4 : Collecter les résultats

Utilise `TaskOutput` avec `block: true` pour attendre toutes les réponses des experts :

```text
TaskOutput(task_id: "<api_task_id>", block: true)
TaskOutput(task_id: "<ui_task_id>", block: true)
```

### Étape 5 : Synthétiser

Combine toutes les conclusions des experts dans une réponse unifiée mettant en évidence :
- Ce que chaque expert a réalisé
- Points d'intégration entre les implémentations
- Conflits ou problèmes de compatibilité
- Prochaines étapes recommandées

## Experts du domaine

L'Orchestrateur se coordonne avec ces spécialistes du domaine :

| Domaine | Expert | Quand déployer |
|--------|--------|---|
| **Base de données** | `agileflow-database` | Conception de schémas, migrations, requêtes, indexation |
| **API** | `agileflow-api` | Points de terminaison, routes, logique métier, validation |
| **interface utilisateur** | `agileflow-ui` | Composants, style, formulaires, accessibilité |
| **Tests** | `agileflow-testing` | Tests unitaires, tests d'intégration, couverture |
| **Sécurité** | `agileflow-security` | Authentification, autorisation, vulnérabilités |
| **CI/CD** | `agileflow-ci` | Pipelines, workflows, peluchage, vérification de type |
| **DevOps** | `agileflow-devops` | Déploiement, infrastructure, conteneurisation |
| **Documentations** | `agileflow-documentation` | Documents API, guides d'utilisation, README |
| **Performances** | `agileflow-performance` | Optimisation, profilage, benchmarking |

## Modèles parallèles

### Fonctionnalité Full-Stack

Déployer la base de données et l'API en parallèle (indépendant), puis l'interface utilisateur et les tests en parallèle (une fois l'API existante) :

```
Phase 1 (Parallel):
  - agileflow-database (schema)
  - agileflow-api (endpoint)

Phase 2 (Parallel, after Phase 1):
  - agileflow-ui (component)
  - agileflow-testing (tests)
```

### Revue/analyse du code

Déployez plusieurs experts pour analyser le même code simuEn attendant :

```
Parallel (same code, different perspectives):
  - agileflow-security (vulnerability analysis)
  - agileflow-performance (optimization analysis)
  - agileflow-testing (test coverage analysis)

Then:
  - Synthesize findings and prioritize issues
```

### Comparaison du meilleur des N

Déployez la même tâche auprès de plusieurs experts avec des approches différentes et comparez :

```
Parallel (same task, different approaches):
  - Expert A (approach 1: REST API)
  - Expert B (approach 2: GraphQL API)
  - Expert C (approach 3: RPC API)

Then:
  - Compare implementations
  - Select best approach for codebase
  - Provide reasoning
```

## Contraintes critiques

L'Orchestrator dispose de **UNIQUEMENT les outils Task et TaskOutput** :

### Peut faire :
- Faire apparaître des experts via une tâche
- Collecter les résultats via TaskOutput
- Analyser les demandes et planifier l'exécution
- Synthétiser et coordonner les réponses

### Impossible de faire :
- Lire des fichiers (pas d'outil de lecture)
- Écrire des fichiers (pas d'outil d'écriture)
- Modifier des fichiers (pas d'outil d'édition)
- Exécuter des commandes (pas d'outil Bash)
- Code de recherche (pas d'outils Glob/Grep)

**DOIT déléguer TOUS les travaux à des experts du domaine.**

## Résolution des conflits

Lorsque les experts produisent des résultats contradictoires :

1. **Notez le conflit** dans la section de synthèse
2. **Présentez les deux options** avec des compromis
3. **Recommandez-en un** en fonction de :
   - Cohérence avec les modèles existants
   - Simplicité et maintenabilité
   - Implications en termes de performances
4. **Demander une décision** si la recommandation n'est pas claire

Exemple de conflit :
```
### Conflicts / Review Needed

API Expert recommends: PUT /api/profile for updates
UI Expert expects: PATCH /api/profile for updates

Recommendation: Use PUT (simpler, consistent with REST conventions)
UI can send full profile object without issues.
```

## Exemple : Complet-Fonctionnalité de profil utilisateur de pile

**Demande** : "Ajouter une fonctionnalité de profil utilisateur complète avec API, base de données, composant React et tests"

**Réponse de l'orchestre** :

```
Analyzing multi-domain request...

Domains identified:
- Database (schema for user profiles)
- API (REST endpoints)
- UI (React component)
- Testing (unit and integration tests)

Execution plan:
- Phase 1 (Parallel): Database + API (API needs schema)
- Phase 2 (Parallel): UI + Testing (both use API)

[Spawning Phase 1 experts...]
- Database Expert → User profiles schema
- API Expert → /api/profile endpoints

[Collecting Phase 1 results...]

[Spawning Phase 2 experts...]
- UI Expert → ProfilePage component
- Testing Expert → Comprehensive test suite

[Collecting Phase 2 results...]

## Orchestration Complete

### Database Expert ✅
- Created `profiles` table with columns: id, user_id, bio, avatar_url, etc.
- Added indexes on user_id and created_at
- Files: `migrations/001_create_profiles.sql`

### API Expert ✅
- GET /api/profile - Fetch user profile
- PUT /api/profile - Update profile
- DELETE /api/profile - Remove profile
- Files: `src/routes/profile.ts`, `src/controllers/ProfileController.ts`

### UI Expert ✅
- ProfilePage component with form
- Form validation and error handling
- Styling with Tailwind CSS
- Files: `src/components/ProfilePage.tsx`, `src/hooks/useProfile.ts`

### Testing Expert ✅
- Unit tests for ProfilePage component
- Integration tests for API endpoints
- Database query tests
- 87% coverage
- Files: `src/routes/__tests__/profile.test.ts`, `src/components/__tests__/ProfilePage.test.tsx`

### Integration Points
- UI imports API functions from `src/api/profile.ts`
- UI calls GET /api/profile on component mount
- Form submission sends PUT to /api/profile
- Database schema matches API data model

### Next Steps
1. Wire ProfilePage into router in App.tsx
2. Add authentication middleware to API routes
3. Add validation on API layer
4. Deploy to staging for E2E testing

Ready to proceed with integration?
```

## Comportements clés

- **TOUJOURS analyser pour plusieurs domaines** - Ne suppose jamais un travail sur un seul domaine
- **Planifie TOUJOURS une stratégie d'exécution** - Parallèle ou séquentiel en fonction des dépendances
- **Déploie TOUJOURS les experts en parallèle** - Jamais de manière séquentielle, sauf si les dépendances l'exigent
- **Déploie TOUJOURS TOUS les experts dans un SEUL message** - Regroupe les appels de tâches ensemble
- **Utilise TOUJOURS TaskOutput avec le bloc : true** - Attend tous les résultats avant la synthèse
- **NE JAMAIS donner de réponse finale sans synthétiser TOUTES les réponses des experts** - Toutes les perspectives doivent s'intégrer
- **Note TOUJOURS les points d'intégration** - Met en évidence la manière dont les implémentations se connectent

## Outils disponibles

Cet agent a accès à **UNIQUEMENT** :
- **Tâche** - Déployer des agents experts de domaine en parallèle
- **TaskOutput** - Collectez les résultats des experts et attendez la fin

Il n'a PAS accèsss à :
- Lire, écrire, modifier (impossible de modifier le code lui-même)
- Bash (impossible d'exécuter des commandes)
- Glob, Grep (impossible de rechercher le code)

Cette contrainte garantit que l'Orchestrateur se concentre exclusivement sur la coordination et non sur la mise en œuvre.

## Configuration du modèle

- **Modèle** : Claude Sonnet 3.5 (optimisé pour la coordination)
- **Raisonnement** : Planification, exécution parallèle, logique de synthèse

## Agents associés

**Spécialistes de domaine** (déployés par Orchestrator) :
- [`database`](/agents/database) - Expert en schéma de base de données et en requêtes
- [`api`](/agents/api) - Expert en points de terminaison de l'API REST
- [`ui`](/agents/ui) - Expert en composants frontend
- [`testing`](/agents/testing) - Expert en couverture de tests et en stratégie
- [`security`](/agents/security) - Expert en sécurité et authentification
- [`performance`](/agents/performance) - Expert en optimisation des performances
- [`ci`](/agents/ci) - Expert en pipeline CI/CD
- [`devops`](/agents/devops) - Infrastructure et deexpert en placement
- [`documentation`](/agents/documentation) - Expert en documentation technique

**Autres méta-agents** :
- [`multi-expert`](/agents/multi-expert) - Analyse le même problème avec 3 à 5 experts (cas d'utilisation différent - analyse vs mise en œuvre)
- [`mentor`](/agents/mentor) - Conseils de mise en œuvre de bout en bout

## Quand NE PAS utiliser

- **Tâches simples sur un seul domaine** - Utilisez plutôt un expert de domaine direct (plus rapide, plus simple)
- **Analyse uniquement** - Utilisez l'agent multi-expert pour une analyse de haute confiance
- **Questions simples** - Faire appel directement à des agents spécialisés
- **Tâches nécessitant une coordination manuelle** - Orchestrator fonctionne uniquement avec des agents