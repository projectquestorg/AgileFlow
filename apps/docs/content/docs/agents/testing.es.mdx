---
title: Pruebas
description: Especialista en pruebas para estrategia de prueba, patrones de prueba, optimización de cobertura y diseño integral de conjuntos de pruebas.
---

# Agente de prueba

El agente de pruebas (AG-TESTING) es un experto especializado en control de calidad que diseña estrategias de prueba integrales, elimina los antipatrones de prueba y optimiza la cobertura de las pruebas. A diferencia de la configuración de la infraestructura de CI, este agente se centra en las preguntas de "qué probar" y "cómo probarlo".

## Capacidades

- **Test Strategy Design**: Cree planes de prueba integrales que abarquen pruebas unitarias, de integración y E2E.
- **Coverage Optimization**: Analizar la cobertura del código e identificar brechas en rutas críticas
- **Test Anti-Pattern Detection**: Identifique y elimine pruebas escamosas, lentas y quebradizas
- **Test Infrastructure**: cree dispositivos de prueba, fábricas y funciones auxiliares
- **Coverage Analysis**: Mida e informe métricas de cobertura con recomendaciones prácticas
- **Test Pattern Documentation**: Documentar patrones de prueba reutilizables y mejores prácticas.
- **Performance Testing**: Diseñar y ejecutar puntos de referencia de rendimiento.
- **Mutation Testing**: Pruebe las pruebas mismas para garantizar la calidad.

## Cuando usar

Utilice el agente de prueba cuando:

- Iniciar una nueva función y es necesario definir qué necesita probarse
- La cobertura actual de las pruebas está por debajo del 70% y necesita mejoras
- Las pruebas son inestables (fallas intermitentes) o lentas (>1 segundo cada una)
- Necesidad de diseñar instalaciones de prueba o fábricas para datos de prueba complejos
- Configuración de una infraestructura de pruebas automatizada
- Creación de ADR para decisiones de prueba
- Implementación de conjuntos de pruebas integrales para rutas críticas

## Cómo funciona

1. **Knowledge Loading**: El agente lee el archivo de experiencia y el estado de prueba del proyecto.
2. **Story Review**: El agente analiza la historia para determinar los requisitos de capacidad de prueba.
3. **Test Planning**: El agente diseña casos de prueba (camino feliz, casos de error, casos extremos)
4. **Infrastructure Setup**: El agente crea dispositivos de prueba, simulacros y ayudantes.
5. **Test Implementation**: El agente escribe pruebas siguiendo el patrón AAA (Arrange-Act-Assert)
6. **Coverage Measurement**: El agente mide la cobertura e identifica brechas
7. **Anti-Pattern Elimination**: El agente identifica y repara pruebas inestables/lentas/quebradizas
8. **Verification**: El agente se ejecuta `/agileflow:verify` para garantizar que todas las pruebas pasen
9. **Coordination**: El agente actualiza status.json y se comunica a través de bus/log.jsonl

## Ejemplo

```bash
# Via babysit - identify testing work
/agileflow:babysit
> "We need comprehensive testing for the payment processing feature"

# Agent output:
# Test Strategy Created:
# - Unit tests: Payment validation, transaction formatting (80% coverage)
# - Integration tests: Database saves, external API calls (15% coverage)
# - E2E tests: Complete payment workflow (5% coverage)
# - Coverage target: 85% critical path
# - Expected test count: 47 tests
# - Estimated time: 4 hours
```

## Comportamientos clave

- **AAA Pattern**: All tests follow Arrange-Act-Assert structure for clarity
- **Test Isolation**: Las pruebas unitarias simulan dependencias; Las pruebas de integración utilizan dependencias reales.
- **Behavior-Focused**: Las pruebas validan el comportamiento, no los detalles de implementación.
- **Fast Execution**: Las pruebas unitarias se ejecutan en milisegundos; suite completa en minutos
- **Clear Naming**: Los nombres de las pruebas describen exactamente lo que se está probando.
- **Coverage Thresholds**: 70% mínimo, 80%+ para rutas críticas (100% para autenticación/pago)
- **No Flaky Tests**: Las fallas intermitentes son señales de alerta; Se elimina la aleatoriedad y el tiempo.
- **Performance Awareness**: Las pruebas no son más lentas que el código que prueban.
- **Context Preservation**: Utiliza compact_context (prioridad: alta) para mantener el enfoque de las pruebas durante conversaciones largas, preservando los objetivos de cobertura y la detección antipatrón a través de la compactación del contexto.

## Configuración de contexto compacto

El agente de pruebas utiliza **high priority** compact_context para garantizar que la cobertura y la calidad de las pruebas permanezcan enfocadas:

```yaml
compact_context:
  priority: high
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/testing/expertise.yaml"
    - "AAA PATTERN: All tests follow Arrange-Act-Assert structure"
    - "COVERAGE MINIMUM: 70% coverage required, 80%+ for critical paths"
    - "NO FLAKY TESTS: Eliminate randomness, timing issues, intermittent failures"
    - "TEST ISOLATION: Unit tests mock, integration tests use real dependencies"
    - "VERIFY PASSES: Run /agileflow:verify before marking in-review"
  state_fields:
    - current_story
    - coverage_percentage
    - critical_paths_count
    - flaky_tests_found
    - test_status_baseline
```

Esto garantiza que las reglas de prueba críticas (patrón AAA, mínimos de cobertura, prácticas de prueba anti-incorrectas) y el estado actual (brechas de cobertura, recuentos de pruebas inestables, estado de las pruebas de ruta crítica) permanezcan enfocados a través de la compactación del contexto.

## Herramientas disponibles

- Leer, escribir, editar (operaciones de archivos)
- Bash (ejecutar comandos de prueba)
- Glob (buscar archivos de prueba)
- Grep (código de prueba de búsqueda)

## Integración del arnés de sesión

El agente de pruebas se integra con el arnés de sesión para garantizar la calidad:

```text
Pre-Implementation:
├── Check environment.json exists
├── Verify test_status: "passing" baseline
└── Run /agileflow:session:resume

During Implementation:
├── Run tests incrementally
├── Fix failures immediately
└── Update test_status in real-time

Post-Implementation:
├── Run /agileflow:verify US-XXXX (must pass)
├── Verify test_status: "passing"
└── Mark story "in-review" ONLY if tests pass
```

## Categorías de prueba y objetivos

| Category | Percentage | Speed | Scope |
|----------|-----------|-------|-------|
| Unit Tests | 80% | under 1ms each | Single function, mocked dependencies |
| Integration Tests | 15% | Slower | Multiple components, real dependencies |
| E2E Tests | 5% | Very slow | Full user workflows |
| Contract Tests | 0-5% | Fast | API schema validation |

## Lista de control de calidad

Antes de marcar una historia como completa:

- [] Cobertura de prueba ≥70% (rutas críticas 100%)
- [] Todos los escenarios de camino feliz probados
- [] Todos los escenarios de error probados
- [] Casos extremos identificados y probados
- [] Sin pruebas inestables (ejecutar 10 veces, todas pasan)
- [] Sin pruebas lentas (cada prueba en menos de 1 segundo, conjunto completo en menos de 5 minutos)
- [] Prueba el comportamiento de la prueba, no la implementación
- [] Los nombres de las pruebas describen claramente lo que se prueba.
- [ ] Dispositivos de prueba reutilizables y bien documentados
- [ ] Informe de cobertura generado y revisado
- [] test_status: "aprobado" verificado

## Patrones de prueba comunes

**AAA Pattern (Arrange-Act-Assert)**:
```javascript
describe('validateEmail', () => {
  it('rejects invalid formats', () => {
    // Arrange
    const email = 'invalid@';

    // Act
    const result = validateEmail(email);

    // Assert
    expect(result).toBe(false);
  });
});
```

**Test Fixtures (Reusable test data)**:
```javascript
const validUser = { id: 1, email: 'user@example.com', name: 'John' };
const invalidUser = { id: 2, email: 'invalid@', name: 'Jane' };
```

**Parameterized Tests**:
```javascript
test.each([
  ['valid@example.com', true],
  ['invalid@', false],
  ['no-at-sign.com', false],
])('validates email %s', (email, expected) => {
  expect(validateEmail(email)).toBe(expected);
});
```

## Antipatrones para eliminar

| Anti-Pattern | Problem | Fix |
|--------------|---------|-----|
| Flaky tests | Intermittent failures, unpredictable | Remove randomness, add waits for conditions |
| Slow tests | >1 second each | Use mocks, parallelize, optimize queries |
| Brittle tests | Break on refactoring | Test behavior, not implementation details |
| Over-mocking | Unrealistic isolation | Balance unit and integration tests |

## Agentes Relacionados

- [`qa`](/agents/qa) - Estrategia de prueba y preparación para el lanzamiento (alcance diferente)
- [`ci`](/agents/ci) - Infraestructura de prueba y configuración de canalización de CI
- [`api`](/agents/api) - Pruebas API y validación de contratos.
- [`ui`](/agents/ui) - Pruebas de componentes y pruebas de interacción con el usuario.
- [`base de datos`](/agents/database) - Pruebas de capa de datos y optimización de consultas.

## Coordinación

El Agente de Pruebas coordina con otros agentes:

- **AG-API**: Asegúrese de que se prueben los casos de error de API
- **AG-UI**: Coordinar las pruebas de componentes y E2E.
- **AG-DATABASE**: Pruebe la capa de datos y el rendimiento de las consultas.
- **AG-CI**: Solicitar infraestructura de prueba (ejecución paralela, informes de cobertura)
- **AG-QA**: Alinear las métricas de calidad y los objetivos de cobertura de pruebas

## Comandos de barra diagonal

- `/agileflow:verify US-XXXX` - Ejecutar pruebas para una historia específica.
- `/agileflow:research:ask TOPIC=...` - Patrones de prueba de investigación
- `/agileflow:ai-code-review` - Revisar el código de prueba para antipatrones.
- `/agileflow:adr-new` - Documentar las decisiones de prueba.
- `/agileflow:status STORY=... STATUS=...` - Actualizar el estado de la historia
