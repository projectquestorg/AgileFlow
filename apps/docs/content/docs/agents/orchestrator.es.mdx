---
title: orquestador
description: Coordinador multiexperto que despliega expertos en el dominio en paralelo y sintetiza los resultados. SÓLO tiene herramientas de Tarea/Salida de Tarea; debe delegar todo el trabajo.
---
# Agente orquestador

El Agente Orchestrator es un coordinador multidominio que analiza solicitudes complejas, identifica dominios expertos relevantes e implementa agentes especializados en paralelo para ejecutar el trabajo. Luego sintetiza todos los resultados en una respuesta unificada.

## Capacidades

- Analiza solicitudes complejas para identificar múltiples dominios (API, UI, base de datos, pruebas, seguridad, CI, etc.)
- Implementa de 2 a 8 expertos en el dominio en paralelo para ejecución simultánea
- Coordina la ejecución del trabajo utilizando únicamente las herramientas Task y TaskOutput.
- Sintetiza los resultados de los expertos en respuestas unificadas y conscientes de los conflictos.
- Maneja tanto el trabajo independiente paralelo como los patrones de trabajo dependientes secuenciales.
- Gestiona puntos de integración entre múltiples implementaciones especializadas.

## Cuándo utilizar

Utilice este agente cuando:

- **Funciones de pila completa** - "Agregar perfil de usuario con API, esquema de base de datos, componente de interfaz de usuario y pruebas" requiere coordinación entre múltiples dominios
- **Solicitudes complejas de múltiples dominios** - Solicitudes únicas que abarcan API, UI y base de datosase y cambios de implementación
- **Coordinación de trabajos paralelos** - Múltiples trabajos independientes que deben ejecutarse simultáneamente
- **Trabajo dependiente secuencial** - Trabajo que debe completarse en orden (esquema de base de datos → API → UI → pruebas)
- **Coordinación de integración** - Garantizar que múltiples implementaciones funcionen juntas correctamente
- **Refactorización grande**: cambios en la base de datos que se propagan a la API, luego a la interfaz de usuario y luego a las pruebas.
- **Función con infraestructura** - Implementación de funciones más configuración de canalización de CI/CD

## Cómo funciona

El agente sigue un flujo de trabajo estructurado:

```text
USER REQUEST
     ↓
┌─────────────────────────────────────┐
│ 1. ANALYZE DOMAINS                  │ → Identify API, UI, Database, etc.
│ 2. PLAN EXECUTION                   │ → Parallel vs sequential dependencies
│ 3. DEPLOY EXPERTS                   │ → Spawn via Task in parallel
│ 4. COLLECT RESULTS                  │ → TaskOutput with block: true
│ 5. SYNTHESIZE RESPONSE              │ → Unified output with integration points
└─────────────────────────────────────┘
     ↓
COORDINATED MULTI-DOMAIN IMPLEMENTATION
```

### Paso 1: Analizar la solicitud

El agente analiza la solicitud de palabras clave del dominio e identifica qué expertos se necesitan:

| Solicitar | Dominios | Expertos |
|---------|---------|---------|
| "Agregar perfil de usuario con API y UI" | API + interfaz de usuario | 2 expertos (paralelos) |
| "Agregar inicio de sesión con pruebas" | API + Seguridad + Pruebas | 3 expertos (secuenciales) |
| "Refactorizar base de datos y actualizar API" | Base de datos + API | 2 expertos (secuenciales) |
|"Función de pila completa con CI" | Base de datos + API + UI + Pruebas + CI | 5 expertos (mixtos) |

### Paso 2: Ejecución del plan

El agente determina la estrategia de ejecución en función de las dependencias:

**Ejecución Paralela** (trabajo independiente):
```
API + UI (both can work simultaneously)
Testing + Documentation (can test while docs written)
Security audit + Performance analysis (independent reviews)
```

**Ejecución Secuencial** (trabajo dependiente):
```
Database schema → API implementation → UI component
(Each depends on previous)
```

**Ejecución mixta** (algunas paralelas, otras secuenciales):
```
Parallel: Database schema + API tests + Documentation
Then Sequential: API implementation → UI component
```

### Paso 3: Implementar expertos

Todos los expertos paralelos se implementan simultáneamente en un único mensaje mediante ejecución en segundo plano:

```text
Task(
  description: "Implement user profile API",
  prompt: "Create /api/profile endpoint with GET/PUT methods...",
  subagent_type: "agileflow-api",
  run_in_background: true
)

Task(
  description: "Implement profile UI component",
  prompt: "Create ProfilePage component with form...",
  subagent_type: "agileflow-ui",
  run_in_background: true
)
```

### Paso 4: recopilar resultados

Utiliza `TaskOutput` con `block: true` para esperar todas las respuestas de los expertos:

```text
TaskOutput(task_id: "<api_task_id>", block: true)
TaskOutput(task_id: "<ui_task_id>", block: true)
```

### Paso 5: Sintetizar

Combina todos los resultados de los expertos en una respuesta unificada que destaca:
- Lo que completó cada experto
- Puntos de integración entre implementaciones.
- Conflictos o problemas de compatibilidad
- Próximos pasos recomendados

## Expertos en dominios

El orquestador coordina con estos especialistas de dominio:

| Dominio | Experto | Cuándo implementar |
|--------|--------|---|
| **Base de datos** | `agileflow-database` | Diseño de esquemas, migraciones, consultas, indexación |
| **API** | `agileflow-api` | Puntos finales, rutas, lógica de negocios, validación |
| **UI** | `agileflow-ui` | Componentes, estilo, formas, accesibilidad |
| **Pruebas** | `agileflow-testing` | Pruebas unitarias, pruebas de integración, cobertura |
| **Seguridad** | `agileflow-security` | Autenticación, autorización, vulnerabilidades |
| **CI/CD** | `agileflow-ci` | Canalizaciones, flujos de trabajo, linting, verificación de tipos |
| **DevOps** | `agileflow-devops` | Despliegue, infraestructura, contenerización |
| **Documentación** | `agileflow-documentation` | Documentos API, guías de usuario, archivos README |
| **Rendimiento** | `agileflow-performance` | Optimización, elaboración de perfiles, evaluación comparativa |

## Patrones paralelos

### Función de pila completa

Implemente la base de datos y la API en paralelo (independientes), luego la interfaz de usuario y las pruebas en paralelo (después de que exista la API):

```
Phase 1 (Parallel):
  - agileflow-database (schema)
  - agileflow-api (endpoint)

Phase 2 (Parallel, after Phase 1):
  - agileflow-ui (component)
  - agileflow-testing (tests)
```

### Revisión/Análisis de Código

Implemente varios expertos para analizar el mismo código simultáneamenteinstantáneamente:

```
Parallel (same code, different perspectives):
  - agileflow-security (vulnerability analysis)
  - agileflow-performance (optimization analysis)
  - agileflow-testing (test coverage analysis)

Then:
  - Synthesize findings and prioritize issues
```

### Comparación mejor de N

Implemente la misma tarea para varios expertos con diferentes enfoques y compare:

```
Parallel (same task, different approaches):
  - Expert A (approach 1: REST API)
  - Expert B (approach 2: GraphQL API)
  - Expert C (approach 3: RPC API)

Then:
  - Compare implementations
  - Select best approach for codebase
  - Provide reasoning
```

## Restricciones críticas

Orchestrator tiene **SÓLO herramientas Task y TaskOutput**:

### Puede hacer:
- Generar expertos a través de tareas
- Recopilar resultados a través de TaskOutput
- Analizar solicitudes y planificar la ejecución.
- Sintetizar y coordinar respuestas.

### No puedo hacer:
- Leer archivos (sin herramienta de lectura)
- Escribir archivos (sin herramienta de escritura)
- Editar archivos (sin herramienta de edición)
- Ejecutar comandos (sin herramienta Bash)
- Código de búsqueda (sin herramientas Glob/Grep)

**DEBE delegar TODO el trabajo a expertos en el dominio.**

## Resolución de conflictos

Cuando los expertos producen resultados contradictorios:

1. **Tenga en cuenta el conflicto** en la sección de síntesis
2. **Presentar ambas opciones** con compensaciones
3. **Recomiende uno** según:
   - Coherencia con los patrones existentes.
   - Simplicidad y mantenibilidad
   - Implicaciones de rendimiento
4. **Solicite una decisión** si la recomendación no está clara

Conflicto de ejemplo:
```
### Conflicts / Review Needed

API Expert recommends: PUT /api/profile for updates
UI Expert expects: PATCH /api/profile for updates

Recommendation: Use PUT (simpler, consistent with REST conventions)
UI can send full profile object without issues.
```

## Ejemplo: Completo-Función de perfil de usuario de pila

**Solicitud**: "Agregar una función de perfil de usuario completa con API, base de datos, componente React y pruebas"

**Respuesta del orquestador**:

```
Analyzing multi-domain request...

Domains identified:
- Database (schema for user profiles)
- API (REST endpoints)
- UI (React component)
- Testing (unit and integration tests)

Execution plan:
- Phase 1 (Parallel): Database + API (API needs schema)
- Phase 2 (Parallel): UI + Testing (both use API)

[Spawning Phase 1 experts...]
- Database Expert → User profiles schema
- API Expert → /api/profile endpoints

[Collecting Phase 1 results...]

[Spawning Phase 2 experts...]
- UI Expert → ProfilePage component
- Testing Expert → Comprehensive test suite

[Collecting Phase 2 results...]

## Orchestration Complete

### Database Expert ✅
- Created `profiles` table with columns: id, user_id, bio, avatar_url, etc.
- Added indexes on user_id and created_at
- Files: `migrations/001_create_profiles.sql`

### API Expert ✅
- GET /api/profile - Fetch user profile
- PUT /api/profile - Update profile
- DELETE /api/profile - Remove profile
- Files: `src/routes/profile.ts`, `src/controllers/ProfileController.ts`

### UI Expert ✅
- ProfilePage component with form
- Form validation and error handling
- Styling with Tailwind CSS
- Files: `src/components/ProfilePage.tsx`, `src/hooks/useProfile.ts`

### Testing Expert ✅
- Unit tests for ProfilePage component
- Integration tests for API endpoints
- Database query tests
- 87% coverage
- Files: `src/routes/__tests__/profile.test.ts`, `src/components/__tests__/ProfilePage.test.tsx`

### Integration Points
- UI imports API functions from `src/api/profile.ts`
- UI calls GET /api/profile on component mount
- Form submission sends PUT to /api/profile
- Database schema matches API data model

### Next Steps
1. Wire ProfilePage into router in App.tsx
2. Add authentication middleware to API routes
3. Add validation on API layer
4. Deploy to staging for E2E testing

Ready to proceed with integration?
```

## Comportamientos clave

- **SIEMPRE analiza múltiples dominios** - Nunca asume el trabajo de un solo dominio
- **SIEMPRE planifica la estrategia de ejecución** - Paralelo vs secuencial basado en dependencias
- **SIEMPRE implementa expertos en paralelo** - Nunca de forma secuencial a menos que las dependencias lo requieran
- **SIEMPRE implementa TODOS los expertos en un ÚNICO mensaje** - Llamadas de tareas por lotes juntas
- **SIEMPRE usa TaskOutput con bloque: verdadero** - Espera todos los resultados antes de la síntesis
- **NUNCA da una respuesta final sin sintetizar TODAS las respuestas de los expertos** - Todas las perspectivas deben integrarse
- **SIEMPRE toma nota de los puntos de integración** - Destaca cómo se conectan las implementaciones

## Herramientas disponibles

Este agente tiene acceso **SÓLO**:
- **Tarea** - Implementar agentes expertos en el dominio en paralelo
- **TaskOutput**: recopile resultados de expertos y espere a que se completen

NO tiene accesoss a:
- Leer, escribir, editar (no se puede modificar el código en sí)
- Bash (no se pueden ejecutar comandos)
- Glob, Grep (no se puede buscar el código)

Esta restricción garantiza que el orquestador se centre exclusivamente en la coordinación, no en la implementación.

## Configuración del modelo

- **Modelo**: Claude Sonnet 3.5 (optimizado para coordinación)
- **Razonamiento**: Planificación, ejecución paralela, lógica de síntesis.

## Agentes relacionados

**Especialistas en dominios** (implementados por Orchestrator):
- [`database`](/agents/database) - Experto en consultas y esquemas de bases de datos
- [`api`](/agents/api) - Experto en terminales de API REST
- [`ui`](/agents/ui) - Experto en componentes frontend
- [`testing`](/agents/testing) - Experto en estrategia y cobertura de pruebas
- [`security`](/agents/security) - Experto en seguridad y autenticación
- [`performance`](/agents/performance) - Experto en optimización del rendimiento
- [`ci`](/agents/ci) - Experto en canalización de CI/CD
- [`devops`](/agents/devops) - Infraestructura y deexperto en empleo
- [`documentation`](/agents/documentation) - Experto en documentación técnica

**Otros metaagentes**:
- [`multi-expert`](/agents/multi-expert) - Analiza el mismo problema con 3-5 expertos (caso de uso diferente: análisis versus implementación)
- [`mentor`](/agents/mentor) - Guía de implementación de un extremo a otro

## Cuándo NO usarlo

- **Tareas sencillas de un solo dominio** - Utilice en su lugar el experto en dominio directo (más rápido, más sencillo)
- **Solo análisis** - Utilice el agente Multi-Expert para análisis de alta confianza
- **Preguntas sencillas** - Utilice agentes especializados directamente
- **Tareas que requieren coordinación manual** - Orchestrator trabaja solo con agentes