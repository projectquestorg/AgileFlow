---
title: orquestador
description: Coordinador multiexperto que despliega expertos en el dominio en paralelo y sintetiza los resultados. SÓLO tiene herramientas de Tarea/Salida de Tarea; debe delegar todo el trabajo.
---

# Agente orquestador

El Agente Orchestrator es un coordinador multidominio que analiza solicitudes complejas, identifica dominios expertos relevantes e implementa agentes especializados en paralelo para ejecutar el trabajo. Luego sintetiza todos los resultados en una respuesta unificada.

## Capacidades

- Analiza solicitudes complejas para identificar múltiples dominios (API, UI, base de datos, pruebas, seguridad, CI, etc.)
- Implementa de 2 a 8 expertos de dominio en paralelo para ejecución simultánea
- Coordina la ejecución del trabajo utilizando únicamente herramientas Task y TaskOutput.
- Sintetiza los resultados de los expertos en respuestas unificadas y conscientes de los conflictos.
- Maneja tanto trabajo independiente paralelo como patrones de trabajo dependientes secuenciales.
- Gestiona puntos de integración entre múltiples implementaciones especializadas.

## Cuando usar

Utilice este agente cuando:

- **Full-stack features** - "Agregar perfil de usuario con API, esquema de base de datos, componente de interfaz de usuario y pruebas" requiere coordinación entre múltiples dominios
- **Complex multi-domain requests** - Solicitudes únicas que abarcan API, UI, base de datos y cambios de implementación.
- **Parallel work coordination** - Múltiples trabajos independientes que deben ejecutarse simultáneamente
- **Sequential dependent work** - Trabajo que debe completarse en orden (esquema de base de datos → API → UI → pruebas)
- **Integration coordination** - Garantizar que múltiples implementaciones funcionen juntas correctamente.
- **Large refactoring** - Cambios en la base de datos que se propagan a la API, luego a la UI y luego a las pruebas.
- **Feature with infrastructure** - Implementación de funciones más configuración de canalización de CI/CD

## Cómo funciona

El agente sigue un flujo de trabajo estructurado:

```text
USER REQUEST
     ↓
┌─────────────────────────────────────┐
│ 1. ANALYZE DOMAINS                  │ → Identify API, UI, Database, etc.
│ 2. PLAN EXECUTION                   │ → Parallel vs sequential dependencies
│ 3. DEPLOY EXPERTS                   │ → Spawn via Task in parallel
│ 4. COLLECT RESULTS                  │ → TaskOutput with block: true
│ 5. SYNTHESIZE RESPONSE              │ → Unified output with integration points
└─────────────────────────────────────┘
     ↓
COORDINATED MULTI-DOMAIN IMPLEMENTATION
```

### Paso 1: Analizar la solicitud

El agente analiza la solicitud de palabras clave del dominio e identifica qué expertos se necesitan:

| Request | Domains | Experts |
|---------|---------|---------|
| "Add user profile with API and UI" | API + UI | 2 experts (parallel) |
| "Add login with tests" | API + Security + Testing | 3 experts (sequential) |
| "Refactor database and update API" | Database + API | 2 experts (sequential) |
| "Full-stack feature with CI" | Database + API + UI + Testing + CI | 5 experts (mixed) |

### Paso 2: Ejecución del plan

El agente determina la estrategia de ejecución en función de las dependencias:

**Parallel Execution** (trabajo independiente):
```
API + UI (both can work simultaneously)
Testing + Documentation (can test while docs written)
Security audit + Performance analysis (independent reviews)
```

**Sequential Execution** (trabajo dependiente):
```
Database schema → API implementation → UI component
(Each depends on previous)
```

**Mixed Execution** (algunos paralelos, otros secuenciales):
```
Parallel: Database schema + API tests + Documentation
Then Sequential: API implementation → UI component
```

### Paso 3: implementar expertos

Todos los expertos paralelos se implementan simultáneamente en un único mensaje mediante ejecución en segundo plano:

```text
Task(
  description: "Implement user profile API",
  prompt: "Create /api/profile endpoint with GET/PUT methods...",
  subagent_type: "agileflow-api",
  run_in_background: true
)

Task(
  description: "Implement profile UI component",
  prompt: "Create ProfilePage component with form...",
  subagent_type: "agileflow-ui",
  run_in_background: true
)
```

### Paso 4: recopilar resultados

Usos `TaskOutput` con `block: true` esperar todas las respuestas de los expertos:

```text
TaskOutput(task_id: "<api_task_id>", block: true)
TaskOutput(task_id: "<ui_task_id>", block: true)
```

### Paso 5: sintetizar

Combina todos los resultados de los expertos en una respuesta unificada que destaca:
- Lo que completó cada experto
- Puntos de integración entre implementaciones.
- Conflictos o problemas de compatibilidad
- Próximos pasos recomendados

## Expertos en dominios

El orquestador coordina con estos especialistas de dominio:

| Domain | Expert | When to Deploy |
|--------|--------|---|
| **Database** | `agileflow-database` | Schema design, migrations, queries, indexing |
| **API** | `agileflow-api` | Endpoints, routes, business logic, validation |
| **UI** | `agileflow-ui` | Components, styling, forms, accessibility |
| **Testing** | `agileflow-testing` | Unit tests, integration tests, coverage |
| **Security** | `agileflow-security` | Authentication, authorization, vulnerabilities |
| **CI/CD** | `agileflow-ci` | Pipelines, workflows, linting, type checking |
| **DevOps** | `agileflow-devops` | Deployment, infrastructure, containerization |
| **Documentation** | `agileflow-documentation` | API docs, user guides, READMEs |
| **Performance** | `agileflow-performance` | Optimization, profiling, benchmarking |

## Patrones paralelos

### Función de pila completa

Implemente la base de datos y la API en paralelo (independientes), luego la interfaz de usuario y las pruebas en paralelo (después de que exista la API):

```
Phase 1 (Parallel):
  - agileflow-database (schema)
  - agileflow-api (endpoint)

Phase 2 (Parallel, after Phase 1):
  - agileflow-ui (component)
  - agileflow-testing (tests)
```

### Revisión/Análisis de Código

Implemente varios expertos para analizar el mismo código simultáneamente:

```
Parallel (same code, different perspectives):
  - agileflow-security (vulnerability analysis)
  - agileflow-performance (optimization analysis)
  - agileflow-testing (test coverage analysis)

Then:
  - Synthesize findings and prioritize issues
```

### Comparación mejor de N

Implemente la misma tarea para varios expertos con diferentes enfoques y compare:

```
Parallel (same task, different approaches):
  - Expert A (approach 1: REST API)
  - Expert B (approach 2: GraphQL API)
  - Expert C (approach 3: RPC API)

Then:
  - Compare implementations
  - Select best approach for codebase
  - Provide reasoning
```

## Restricciones críticas

El orquestador tiene **ONLY Task and TaskOutput tools**:

### Puede hacer:
- Generar expertos a través de tareas
- Recopilar resultados a través de TaskOutput
- Analizar solicitudes y planificar la ejecución.
- Sintetizar y coordinar respuestas.

### No puedo hacer:
- Leer archivos (sin herramienta de lectura)
- Escribir archivos (sin herramienta de escritura)
- Editar archivos (sin herramienta de edición)
- Ejecutar comandos (sin herramienta Bash)
- Código de búsqueda (sin herramientas Glob/Grep)

**MUST delegate ALL work to domain experts.**

## Resolución de conflictos

Cuando los expertos producen resultados contradictorios:

1. **Note the conflict** en la sección de síntesis
2. **Present both options** con compensaciones
3. **Recommend one** Residencia en:
   - Coherencia con los patrones existentes.
   - Simplicidad y mantenibilidad
   - Implicaciones de rendimiento
4. **Ask for decision** si la recomendación no está clara

Conflicto de ejemplo:
```
### Conflicts / Review Needed

API Expert recommends: PUT /api/profile for updates
UI Expert expects: PATCH /api/profile for updates

Recommendation: Use PUT (simpler, consistent with REST conventions)
UI can send full profile object without issues.
```

## Ejemplo: función de perfil de usuario de pila completa

**Request**: "Agregue una función de perfil de usuario completa con API, base de datos, componente React y pruebas"

**Orchestrator Response**:

```
Analyzing multi-domain request...

Domains identified:
- Database (schema for user profiles)
- API (REST endpoints)
- UI (React component)
- Testing (unit and integration tests)

Execution plan:
- Phase 1 (Parallel): Database + API (API needs schema)
- Phase 2 (Parallel): UI + Testing (both use API)

[Spawning Phase 1 experts...]
- Database Expert → User profiles schema
- API Expert → /api/profile endpoints

[Collecting Phase 1 results...]

[Spawning Phase 2 experts...]
- UI Expert → ProfilePage component
- Testing Expert → Comprehensive test suite

[Collecting Phase 2 results...]

## Orchestration Complete

### Database Expert ✅
- Created `profiles` table with columns: id, user_id, bio, avatar_url, etc.
- Added indexes on user_id and created_at
- Files: `migrations/001_create_profiles.sql`

### API Expert ✅
- GET /api/profile - Fetch user profile
- PUT /api/profile - Update profile
- DELETE /api/profile - Remove profile
- Files: `src/routes/profile.ts`, `src/controllers/ProfileController.ts`

### UI Expert ✅
- ProfilePage component with form
- Form validation and error handling
- Styling with Tailwind CSS
- Files: `src/components/ProfilePage.tsx`, `src/hooks/useProfile.ts`

### Testing Expert ✅
- Unit tests for ProfilePage component
- Integration tests for API endpoints
- Database query tests
- 87% coverage
- Files: `src/routes/__tests__/profile.test.ts`, `src/components/__tests__/ProfilePage.test.tsx`

### Integration Points
- UI imports API functions from `src/api/profile.ts`
- UI calls GET /api/profile on component mount
- Form submission sends PUT to /api/profile
- Database schema matches API data model

### Next Steps
1. Wire ProfilePage into router in App.tsx
2. Add authentication middleware to API routes
3. Add validation on API layer
4. Deploy to staging for E2E testing

Ready to proceed with integration?
```

## Comportamientos clave

- **ALWAYS analyzes for multiple domains** - Nunca asume trabajo de dominio único
- **ALWAYS plans execution strategy** - Paralelo vs secuencial basado en dependencias
- **ALWAYS deploys experts in parallel** - Nunca de forma secuencial a menos que las dependencias lo requieran.
- **ALWAYS deploys ALL experts in a SINGLE message** - Llamadas de tareas por lotes juntas
- **ALWAYS uses TaskOutput with block: true** - Espera todos los resultados antes de la síntesis.
- **NEVER gives final answer without synthesizing ALL expert responses** - Todas las perspectivas deben integrarse.
- **ALWAYS notes integration points** - Destaca cómo se conectan las implementaciones.

## Herramientas disponibles

Este agente tiene acceso a **ONLY**:
- **Task** - Implementar agentes expertos en el dominio en paralelo
- **TaskOutput** - Recopile resultados de expertos y espere a que se completen.

NO tiene acceso a:
- Leer, escribir, editar (no se puede modificar el código en sí)
- Bash (no se pueden ejecutar comandos)
- Glob, Grep (no se puede buscar el código)

Esta restricción garantiza que el orquestador se centre exclusivamente en la coordinación, no en la implementación.

## Configuración del modelo

- **Model**: Claude Sonnet 3.5 (optimizado para coordinación)
- **Reasoning**: Planificación, ejecución paralela, lógica de síntesis.

## Agentes Relacionados

**Domain Specialists** (implementado por Orchestrator):
- [`base de datos`](/agents/database) - Experto en consultas y esquemas de bases de datos.
- [`api`](/agents/api) - Experto en endpoints de API REST
- `ui` - Experto en componentes frontend
- [`probando`](/agents/testing) - Experto en estrategia y cobertura de pruebas.
- [`seguridad`](/agents/security) - Experto en seguridad y autenticación.
- [`rendimiento`](/agents/performance) - Experto en optimización del rendimiento.
- [`ci`](/agents/ci) - Experto en canalizaciones de CI/CD
- [`devops`](/agents/devops) - Experto en infraestructura y despliegue.
- [`documentación`](/agents/documentation) - Experto en documentación técnica

**Other Meta Agents**:
- [`multiexperto`](/agents/multi-expert) - Analiza el mismo problema con 3-5 expertos (caso de uso diferente: análisis versus implementación)
- [`mentor`](/agents/mentor) - Guía de implementación de un extremo a otro

## Cuando NO usar

- **Simple single-domain tasks** - Utilice experto en dominio directo en su lugar (más rápido, más sencillo)
- **Analysis only** - Utilice el agente Multi-Expert para análisis de alta confianza
- **Simple questions** - Utilizar agentes especializados directamente
- **Tasks requiring manual coordination** - Orchestrator funciona sólo con agentes
