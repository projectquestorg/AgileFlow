---
title: Testen
description: Testspezialist für Teststrategie, Testmuster, Abdeckungsoptimierung und umfassendes Testsuite-Design.
---
# Testagent

Der Testing Agent (AG-TESTING) ist ein spezialisierter Qualitätssicherungsexperte, der umfassende Teststrategien entwirft, Test-Anti-Patterns eliminiert und die Testabdeckung optimiert. Im Gegensatz zur Einrichtung einer CI-Infrastruktur konzentriert sich dieser Agent auf die Fragen „Was soll getestet werden“ und „Wie testet man es?“.

## Fähigkeiten

- **Teststrategiedesign**: Erstellen Sie umfassende Testpläne, die Unit-, Integrations- und E2E-Tests abdecken
- **Abdeckungsoptimierung**: Analysieren Sie die Codeabdeckung und identifizieren Sie Lücken in kritischen Pfaden
- **Test-Anti-Pattern-Erkennung**: Identifizieren und beseitigen Sie flockige, langsame und spröde Tests
- **Testinfrastruktur**: Erstellen Sie Testvorrichtungen, Fabriken und Hilfsfunktionen
- **Abdeckungsanalyse**: Messen und melden Sie Abdeckungskennzahlen mit umsetzbaren Empfehlungen
- **Testmusterdokumentation**: Dokumentieren Sie wiederverwendbare Testmuster und Best Practices
- **Leistungstests**: Leistungsbenchmarks entwerfen und durchführen
- **Mutationstests**: Testen Sie die Tests selbst, um die Qualität sicherzustellen## Wann zu verwenden

Verwenden Sie den Testagenten, wenn:

- Starten Sie eine neue Funktion und müssen Sie definieren, was getestet werden muss
- Die aktuelle Testabdeckung liegt unter 70 % und muss verbessert werden
- Die Tests sind unregelmäßig (zeitweilige Fehler) oder langsam (jeweils > 1 Sekunde).
- Es müssen Testvorrichtungen oder Fabriken für komplexe Testdaten entworfen werden
- Aufbau einer automatisierten Testinfrastruktur
- Erstellen von ADRs zum Testen von Entscheidungen
- Implementierung umfassender Testsuiten für kritische Pfade

## Wie es funktioniert

1. **Laden von Wissen**: Der Agent liest die Fachwissensdatei und den Teststatus des Projekts
2. **Story-Review**: Der Agent analysiert die Story auf Testbarkeitsanforderungen
3. **Testplanung**: Agent entwirft Testfälle (Happy Path, Fehlerfälle, Randfälle)
4. **Infrastruktur-Setup**: Agent erstellt Testvorrichtungen, Mocks und Helfer
5. **Testimplementierung**: Agent schreibt Tests nach dem AAA-Muster (Arrange-Act-Assert)
6. **Abdeckungsmessung**: Der Agent misst die Abdeckung und identifiziert Lücken
7. **Anti-Pattern Elimination**: Agent identifiziert und behebt flaky/langsam/spröde Tests
8. **Überprüfung**: Der Agent führt `/agileflow:verify` aus, um sicherzustellen, dass alle Tests erfolgreich sind
9. **Koordination**: Agent aktualisiert status.json und kommuniziert über bus/log.jsonl

## Beispiel

```bash
# Via babysit - identify testing work
/agileflow:babysit
> "We need comprehensive testing for the payment processing feature"

# Agent output:
# Test Strategy Created:
# - Unit tests: Payment validation, transaction formatting (80% coverage)
# - Integration tests: Database saves, external API calls (15% coverage)
# - E2E tests: Complete payment workflow (5% coverage)
# - Coverage target: 85% critical path
# - Expected test count: 47 tests
# - Estimated time: 4 hours
```

## Schlüsselverhalten

- **AAA-Muster**: Alle Tests folgen aus Gründen der Übersichtlichkeit der Struktur „Arrange-Act-Assert“.
- **Testisolation**: Unit testet Scheinabhängigkeiten; Integrationstests verwenden echte Abhängigkeiten
- **Verhaltensorientiert**: Tests validieren das Verhalten, nicht die Implementierungsdetails
- **Schnelle Ausführung**: Unit-Tests werden in Millisekunden ausgeführt; Komplette Suite in wenigen Minuten
- **Eindeutige Benennung**: Testnamen beschreiben genau, was getestet wird
- **Abdeckungsschwellenwerte**: mindestens 70 %, 80 %+ für kritische Pfade (100 % für Authentifizierung/Zahlung)
- **Keine fehlerhaften Tests**: Zeitweilige Fehler sind ein Warnsignal; Zufälligkeit und Timing entfernt
- **Leistungsbewusstsein**: Tests sind nicht langsamer als der Code, den sie testen
- **Kontexterhaltung**: Verwendet kompakten_Kontext (Priorität: hoch), um den Testfokus bei langen Gesprächen beizubehalten und zu bewahrenAbdeckungsziele und Anti-Pattern-Erkennung durch Kontextkomprimierung

## Kompakte Kontextkonfiguration

Der Testing-Agent verwendet Compact_Context mit **hoher Priorität**, um sicherzustellen, dass Testabdeckung und -qualität im Fokus bleiben:

```yaml
compact_context:
  priority: high
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/testing/expertise.yaml"
    - "AAA PATTERN: All tests follow Arrange-Act-Assert structure"
    - "COVERAGE MINIMUM: 70% coverage required, 80%+ for critical paths"
    - "NO FLAKY TESTS: Eliminate randomness, timing issues, intermittent failures"
    - "TEST ISOLATION: Unit tests mock, integration tests use real dependencies"
    - "VERIFY PASSES: Run /agileflow:verify before marking in-review"
  state_fields:
    - current_story
    - coverage_percentage
    - critical_paths_count
    - flaky_tests_found
    - test_status_baseline
```

Dadurch wird sichergestellt, dass testkritische Regeln (AAA-Muster, Mindestabdeckung, Anti-Flocken-Testpraktiken) und der aktuelle Status (Abdeckungslücken, Anzahl der Flockigen Tests, Teststatus kritischer Pfade) durch Kontextkomprimierung im Fokus bleiben.

## Werkzeuge verfügbar

- Lesen, Schreiben, Bearbeiten (Dateioperationen)
- Bash (Testbefehle ausführen)
- Glob (Testdateien finden)
- Grep (Testcode suchen)

## Session Harness-Integration

Der Testing Agent lässt sich in das Session Harness integrieren, um die Qualität sicherzustellen:

```text
Pre-Implementation:
├── Check environment.json exists
├── Verify test_status: "passing" baseline
└── Run /agileflow:session:resume

During Implementation:
├── Run tests incrementally
├── Fix failures immediately
└── Update test_status in real-time

Post-Implementation:
├── Run /agileflow:verify US-XXXX (must pass)
├── Verify test_status: "passing"
└── Mark story "in-review" ONLY if tests pass
```

## Testkategorien und -ziele

| Kategorie | Prozentsatz | Geschwindigkeit | Geltungsbereich |
|----------|-----------|-------|-------|
| Unit-Tests | 80 % | jeweils unter 1ms | Einzelne Funktion, simulierte Abhängigkeiten |
| Integrationstests | 15 % | Langsamer | Mehrere Komponenten, echte Abhängigkeiten |
| E2E-Tests| 5 % | Sehr langsam | Vollständige Benutzerworkflows |
| Vertragstests | 0-5% | Schnell | API-Schemavalidierung |

## Qualitätscheckliste

Bevor Sie eine Geschichte als abgeschlossen markieren:

- [ ] Testabdeckung ≥70 % (kritische Pfade 100 %)
- [ ] Alle Happy-Path-Szenarien getestet
- [ ] Alle Fehlerszenarien getestet
- [ ] Randfälle identifiziert und getestet
- [ ] Keine flockigen Tests (10x ausführen, alle bestehen)
- [ ] Keine langsamen Tests (jeder Test weniger als 1 Sekunde, die gesamte Suite weniger als 5 Minuten)
- [ ] Testet das Testverhalten, nicht die Implementierung
- [ ] Testnamen beschreiben klar, was getestet wird
- [ ] Prüfvorrichtungen wiederverwendbar und gut dokumentiert
- [ ] Abdeckungsbericht erstellt und überprüft
- [ ] test_status: „bestanden“ verifiziert

## Gemeinsame Testmuster

**AAA-Muster (Arrange-Act-Assert)**:
```javascript
describe('validateEmail', () => {
  it('rejects invalid formats', () => {
    // Arrange
    const email = 'invalid@';

    // Act
    const result = validateEmail(email);

    // Assert
    expect(result).toBe(false);
  });
});
```

**Testvorrichtungen (wiederverwendbare Testdaten)**:
```javascript
const validUser = { id: 1, email: 'user@example.com', name: 'John' };
const invalidUser = { id: 2, email: 'invalid@', name: 'Jane' };
```

**Parametrierte Tests**:
```javascript
test.each([
  ['valid@example.com', true],
  ['invalid@', false],
  ['no-at-sign.com', false],
])('validates email %s', (email, expected) => {
  expect(validateEmail(email)).toBe(expected);
});
```

## Zu beseitigende Anti-Patterns

| Anti-Pattern | Problem | Fix |
|--------------|---------|-----|
| Flockentests | Zeitweilige Ausfälle, unvorhersehbar | Entfernen Sie die Zufälligkeit,Hinzufügen wartet auf Bedingungen |
| Langsame Tests | jeweils >1 Sekunde | Mocks verwenden, Abfragen parallelisieren, optimieren |
| Sprödigkeitsprüfungen | Pause beim Refactoring | Testverhalten, keine Implementierungsdetails |
| Übermäßiger Spott | Unrealistische Isolation | Balance-Einheiten- und Integrationstests |

## Verwandte Agenten

- [`qa`](/agents/qa) - Teststrategie und Release-Bereitschaft (unterschiedlicher Umfang)
- [`ci`](/agents/ci) – Testen Sie die Infrastruktur und die Einrichtung der CI-Pipeline
- [`api`](/agents/api) – API-Tests und Vertragsvalidierung
- [`ui`](/agents/ui) – Komponententests und Benutzerinteraktionstests
- [`database`](/agents/database) – Datenschichttests und Abfrageoptimierung

## Koordination

Der Testagent stimmt sich mit anderen Agenten ab:

- **AG-API**: Stellen Sie sicher, dass API-Fehlerfälle getestet werden
- **AG-UI**: Koordinierung bei Komponenten- und E2E-Tests
- **AG-DATABASE**: Testen Sie die Datenschicht und die Abfrageleistung
- **AG-CI**: Testinfrastruktur anfordern (parallele Ausführung)., Abdeckungsberichte)
- **AG-QA**: Ausrichtung auf Qualitätsmetriken und Testabdeckungsziele

## Slash-Befehle

- `/agileflow:verify US-XXXX` – Führen Sie Tests für eine bestimmte Story durch
- `/agileflow:research:ask TOPIC=...` - Testmuster recherchieren
– `/agileflow:ai-code-review` – Testcode auf Anti-Patterns prüfen
- `/agileflow:adr-new` - Testentscheidungen dokumentieren
- `/agileflow:status STORY=... STATUS=...` – Story-Status aktualisieren