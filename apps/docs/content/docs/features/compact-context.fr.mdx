---
title: Préservation du contexte compact
description: Comment les agents AgileFlow préservent les connaissances critiques lors du compactage automatique du contexte
---
# Préservation du contexte compact

Les agents AgileFlow utilisent la configuration **compact_context** pour préserver les connaissances et l'état critiques lorsque Claude Code compacte automatiquement le contexte de conversation. Cette fonctionnalité garantit que les agents restent concentrés, continuent de suivre les règles essentielles et suivent l'état actuel même pendant des conversations prolongées qui déclenchent une compression de contexte.

## Le problème : perte de contexte lors du compactage

Lorsque les conversations s'allongent, Claude Code compacte automatiquement le contexte pour rester dans les limites des jetons. Ce compactage peut provoquer :

- **Règles perdues** : les agents oublient les règles comportementales critiques (par exemple, "Charger d'abord l'expertise", "Vérifier la réussite des tests avant la révision")
- **État perdu** : les agents perdent la trace de leur travail en cours (sur quelle histoire ils se trouvent, ce qui les bloque, ce qui est fait)
- **Priorités perdues** : les agents oublient quelles tâches sont urgentes (par exemple, débloquer des histoires AG-UI)
- **Délai de recentrage** : les agents gaspillent des jetons en relisant leur expertise et leur contexte après le compactage.

C'est particulièrement problématiquec pour :
- **Fonctionnalités de longue durée** : travail de mise en œuvre sur plusieurs jours avec des dizaines d'échanges
- **Agents dépendants** : interface utilisateur en attente sur les points de terminaison de l'API, tous deux nécessitant une attention soutenue
- **Coordination critique** : Mentor orchestrant plusieurs agents simultanément

## La solution : un contexte compact

Chaque agent définit une configuration `compact_context` avec trois composants :

### 1. Niveau de priorité

Détermine avec quelle agressivité le contexte de l'agent est préservé pendant le compactage :

```yaml
compact_context:
  priority: critical  # one of: critical, high, medium, low
```

**Niveaux de priorité** :
- `critical` (2 agents) : Toujours conservé même en compactage agressif
  - Mentor, Agent API
  - Gérer l'orchestration et la mise en œuvre du noyau
- `high` (8 agents) : Préservé dans la plupart des compactages
  - UI, Base de données, CI, DevOps, Tests, Sécurité, Documentation, Performance
  - Exécuter un travail de longue durée avec une concentration soutenue
- `medium` (15 agents) : Préservé lorsque cela est possible
  - Agents les plus spécialisés (analytics, intégrations, mobile, etc.)
  - Gérer les domaines spécifiquesc tâches
- `low` (2 agents) : premier à être supprimé
  - Agents-conseils, rarement utilisés (epic-planner, orchestrateur)
  - Uniquement inclus si la chambre le permet

### 2. Conserver les règles

Règles comportementales fondamentales à ne jamais perdre :

```yaml
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
  - "VERIFY TEST BASELINE: Check test_status before starting"
  - "PRIORITIZE AG-UI BLOCKERS: Unblock UI stories waiting on API endpoints"
  - "DIFF-FIRST APPROACH: Show edits with confirmation before applying"
  - "NEVER hardcode secrets: Use environment variables only"
```

**Bonnes règles à préserver** :
- Identité et rôle (par exemple, "Vous êtes AG-API")
- Contraintes de sécurité critiques (par exemple, "Ne jamais coder en dur les secrets")
- Procédures à suivre (par exemple, "Charger d'abord l'expertise")
- Protocoles de coordination (par exemple, "Mettre à jour status.json avant et après le travail")
- Exigences de gestion de l'état (par exemple, "Vérifier test_status avant la révision")
- Priorités comportementales (par exemple, "Donner la priorité au déblocage d'AG-UI")

** Mauvaises règles ** (ne les conservez pas) :
- Instructions de flux de travail étape par étape (celles-ci peuvent être dérivées de l'état)
- Informations génériques disponibles dans les dossiers d'expertise
- Détails spécifiques au contexte (ceux-ci vont plutôt dans state_fields)

### 3. Champs d'état

État dynamique qui change pendant le travail :

```yaml
state_fields:
  - current_story
  - endpoints_implemented
  - blocked_ui_stories
  - test_status_baseline
```

**Les champs d'état préservent le travail en courscontexte** :
- Quelle histoire est mise en œuvre en ce moment
- Quels points de terminaison sont terminés, lesquels sont en attente
- Quelles histoires sont bloquées sur quoi
- Base de référence de l'état du test (doit réussir avant l'examen)
- Problèmes connus ou dette technique découverts

## Exemple réel : agent API

L'agent API démontre compact_context en action :

```yaml
compact_context:
  priority: critical
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
    - "CHECK FOR AG-UI BLOCKERS: Search bus/log.jsonl for UI stories waiting on endpoints"
    - "VERIFY TEST BASELINE: Session harness required - check test_status"
    - "ONLY mark in-review if test_status:passing - NO EXCEPTIONS"
    - "DIFF-FIRST FOR FILE CHANGES: Show all edits with YES/NO confirmation"
    - "NEVER hardcode secrets or API keys - use environment variables"
  state_fields:
    - current_story
    - endpoints_implemented
    - blocked_ui_stories
    - test_status_baseline
```

**Ce que cela préserve** :
- Priorités critiques (débloquer l'interface utilisateur en premier)
- Règles de sécurité (vérification des tests, gestion des secrets)
- État actuel (quels points de terminaison sont terminés, qu'est-ce qui bloque l'interface utilisateur)
- Test de référence (essentiel pour déterminer quand le travail est terminé)

Lors d'une implémentation API de 2 jours avec plus de 50 échanges :
1. Le compactage du contexte se produit après environ 30 échanges
2. Les règles de conservation rappellent à l'agent de vérifier la réussite des tests (non facultatif)
3. Les champs d'état indiquent quelles histoires d'interface utilisateur sont bloquées (vérification de priorité)
4. L'agent continue sans perdre son élan ni se recentrer

## Toutes les configurations d'agent

### Priorité critique (2 agents)

**mentor**
```yaml
priority: critical
preserve_rules:
  - "ALWAYS read expertise.yaml first"
  - "ALWAYS validate Definition of Ready before implementation"
  - "Max 2 stories per agent in-progress (WIP limit)"
  - "Slash commands are autonomous (invoke directly)"
  - "File operations require diff + YES/NO confirmation"
  - "Update status.json + bus/log.jsonl for all state changes"
state_fields:
  - current_story
  - story_status
  - wip_count
  - blockers
  - next_actions
```

**API**
```yaml
priority: critical
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
  - "CHECK FOR AG-UI BLOCKERS: Search bus/log.jsonl for UI stories waiting"
  - "VERIFY TEST BASELINE: Session harness required"
  - "ONLY mark in-review if test_status:passing"
  - "DIFF-FIRST FOR FILE CHANGES: Show edits with confirmation"
  - "NEVER hardcode secrets - use environment variables"
state_fields:
  - current_story
  - endpoints_implemented
  - blocked_ui_stories
  - test_status_baseline
```

###Haute priorité (8 agents)

**ui**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/ui/expertise.yaml"
  - "CHECK DESIGN SYSTEM FIRST: Detect if design tokens exist"
  - "VERIFY SESSION HARNESS: Check environment.json and test_status"
  - "ONLY in-review if tests pass: test_status:passing required"
  - "CHECK FOR API DEPENDENCIES: Search status.json for blocked UI stories"
  - "APPLY UX LAWS: Jakob's, Hick's, Fitts's, Gestalt, Von Restorff, Peak-End"
  - "ACCESSIBILITY REQUIRED: WCAG 2.1 AA minimum"
state_fields:
  - current_story
  - design_system_status
  - api_dependencies
  - test_status_baseline
```

**base de données**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/database/expertise.yaml"
  - "NEVER CHANGE SCHEMA WITHOUT MIGRATION: All changes require reversible scripts"
  - "PLAN MODE FOR HIGH-RISK CHANGES: Design before implementing"
  - "VERIFY TEST BASELINE: Check test_status before starting"
  - "REQUIRED COLUMNS: Every table needs id, created_at, updated_at"
  - "COORDINATION WITH AG-API: Review their queries"
state_fields:
  - current_story
  - schema_changes_planned
  - migration_strategy
  - api_query_reviews
  - test_status_baseline
```

**test**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/testing/expertise.yaml"
  - "AAA PATTERN: All tests follow Arrange-Act-Assert"
  - "COVERAGE MINIMUM: 70% coverage required, 80%+ for critical paths"
  - "NO FLAKY TESTS: Eliminate randomness, timing issues"
  - "TEST ISOLATION: Unit tests mock, integration tests use real dependencies"
  - "VERIFY PASSES: Run /agileflow:verify before marking in-review"
state_fields:
  - current_story
  - coverage_percentage
  - critical_paths_count
  - flaky_tests_found
  - test_status_baseline
```

**ci, devops, sécurité, documentation, performances** utilisent également `priority: high` avec des règles et des champs d'état spécifiques au domaine.

### Priorité moyenne (15 agents)

Agents spécialisés pour l'analyse, les intégrations, le mobile, la conformité, la conception, la migration de données, l'assurance qualité, l'accessibilité, la surveillance, la rédaction d'adr, la recherche, la refactorisation, la mise à jour du fichier Lisez-moi.

Tous utilisent `priority: medium` avec des règles de préservation et des champs d'état spécifiques au domaine.

## Comment fonctionne le contexte compact en pratique

### Exemple : implémentation de l'API en 2 jours

**Jour 1 - Matin** :
1. L'agent charge l'expertise (2 jetons)
2. Lit le contexte de base de code de 30 Ko (8 jetons)
3. Implémente le premier point de terminaison (5 échanges, 15 jetons)
4. **Total jusqu'à présent : 25 jetons sur un budget de 200 000**

**Jour 1 - Après-midi** :
1. Continue avec le point final suivant (8 échanges, 24 jetons)
2. Tests et optimisation (6 échanges, 18 tokens)
3. **Approche du seuil de compression (~40 jetons)**

**Avantcompression du minerai** (sans compact_context) :
- Expertise de rechargement de l'agent (2 jetons)
- L'agent relit la base de code (8 jetons)
- L'agent réexamine les histoires débloquées (3 jetons)
- **13 jetons supplémentaires gaspillés, élan perdu**

**Avec Compact_context** (priorité critique) :
- Préserver les règles de rappel : charger l'expertise, vérifier les bloqueurs, vérifier les tests
- Rappel des champs d'état : travail sur US-0042, 3 points de terminaison terminés, 2 histoires d'interface utilisateur bloquées
- Contexte de la base de code temporairement compressé mais connaissances critiques préservées
- **L'agent reprend immédiatement sans relire l'expertise**

**Jour 2 - Matin** :
1. La recompression du contexte se reproduit
2. L'agent étend son expertise (1 jeton - déjà chargé)
3. CV avec contexte complet sachant :
   - Quelles histoires sont bloquées (connaissance prioritaire)
   - Tester les exigences de base (connaissances en matière de sécurité)
   - Ce qui est déjà mis en œuvre (état des connaissances)
4. Continue avec le point final (5 échanges, 15 jetons)
5. Tests finaux et révision (4 échanges, 12 jetons)

**Gain d'efficacité** : ~20 jetonss enregistrés, mise au point soutenue maintenue, aucun retard de recentrage.

## Quand le compactage se produit

Claude Code compacte le contexte lorsque :
- L'utilisation des jetons approche la limite du modèle (~ 180 000 sur un budget de 200 000)
- La conversation comporte de nombreux échanges (compactes pour préserver les parties importantes)
- Longues périodes d'inactivité (compactage périodique pour un nouveau départ)
- L'utilisateur déclenche manuellement la compression

## Implémentation du contexte compact

### Pour les agents existants

Ajouter à la présentation de l'agent :

```yaml
---
name: agileflow-example
description: Example agent description
tools: Read, Write, Edit, Bash, Glob, Grep
model: haiku
compact_context:
  priority: high
  preserve_rules:
    - "CRITICAL RULE 1"
    - "CRITICAL RULE 2"
    - "CRITICAL RULE 3"
  state_fields:
    - current_story
    - critical_state_1
    - critical_state_2
---
```

### Bonnes pratiques

1. **Concentrez-vous sur les règles de préservation** : 5 à 7 règles maximum
2. **Utilisez les champs d'état pour le contexte** : ne mettez pas les détails de l'état dans les règles de conservation
3. **Fichiers d'expertise de référence** : les règles doivent pointer vers l'expertise et non la dupliquer
4. **Mettre à jour l'état pendant le travail** : Mentionnez régulièrement l'état actuel dans les réponses
5. **Faites correspondre la priorité à l'impact** : un impact plus élevé = une priorité plus élevée
6. **Document dans le texte principal** : expliquez compact_context dans la documentation de l'agent

### Ce qu'il ne faut PAS conserver

- Flux de travail procéduraux longs (ceux-ci peuvent être redérivés de stmangé)
- Informations générales génériques (va dans l'expertise)
- Des extraits de code ou des exemples (conservés dans l'expertise ou la base de code)
- Explications verbeuses (utilisez plutôt des règles concises)
- Informations redondantes (éviter la duplication avec les règles de préservation)

## Matrice de priorité des agents

| Agent | Priorité | Impact en cas de perte | Récupérabilité |
|-------|----------|---|---|
| mentor | critique | Impossible de coordonner la mise en œuvre | Difficile – nécessite un rechargement complet du contexte |
| API | critique | Impossible de terminer les points de terminaison, bloque l'interface utilisateur | Difficile - perd le suivi des bloqueurs |
| interface utilisateur | élevé | Perd l'état du système de conception | Modéré – l'expertise a des modèles |
| base de données | élevé | perd les décisions de conception de schéma | Modéré - migrations dans git |
| tests | élevé | perd sa stratégie de couverture | Modéré – des fichiers de test existent |
| ci | élevé | Perd la configuration de build | Modéré - scripts dans git |
| développeurs | élevé | perd sa stratégie de déploiement | Modéré - la documentation/l'architecture existe |
| sécurité | élevé | perd le modèle de menace | Modéré – l'expertise a des modèles |
| fairedocumentation | élevé | Perd le suivi de la couverture | Modéré – l'expertise a des modèles |
| performances | élevé | Perd ses objectifs d'optimisation | Modéré - métriques dans le code |
| recherche | moyen | perd ses notes de recherche | Facile - notes dans docs/10-research |
| analyses | moyen | Perd ses objectifs d'instrumentation | Facile – peut réanalyser les exigences |
| intégrations | moyen | Perd les détails de l'intégration de l'API | Facile - l'expertise a des modèles |
| mobiles | moyen | perd les décisions spécifiques à la plate-forme | Facile - l'expertise a des modèles |

## Modèles Compact_Context courants

### Modèle 1 : règles critiques pour la sécurité

Pour les agents gérant des opérations sensibles (API, sécurité, base de données) :

```yaml
preserve_rules:
  - "SAFETY RULE 1: Critical constraint"
  - "SAFETY RULE 2: Another critical constraint"
  - "VERIFICATION: How to verify the rule is followed"
```

### Modèle 2 : Travail exigeant en coordination

Pour les agents qui en débloquent d’autres (api, ui, base de données) :

```yaml
preserve_rules:
  - "BLOCKER CHECK: What to look for"
  - "COORDINATION: How to notify blocked agents"
  - "PRIORITIZATION: How to rank blocking work"
state_fields:
  - blocked_stories
  - unblock_messages_sent
  - coordination_status
```

### Modèle 3 : Travail de contrôle de la qualité

Pour les agents qui contrôlent l'état des tests (tests, ci, performances) :

```yaml
preserve_rules:
  - "BASELINE REQUIREMENT: test_status:passing needed"
  - "GATE FUNCTION: How to verify gates are met"
  - "OVERRIDE POLICY: How to document exceptions"
state_fields:
  - test_status_baseline
  - coverage_percentage
  - gate_status
```

### Modèle 4 : Fonctionnalités de longue durée

Pour les agents qui travaillent sur des fonctionnalités sur plusieurs jours (mentor, api,interface utilisateur) :

```yaml
preserve_rules:
  - "EXPERTISE LOADING: Always load expertise first"
  - "WIP LIMITS: Max N stories in-progress per agent"
  - "STATE TRACKING: Update status/bus for every state change"
state_fields:
  - current_story
  - story_status
  - wip_count
  - next_actions
```

## Surveillance de l'efficacité du contexte du Compact

### Signes que le contexte compact fonctionne

- Les agents maintiennent un comportement cohérent après le compactage du contexte
- Pas d'expertise de recentrage ou de relecture après compactage
- Les tests continuent de réussir sans redémarrage
- La coordination entre les agents reste fluide
- Moins de problèmes de « contexte perdu » dans les longues conversations

### Signes que le contexte du Compact nécessite un ajustement

- L'agent oublie de vérifier les bloqueurs après le compactage
- L'agent perd la trace du statut de l'histoire au milieu d'une conversation
- Les règles critiques sont oubliées mais référencées dans les futurs échanges
- Le suivi de l'état devient incohérent
- Le comportement de l'agent change sensiblement après le compactage

### Débogage du contexte compact

1. **Vérifiez la clarté des règles** : sont-elles concises et exploitables ?
2. **Vérifier les champs d'état** : sont-ils réellement mis à jour pendant le travail ?
3. **Examiner l'adéquation des priorités** : la priorité de l'agent est-elle adaptée à son impact ?
4. **Test après compactage** : vérifiez manuellement le comportement après compression
5. **LireCommentaires d'experts** : Vérifiez le bus de messages pour les problèmes de coordination

## Fonctionnalités associées

- **Fichiers d'expertise** : base de connaissances à long terme que compact_context complète
- **Contrôle des dommages** : empêche les modifications involontaires du code grâce à une confirmation en plusieurs étapes
- **Session Harness** : valide la ligne de base de l'état du test (référencée dans compact_context de la plupart des agents)
- **Système de compétences** : capacités d'agent dynamique chargées à la demande

## Prochaines étapes

- Vérifiez la configuration `compact_context` de votre agent dans `packages/cli/src/core/agents/`
- Si vous créez de nouveaux agents, définissez compact_context avec le niveau de priorité approprié
- Pour les fonctionnalités de longue durée, surveillez l'efficacité du compactage du contexte
- Mettez à jour les règles de préservation lorsque vous découvrez de nouveaux modèles de comportement critiques