---
title: Preservación del contexto compacto
description: Cómo los agentes de AgileFlow preservan el conocimiento crítico durante la compactación automática del contexto
---
# Preservación del contexto compacto

Los agentes de AgileFlow utilizan la configuración **compact_context** para preservar el conocimiento y el estado críticos cuando Claude Code compacta automáticamente el contexto de la conversación. Esta característica garantiza que los agentes mantengan el enfoque, sigan las reglas esenciales y realicen un seguimiento del estado actual incluso durante conversaciones prolongadas que activan la compresión del contexto.

## El problema: pérdida de contexto durante la compactación

Cuando las conversaciones se alargan, Claude Code compacta automáticamente el contexto para mantenerse dentro de los límites simbólicos. Esta compactación puede provocar:

- **Reglas perdidas**: los agentes olvidan reglas de comportamiento críticas (por ejemplo, "Cargar experiencia primero", "Verificar que las pruebas pasen antes de realizar la revisión")
- **Estado perdido**: los agentes pierden la pista del trabajo actual (en qué historia están, qué los bloquea, qué se hizo)
- **Prioridades perdidas**: los agentes olvidan qué tareas son urgentes (por ejemplo, desbloquear historias AG-UI)
- **Retraso en el reenfoque**: los agentes desperdician tokens al releer la experiencia y el contexto después de la compactación

Esto es especialmente problemático.c para:
- **Funciones de larga duración**: trabajo de implementación de varios días con docenas de intercambios
- **Agentes dependientes**: UI esperando en los puntos finales de API, ambos necesitan un enfoque sostenido
- **Coordinación crítica**: Mentor que orquesta múltiples agentes simultáneamente

## La solución: contexto compacto

Cada agente define una configuración `compact_context` con tres componentes:

### 1. Nivel de prioridad

Determina con qué agresividad se conserva el contexto del agente durante la compactación:

```yaml
compact_context:
  priority: critical  # one of: critical, high, medium, low
```

**Niveles de prioridad**:
- `critical` (2 agentes): Siempre conservado incluso en compactación agresiva
  - Mentor, Agente API
  - Manejar la orquestación y la implementación central.
- `high` (8 agentes): Preservado en la mayoría de las compactaciones.
  - UI, base de datos, CI, DevOps, pruebas, seguridad, documentación, rendimiento
  - Ejecutar trabajos de larga duración con enfoque sostenido.
- `medium` (15 agentes): Preservado cuando sea posible
  - La mayoría de agentes especializados (análisis, integraciones, móviles, etc.)
  - Manejar dominio específicoc tareas
- `low` (2 agentes): Primero en ser eliminado
  - Agentes asesores, poco utilizados (planificador épico, orquestador)
  - Sólo incluido si la habitación lo permite.

### 2. Preservar las reglas

Reglas básicas de comportamiento que nunca deben perderse:

```yaml
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
  - "VERIFY TEST BASELINE: Check test_status before starting"
  - "PRIORITIZE AG-UI BLOCKERS: Unblock UI stories waiting on API endpoints"
  - "DIFF-FIRST APPROACH: Show edits with confirmation before applying"
  - "NEVER hardcode secrets: Use environment variables only"
```

**Buenas reglas para preservar**:
- Identidad y rol (por ejemplo, "Eres AG-API")
- Restricciones de seguridad críticas (por ejemplo, "Nunca codificar secretos")
- Procedimientos obligatorios (por ejemplo, "Cargar experiencia primero")
- Protocolos de coordinación (por ejemplo, "Actualizar status.json antes y después del trabajo")
- Requisitos de gestión del estado (por ejemplo, "Verificar test_status antes de la revisión")
- Prioridades de comportamiento (por ejemplo, "Priorizar el desbloqueo de AG-UI")

**Reglas deficientes** (no las conserve):
- Instrucciones de flujo de trabajo paso a paso (se pueden derivar nuevamente del estado)
- Información genérica disponible en archivos de experiencia.
- Detalles específicos del contexto (en su lugar, van en state_fields)

### 3. Campos de estado

Estado dinámico que cambia durante el trabajo:

```yaml
state_fields:
  - current_story
  - endpoints_implemented
  - blocked_ui_stories
  - test_status_baseline
```

**Los campos de estado preservan el trabajo actualcontexto**:
- ¿Qué historia se está implementando en este momento?
- Qué puntos finales están hechos, cuáles están pendientes
- ¿Qué historias están bloqueadas en qué?
- Línea base del estado de la prueba (debe aprobarse antes de la revisión)
- Problemas conocidos o deuda técnica descubierta

## Ejemplo real: Agente API

El agente API demuestra compact_context en acción:

```yaml
compact_context:
  priority: critical
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
    - "CHECK FOR AG-UI BLOCKERS: Search bus/log.jsonl for UI stories waiting on endpoints"
    - "VERIFY TEST BASELINE: Session harness required - check test_status"
    - "ONLY mark in-review if test_status:passing - NO EXCEPTIONS"
    - "DIFF-FIRST FOR FILE CHANGES: Show all edits with YES/NO confirmation"
    - "NEVER hardcode secrets or API keys - use environment variables"
  state_fields:
    - current_story
    - endpoints_implemented
    - blocked_ui_stories
    - test_status_baseline
```

**Lo que esto preserva**:
- Prioridades críticas (desbloquear la interfaz de usuario primero)
- Normas de seguridad (verificación de pruebas, manipulación secreta)
- Estado actual (qué puntos finales están listos, qué bloquea la interfaz de usuario)
- Línea de base de la prueba (esencial para determinar cuándo se realiza el trabajo)

Durante una implementación de API de 2 días con más de 50 intercambios:
1. La compactación del contexto ocurre después de ~30 intercambios
2. Preservar las reglas recuerda al agente que verifique que se pasen las pruebas (no es opcional)
3. Los campos de estado muestran qué historias de UI están bloqueadas (verificación de prioridad)
4. El agente continúa sin perder impulso ni reenfocarse.

## Todas las configuraciones de agentes

### Prioridad crítica (2 agentes)

**mentor**
```yaml
priority: critical
preserve_rules:
  - "ALWAYS read expertise.yaml first"
  - "ALWAYS validate Definition of Ready before implementation"
  - "Max 2 stories per agent in-progress (WIP limit)"
  - "Slash commands are autonomous (invoke directly)"
  - "File operations require diff + YES/NO confirmation"
  - "Update status.json + bus/log.jsonl for all state changes"
state_fields:
  - current_story
  - story_status
  - wip_count
  - blockers
  - next_actions
```

**api**
```yaml
priority: critical
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
  - "CHECK FOR AG-UI BLOCKERS: Search bus/log.jsonl for UI stories waiting"
  - "VERIFY TEST BASELINE: Session harness required"
  - "ONLY mark in-review if test_status:passing"
  - "DIFF-FIRST FOR FILE CHANGES: Show edits with confirmation"
  - "NEVER hardcode secrets - use environment variables"
state_fields:
  - current_story
  - endpoints_implemented
  - blocked_ui_stories
  - test_status_baseline
```

###Alta prioridad (8 agentes)

**ui**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/ui/expertise.yaml"
  - "CHECK DESIGN SYSTEM FIRST: Detect if design tokens exist"
  - "VERIFY SESSION HARNESS: Check environment.json and test_status"
  - "ONLY in-review if tests pass: test_status:passing required"
  - "CHECK FOR API DEPENDENCIES: Search status.json for blocked UI stories"
  - "APPLY UX LAWS: Jakob's, Hick's, Fitts's, Gestalt, Von Restorff, Peak-End"
  - "ACCESSIBILITY REQUIRED: WCAG 2.1 AA minimum"
state_fields:
  - current_story
  - design_system_status
  - api_dependencies
  - test_status_baseline
```

**base de datos**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/database/expertise.yaml"
  - "NEVER CHANGE SCHEMA WITHOUT MIGRATION: All changes require reversible scripts"
  - "PLAN MODE FOR HIGH-RISK CHANGES: Design before implementing"
  - "VERIFY TEST BASELINE: Check test_status before starting"
  - "REQUIRED COLUMNS: Every table needs id, created_at, updated_at"
  - "COORDINATION WITH AG-API: Review their queries"
state_fields:
  - current_story
  - schema_changes_planned
  - migration_strategy
  - api_query_reviews
  - test_status_baseline
```

**prueba**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/testing/expertise.yaml"
  - "AAA PATTERN: All tests follow Arrange-Act-Assert"
  - "COVERAGE MINIMUM: 70% coverage required, 80%+ for critical paths"
  - "NO FLAKY TESTS: Eliminate randomness, timing issues"
  - "TEST ISOLATION: Unit tests mock, integration tests use real dependencies"
  - "VERIFY PASSES: Run /agileflow:verify before marking in-review"
state_fields:
  - current_story
  - coverage_percentage
  - critical_paths_count
  - flaky_tests_found
  - test_status_baseline
```

**ci, devops, seguridad, documentación, rendimiento** también usan `priority: high` con reglas y campos de estado específicos del dominio.

### Prioridad media (15 agentes)

Agentes especializados en análisis, integraciones, dispositivos móviles, cumplimiento, diseño, migración de datos, control de calidad, accesibilidad, monitoreo, adr-writer, investigación, refactor, readme-updater.

Todos usan `priority: medium` con reglas de conservación y campos de estado específicos del dominio.

## Cómo funciona el contexto compacto en la práctica

### Ejemplo: implementación de API de 2 días

**Día 1 - Mañana**:
1. El agente carga experiencia (2 tokens)
2. Lee el contexto base de código de 30 KB (8 tokens)
3. Implementa el primer punto final (5 intercambios, 15 tokens)
4. **Total hasta el momento: 25 tokens de un presupuesto de 200.000**

**Día 1 - Tarde**:
1. Continúa con el siguiente punto final (8 intercambios, 24 tokens)
2. Pruebas y optimización (6 intercambios, 18 tokens)
3. **Acercándose al umbral de compresión (~40 tokens)**

**AntesCompresión mineral** (sin contexto_compacto):
- El agente recarga experiencia (2 tokens)
- El agente vuelve a leer el código base (8 tokens)
- El agente vuelve a revisar las historias desbloqueadas (3 tokens)
- **13 tokens adicionales desperdiciados, impulso perdido**

**Con Compact_context** (prioridad crítica):
- Preservar las reglas recuerdan: cargar experiencia, verificar bloqueadores, verificar pruebas
- Los campos de estado recuerdan: trabajando en US-0042, 3 puntos finales terminados, 2 historias de UI bloqueadas
- El contexto de la base de código se comprime temporalmente pero se preserva el conocimiento crítico.
- **El agente se reanuda inmediatamente sin necesidad de volver a leer la experiencia**

**Día 2 - Mañana**:
1. La recompresión del contexto vuelve a ocurrir
2. El agente vuelve a ampliar su experiencia (1 token, ya cargado)
3. Currículums con contexto completo sabiendo:
   - Qué historias están bloqueadas (conocimiento prioritario)
   - Requisitos básicos de prueba (conocimientos de seguridad)
   - Lo que ya está implementado (conocimiento del estado)
4. Continúa con el punto final (5 intercambios, 15 tokens)
5. Prueba final y revisión interna (4 intercambios, 12 tokens)

**Aumento de eficiencia**: ~20 tokensSe guarda, se mantiene el enfoque sostenido y no hay retrasos en el reenfoque.

## Cuando ocurre la compactación

Claude Code compacta el contexto cuando:
- El uso de tokens se acerca al límite del modelo (~180 000 de un presupuesto de 200 000)
- La conversación tiene muchos intercambios (pactos para preservar partes importantes)
- Largos periodos de inactividad (compactación periódica para empezar de nuevo)
- El usuario activa manualmente la compresión.

## Implementación del contexto compacto

### Para agentes existentes

Agregar al front-matter del agente:

```yaml
---
name: agileflow-example
description: Example agent description
tools: Read, Write, Edit, Bash, Glob, Grep
model: haiku
compact_context:
  priority: high
  preserve_rules:
    - "CRITICAL RULE 1"
    - "CRITICAL RULE 2"
    - "CRITICAL RULE 3"
  state_fields:
    - current_story
    - critical_state_1
    - critical_state_2
---
```

### Mejores prácticas

1. **Manténgase centrado en las reglas de preservación**: 5-7 reglas como máximo
2. **Utilice campos de estado para contexto**: no incluya detalles de estado en reglas de preservación
3. **Archivos de experiencia de referencia**: las reglas deben señalar la experiencia, no duplicarla
4. **Actualizar el estado durante el trabajo**: mencione periódicamente el estado actual en las respuestas
5. **Hacer coincidir la prioridad con el impacto**: mayor impacto = mayor prioridad
6. **Documento en el texto principal**: Explique compact_context en la documentación del agente.

### Qué NO preservar

- Flujos de trabajo de procedimientos largos (estos pueden volver a derivarse de stcomió)
- Información general genérica (va en experiencia)
- Fragmentos de código o ejemplos (conservados en experiencia o base de código)
- Explicaciones detalladas (en su lugar, utilice reglas concisas)
- Información redundante (evite la duplicación con reglas de preservación)

## Matriz de prioridad de agentes

| Agente | Prioridad | Impacto si se pierde | Recuperabilidad |
|-------|----------|---|---|
| mentor | crítico | No se puede coordinar la implementación | Difícil: necesita recarga de contexto completo |
| API | crítico | No se pueden completar los puntos finales, bloquea la interfaz de usuario | Duro: pierde el seguimiento del bloqueador |
| interfaz de usuario | alto | Pierde el estado del sistema de diseño | Moderado: la experiencia tiene patrones |
| base de datos | alto | Pierde decisiones de diseño de esquemas | Moderado - migraciones en git |
| pruebas | alto | Pierde estrategia de cobertura | Moderado: existen archivos de prueba |
| ci | alto | Pierde la configuración de compilación | Moderado - scripts en git |
| devops | alto | Pierde estrategia de despliegue | Moderado: existe documentación/arquitectura |
| seguridad | alto | Pierde modelo de amenaza | Moderado: la experiencia tiene patrones |
| hacercomentacion | alto | Pierde seguimiento de cobertura | Moderado: la experiencia tiene patrones |
| rendimiento | alto | Pierde objetivos de optimización | Moderado: métricas en el código |
| investigación | medio | Pierde notas de investigación | Fácil: notas en docs/10-research |
| análisis | medio | Pierde objetivos de instrumentación | Fácil: puede volver a analizar los requisitos |
| integraciones | medio | Pierde detalles de integración API | Fácil: la experiencia tiene patrones |
| móvil | medio | Pierde decisiones específicas de plataforma | Fácil: la experiencia tiene patrones |

## Patrones comunes de contexto_compacto

### Patrón 1: Reglas críticas para la seguridad

Para agentes que manejan operaciones confidenciales (API, seguridad, base de datos):

```yaml
preserve_rules:
  - "SAFETY RULE 1: Critical constraint"
  - "SAFETY RULE 2: Another critical constraint"
  - "VERIFICATION: How to verify the rule is followed"
```

### Patrón 2: Coordinación: trabajo pesado

Para agentes que desbloquean a otros (api, ui, base de datos):

```yaml
preserve_rules:
  - "BLOCKER CHECK: What to look for"
  - "COORDINATION: How to notify blocked agents"
  - "PRIORITIZATION: How to rank blocking work"
state_fields:
  - blocked_stories
  - unblock_messages_sent
  - coordination_status
```

### Patrón 3: Trabajo de puerta de calidad

Para agentes que controlan el estado de la prueba (pruebas, ci, rendimiento):

```yaml
preserve_rules:
  - "BASELINE REQUIREMENT: test_status:passing needed"
  - "GATE FUNCTION: How to verify gates are met"
  - "OVERRIDE POLICY: How to document exceptions"
state_fields:
  - test_status_baseline
  - coverage_percentage
  - gate_status
```

### Patrón 4: Funciones de larga duración

Para agentes que trabajan en funciones de varios días (mentor, api,interfaz de usuario):

```yaml
preserve_rules:
  - "EXPERTISE LOADING: Always load expertise first"
  - "WIP LIMITS: Max N stories in-progress per agent"
  - "STATE TRACKING: Update status/bus for every state change"
state_fields:
  - current_story
  - story_status
  - wip_count
  - next_actions
```

## Monitoreo de la efectividad del contexto compacto

### Señales de que el contexto compacto está funcionando

- Los agentes mantienen un comportamiento consistente después de la compactación del contexto.
- No es necesario reorientar ni releer la experiencia después de la compactación.
- Las pruebas continúan pasando sin reiniciar
- La coordinación entre agentes se mantiene fluida
- Menos problemas de "contexto perdido" en conversaciones largas

### Señales El contexto compacto necesita ajustes

- El agente se olvida de revisar los bloqueadores después de la compactación.
- El agente pierde la pista del estado de la historia en mitad de la conversación.
- Las reglas críticas se olvidan pero se hace referencia a ellas en futuros intercambios.
- El seguimiento del estado se vuelve inconsistente
- El comportamiento del agente cambia notablemente después de la compactación.

### Depuración del contexto compacto

1. **Comprueba la claridad de las reglas**: ¿son concisas y prácticas?
2. **Verificar campos de estado**: ¿Están realmente actualizados durante el trabajo?
3. **Revisar el ajuste de la prioridad**: ¿La prioridad del agente es adecuada para su impacto?
4. **Prueba después de la compactación**: Verifique manualmente el comportamiento después de la compresión
5. **LeerComentarios de expertos**: verifique el bus de mensajes para detectar problemas de coordinación.

## Funciones relacionadas

- **Archivos de experiencia**: base de conocimientos a largo plazo que complementa compact_context
- **Control de daños**: evita cambios de código no deseados mediante la confirmación de varios pasos
- **Arnés de sesión**: valida la línea base del estado de la prueba (a la que se hace referencia en el contexto_compacto de la mayoría de los agentes)
- **Sistema de habilidades**: capacidades dinámicas del agente cargadas bajo demanda

## Próximos pasos

- Revise la configuración `compact_context` de su agente en `packages/cli/src/core/agents/`
- Si crea nuevos agentes, defina compact_context con el nivel de prioridad apropiado
- Para funciones de larga duración, supervise la eficacia de la compactación del contexto.
- Actualice las reglas de preservación cuando descubra nuevos patrones de comportamiento críticos.