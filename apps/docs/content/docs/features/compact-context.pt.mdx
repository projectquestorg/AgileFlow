---
title: Preservação compacta de contexto
description: Como os agentes AgileFlow preservam o conhecimento crítico durante a compactação automática de contexto
---
# Preservação compacta de contexto

Os agentes AgileFlow usam a configuração **compact_context** para preservar o conhecimento e o estado críticos quando o Claude Code compacta automaticamente o contexto da conversa. Esse recurso garante que os agentes mantenham o foco, continuem seguindo regras essenciais e rastreiem o estado atual mesmo durante conversas prolongadas que acionam a compactação de contexto.

## O problema: perda de contexto durante a compactação

Quando as conversas ficam longas, o Claude Code compacta automaticamente o contexto para permanecer dentro dos limites do token. Esta compactação pode causar:

- **Regras perdidas**: os agentes esquecem regras comportamentais críticas (por exemplo, "Carregar experiência primeiro", "Verificar se os testes foram aprovados antes da revisão")
- **Estado perdido**: os agentes perdem o controle do trabalho atual (em qual história estão, o que os está bloqueando, o que foi feito)
- **Prioridades perdidas**: os agentes esquecem quais tarefas são urgentes (por exemplo, desbloquear histórias AG-UI)
- **Atraso na reorientação**: os agentes desperdiçam tokens relendo conhecimento e contexto após a compactação

Isto é especialmente problemáticoc para:
- **Recursos de longa duração**: trabalho de implementação de vários dias com dezenas de exchanges
- **Agentes dependentes**: UI aguardando endpoints de API, ambos precisando de foco sustentado
- **Coordenação crítica**: Mentor orquestrando vários agentes simultaneamente

## A solução: contexto compacto

Cada agente define uma configuração __NOTRASLATE_14__ com três componentes:

### 1. Nível de prioridade

Determina com que agressividade o contexto do agente é preservado durante a compactação:

```yaml
compact_context:
  priority: critical  # one of: critical, high, medium, low
```

**Níveis de prioridade**:
- __NOTRASLATE_15__ (2 agentes): Sempre preservado mesmo em compactação agressiva
  - Mentor, Agente API
  - Lidar com orquestração e implementação principal
- __NOTRASLATE_16__ (8 agentes): Preservado na maioria das compactações
  - UI, Banco de Dados, CI, DevOps, Testes, Segurança, Documentação, Desempenho
  - Execute trabalhos de longa duração com foco sustentado
- __NOTRASLATE_17__ (15 agentes): Preservado quando possível
  - Agentes mais especializados (analíticos, integrações, mobile, etc.)
  - Lidar com domínio específicoc tarefas
- __NOTRASLATE_18__ (2 agentes): Primeiro a ser removido
  - Agentes consultivos, raramente usados (planejador épico, orquestrador)
  - Somente incluído se o quarto permitir

### 2. Preservar regras

Regras comportamentais básicas que nunca devem ser perdidas:

```yaml
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
  - "VERIFY TEST BASELINE: Check test_status before starting"
  - "PRIORITIZE AG-UI BLOCKERS: Unblock UI stories waiting on API endpoints"
  - "DIFF-FIRST APPROACH: Show edits with confirmation before applying"
  - "NEVER hardcode secrets: Use environment variables only"
```

**Boas regras para preservar**:
- Identidade e função (por exemplo, "Você é AG-API")
- Restrições críticas de segurança (por exemplo, "Nunca codificar segredos")
- Procedimentos obrigatórios (por exemplo, "Carregar experiência primeiro")
- Protocolos de coordenação (por exemplo, "Atualizar status.json antes e depois do trabalho")
- Requisitos de gerenciamento de estado (por exemplo, "Verificar test_status antes da revisão")
- Prioridades comportamentais (por exemplo, "Priorizar o desbloqueio do AG-UI")

**Regras ruins** (não as preserve):
- Instruções de fluxo de trabalho passo a passo (podem ser derivadas novamente do estado)
- Informações genéricas disponíveis em arquivos de perícia
- Detalhes específicos do contexto (em vez disso, vão para state_fields)

### 3. Campos de estado

Estado dinâmico que muda durante o trabalho:

```yaml
state_fields:
  - current_story
  - endpoints_implemented
  - blocked_ui_stories
  - test_status_baseline
```

**Os campos de estado preservam o trabalho atualcontexto**:
- Que história está sendo implementada agora
- Quais endpoints foram concluídos e quais estão pendentes
- Quais histórias estão bloqueadas em quais
- Linha de base do status do teste (deve passar antes da revisão)
- Problemas conhecidos ou dívida técnica descoberta

## Exemplo real: Agente API

O agente API demonstra compact_context em ação:

__NOTRADUZIR_3__

**O que isso preserva**:
- Prioridades críticas (desbloquear a UI primeiro)
- Regras de segurança (verificação de testes, tratamento secreto)
- Estado atual (quais endpoints estão concluídos, o que está bloqueando a IU)
- Linha de base do teste (essencial para determinar quando o trabalho está concluído)

Durante uma implementação de API de 2 dias com mais de 50 trocas:
1. A compactação do contexto acontece após cerca de 30 trocas
2. Preservar regras lembra o agente de verificar a aprovação nos testes (não opcional)
3. Os campos de estado mostram quais histórias de UI estão bloqueadas (verificação de prioridade)
4. O agente continua sem perder o ímpeto ou focar novamente

## Todas as configurações do agente

### Prioridade Crítica (2 agentes)

**mentor**
__NÃOTRADUZIR_4__

**API**
__NOTRADUZIR_5__

###Alta prioridade (8 agentes)

**ui**
__NOTRADUZIR_6__

**banco de dados**
__NÃOTRADUZIR_7__

**testando**
__NÃOTRADUZIR_8__

**ci, devops, segurança, documentação, desempenho** também usam __NOTRASLATE_19__ com regras específicas de domínio e campos de estado.

### Prioridade Média (15 agentes)

Agentes especializados para análises, integrações, dispositivos móveis, conformidade, design, migração de dados, controle de qualidade, acessibilidade, monitoramento, redator de anúncios, pesquisa, refatoração, atualizador readme.

Todos usam __NOTRASLATE_20__ com regras de preservação e campos de estado específicos do domínio.

## Como o contexto compacto funciona na prática

### Exemplo: implementação de API em 2 dias

**Dia 1 - Manhã**:
1. Agente carrega expertise (2 tokens)
2. Lê contexto de base de código de 30 KB (8 tokens)
3. Implementa o primeiro endpoint (5 exchanges, 15 tokens)
4. **Total até agora: 25 tokens com orçamento de 200 mil**

**Dia 1 - Tarde**:
1. Continua com o próximo endpoint (8 exchanges, 24 tokens)
2. Testes e otimização (6 exchanges, 18 tokens)
3. **Aproximando-se do limite de compactação (~40 tokens)**

**AntesCompressão de minério** (sem compact_context):
- Agente recarrega expertise (2 tokens)
- Agente relê a base de código (8 tokens)
- Agente revisa histórias desbloqueadas (3 tokens)
- **13 tokens extras desperdiçados, impulso perdido**

**Com Compact_context** (prioridade crítica):
- Preservar regras lembrando: Carregar experiência, verificar bloqueadores, verificar testes
- Os campos de estado lembram: trabalhando em US-0042, 3 endpoints concluídos, 2 histórias de UI bloqueadas
- Contexto da base de código temporariamente compactado, mas conhecimento crítico preservado
- **O agente retoma imediatamente sem reler a experiência**

**Dia 2 - Manhã**:
1. A recompressão de contexto acontece novamente
2. Agente reexpande experiência (1 token - já carregado)
3. Currículos com conhecimento completo do contexto:
   - Quais histórias estão bloqueadas (conhecimento prioritário)
   - Teste os requisitos básicos (conhecimento de segurança)
   - O que já está implementado (conhecimento do estado)
4. Continua com o ponto final (5 exchanges, 15 tokens)
5. Teste final e revisão (4 exchanges, 12 tokens)

**Ganho de eficiência**: ~20 tokensé salvo, o foco sustentado é mantido, sem atrasos na reorientação.

## Quando a compactação acontece

Claude Code compacta o contexto quando:
- O uso de token se aproxima do limite do modelo (cerca de 180 mil do orçamento de 200 mil)
- A conversa tem muitas trocas (compacta para preservar partes importantes)
- Longos períodos de inatividade (compactação periódica para recomeços)
- O usuário aciona manualmente a compactação

## Implementando Contexto Compacto

### Para agentes existentes

Adicionar ao frontmatter do agente:

__NOTRADUZIR_9__

### Melhores Práticas

1. **Mantenha o foco nas regras de preservação**: 5 a 7 regras no máximo
2. **Use campos de estado para contexto**: não coloque detalhes de estado em regras de preservação
3. **Arquivos de experiência de referência**: as regras devem apontar para a experiência, e não duplicá-la
4. **Atualizar estado durante o trabalho**: mencione regularmente o estado atual nas respostas
5. **Combinar prioridade com impacto**: Maior impacto = maior prioridade
6. **Documento no texto principal**: Explique compact_context na documentação do agente

### O que NÃO Preservar

- Fluxos de trabalho processuais longos (estes podem ser derivados de stcomi)
- Informações gerais genéricas (vão para especialização)
- Trechos de código ou exemplos (preservados em expertise ou base de código)
- Explicações detalhadas (use regras concisas)
- Informações redundantes (evite duplicação com regras de preservação)

## Matriz de Prioridade do Agente

| Agente | Prioridade | Impacto em caso de perda | Recuperabilidade |
|---|----------|---|---|
| mentor | crítico | Não é possível coordenar a implementação | Difícil - precisa de atualização completa do contexto |
| API | crítico | Não é possível concluir endpoints, bloqueia UI | Difícil - perde o rastreamento do bloqueador |
| interface do usuário | alto | Perde o estado do sistema de design | Moderado – a experiência tem padrões |
| banco de dados | alto | Perde decisões de design de esquema | Moderado - migrações no git |
| testes | alto | Perde estratégia de cobertura | Moderado - existem arquivos de teste |
| ci | alto | Perde configuração de compilação | Moderado - scripts em git |
| devops | alto | Perde estratégia de implantação | Moderado - documentação/arquitetura existe |
| segurança | alto | Perde modelo de ameaça | Moderado – a experiência tem padrões |
| fazerdocumentação | alto | Perde rastreamento de cobertura | Moderado – a experiência tem padrões |
| desempenho | alto | Perde metas de otimização | Moderado – métricas no código |
| investigação | médio | Perde notas de pesquisa | Fácil - notas em docs/10-research |
| análise | médio | Perde objetivos de instrumentação | Fácil - pode reanalisar requisitos |
| integrações | médio | Perde detalhes de integração da API | Fácil – a expertise tem padrões |
| móvel | médio | Perde decisões específicas da plataforma | Fácil – a expertise tem padrões |

## Padrões Compact_Context comuns

### Padrão 1: Regras críticas de segurança

Para agentes que lidam com operações confidenciais (API, segurança, banco de dados):

__NOTRADUZIR_10__

### Padrão 2: Trabalho Pesado de Coordenação

Para agentes que desbloqueiam outros (api, ui, banco de dados):

__NOTRADUZIR_11__

### Padrão 3: Trabalho de qualidade

Para agentes que controlam o status do teste (teste, ci, desempenho):

```yaml
preserve_rules:
  - "BASELINE REQUIREMENT: test_status:passing needed"
  - "GATE FUNCTION: How to verify gates are met"
  - "OVERRIDE POLICY: How to document exceptions"
state_fields:
  - test_status_baseline
  - coverage_percentage
  - gate_status
```

### Padrão 4: Recursos de longa duração

Para agentes que trabalham em recursos de vários dias (mentor, API,interface do usuário):

__NÃOTRADUZIR_13__

## Monitorando a eficácia do contexto compacto

### Sinais de que o contexto compacto está funcionando

- Os agentes mantêm um comportamento consistente após a compactação do contexto
- Nenhuma experiência de reorientação ou releitura após a compactação
- Os testes continuam a passar sem reiniciar
- A coordenação entre agentes permanece tranquila
- Menos problemas de “contexto perdido” em conversas longas

### Sinais de que o contexto compacto precisa de ajuste

- Agente esquece de verificar os bloqueadores após a compactação
- O agente perde o controle do status da história no meio da conversa
- Regras críticas são esquecidas, mas referenciadas em trocas futuras
- O rastreamento de estado torna-se inconsistente
- O comportamento do agente muda visivelmente após a compactação

### Depurando contexto compacto

1. **Verifique e preserve a clareza das regras**: elas são concisas e acionáveis?
2. **Verifique os campos de estado**: eles são realmente atualizados durante o trabalho?
3. **Revisar ajuste de prioridade**: A prioridade do agente é apropriada para seu impacto?
4. **Teste após compactação**: verifique manualmente o comportamento pós-compactação
5. **Leiafeedback de especialistas **: Verifique o barramento de mensagens para problemas de coordenação

## Recursos relacionados

- **Arquivos de conhecimento**: base de conhecimento de longo prazo que compact_context complementa
- **Controle de danos**: evita alterações não intencionais de código por meio de confirmação em várias etapas
- **Session Harness**: valida a linha de base do status do teste (referenciada no compact_context da maioria dos agentes)
- **Sistema de habilidades**: recursos dinâmicos do agente carregados sob demanda

## Próximas etapas

- Revise a configuração __NOTRASLATE_21__ do seu agente em __NOTRASLATE_22__
- Se estiver criando novos agentes, defina compact_context com nível de prioridade apropriado
- Para recursos de longa duração, monitore a eficácia da compactação de contexto
- Atualize as regras de preservação ao descobrir novos padrões comportamentais críticos