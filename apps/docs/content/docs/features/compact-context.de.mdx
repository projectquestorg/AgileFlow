---
title: Kompakte Kontexterhaltung
description: Wie AgileFlow-Agenten wichtiges Wissen während der automatischen Kontextkomprimierung bewahren
---
# Kompakte Kontexterhaltung

AgileFlow-Agenten verwenden die Konfiguration **compact_context**, um wichtiges Wissen und Status beizubehalten, wenn Claude Code den Konversationskontext automatisch komprimiert. Diese Funktion stellt sicher, dass Agenten den Fokus behalten, weiterhin wichtige Regeln befolgen und den aktuellen Status verfolgen, selbst während längerer Gespräche, die eine Kontextkomprimierung auslösen.

## Das Problem: Kontextverlust während der Komprimierung

Wenn Gespräche länger werden, komprimiert Claude Code den Kontext automatisch, um innerhalb der Token-Grenzen zu bleiben. Diese Verdichtung kann Folgendes verursachen:

- **Verlorene Regeln**: Agenten vergessen wichtige Verhaltensregeln (z. B. „Laden Sie zuerst Fachwissen ein“, „Prüfen Sie, ob die Tests bestanden sind, bevor Sie sie überprüfen“).
- **Verlorener Status**: Agenten verlieren den Überblick über die aktuelle Arbeit (an welcher Story sie gerade arbeiten, was sie blockiert, was erledigt ist)
- **Verlorene Prioritäten**: Agenten vergessen, welche Aufgaben dringend sind (z. B. AG-UI-Storys entsperren)
- **Verzögerung der Neuausrichtung**: Agenten verschwenden Token für das erneute Lesen von Fachwissen und Kontext nach der Komprimierung

Dies ist besonders problematischc für:
- **Langzeitfunktionen**: Mehrtägige Implementierungsarbeit mit Dutzenden von Börsen
- **Abhängige Agenten**: Die Benutzeroberfläche wartet auf API-Endpunkte, die beide einen dauerhaften Fokus erfordern
- **Kritische Koordination**: Mentor orchestriert mehrere Agenten gleichzeitig

## Die Lösung: Kompakter Kontext

Jeder Agent definiert eine `compact_context`-Konfiguration mit drei Komponenten:

### 1. Prioritätsstufe

Bestimmt, wie aggressiv der Kontext des Agenten während der Komprimierung erhalten bleibt:

```yaml
compact_context:
  priority: critical  # one of: critical, high, medium, low
```

**Prioritätsstufen**:
- `critical` (2 Agenten): Auch bei aggressiver Verdichtung immer erhalten
  - Mentor, API-Agent
  - Kümmern Sie sich um die Orchestrierung und Kernimplementierung
- `high` (8 Agenten): In den meisten Verdichtungen erhalten
  - Benutzeroberfläche, Datenbank, CI, DevOps, Tests, Sicherheit, Dokumentation, Leistung
  - Führen Sie Langzeitarbeiten mit anhaltender Konzentration durch
- `medium` (15 Agenten): Wenn möglich beibehalten
  - Die meisten spezialisierten Agenten (Analysen, Integrationen, Mobilgeräte usw.)
  - Behandeln Sie domänenspezifische Datenc Aufgaben
- `low` (2 Agenten): Zuerst entfernt werden
  - Beratungsagenten, selten eingesetzt (Epic-Planer, Orchestrator)
  - Nur inbegriffen, wenn der Platz es zulässt

### 2. Regeln beibehalten

Grundlegende Verhaltensregeln, die niemals verloren gehen dürfen:

```yaml
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
  - "VERIFY TEST BASELINE: Check test_status before starting"
  - "PRIORITIZE AG-UI BLOCKERS: Unblock UI stories waiting on API endpoints"
  - "DIFF-FIRST APPROACH: Show edits with confirmation before applying"
  - "NEVER hardcode secrets: Use environment variables only"
```

**Gute Regeln zum Aufbewahren**:
- Identität und Rolle (z. B. „Sie sind AG-API“)
- Kritische Sicherheitsbeschränkungen (z. B. „Keine Geheimnisse fest kodieren“)
- Verfahren, die unbedingt befolgt werden müssen (z. B. „Zuerst Fachwissen laden“)
- Koordinationsprotokolle (z. B. „Status.json vor und nach der Arbeit aktualisieren“)
- Statusverwaltungsanforderungen (z. B. „Teststatus vor In-Review überprüfen“)
- Verhaltensprioritäten (z. B. „Entsperren der AG-UI priorisieren“)

**Schlechte Regeln** (behalten Sie diese nicht bei):
- Schritt-für-Schritt-Anleitungen zum Arbeitsablauf (diese können aus dem Status erneut abgeleitet werden)
- Allgemeine Informationen in Fachwissensdateien verfügbar
- Kontextspezifische Details (diese werden stattdessen in state_fields angezeigt)

### 3. Statusfelder

Dynamischer Zustand, der sich während der Arbeit ändert:

```yaml
state_fields:
  - current_story
  - endpoints_implemented
  - blocked_ui_stories
  - test_status_baseline
```

**Statusfelder bewahren die aktuelle ArbeitKontext**:
- Welche Story wird gerade umgesetzt
- Welche Endpunkte sind erledigt, welche stehen noch aus
- Welche Geschichten sind auf was blockiert?
- Teststatus-Basislinie (muss vor der Überprüfung bestanden werden)
- Bekannte Probleme oder technische Schulden entdeckt

## Echtes Beispiel: API-Agent

Der API-Agent demonstriert „compact_context“ in Aktion:

```yaml
compact_context:
  priority: critical
  preserve_rules:
    - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
    - "CHECK FOR AG-UI BLOCKERS: Search bus/log.jsonl for UI stories waiting on endpoints"
    - "VERIFY TEST BASELINE: Session harness required - check test_status"
    - "ONLY mark in-review if test_status:passing - NO EXCEPTIONS"
    - "DIFF-FIRST FOR FILE CHANGES: Show all edits with YES/NO confirmation"
    - "NEVER hardcode secrets or API keys - use environment variables"
  state_fields:
    - current_story
    - endpoints_implemented
    - blocked_ui_stories
    - test_status_baseline
```

**Was dadurch erhalten bleibt**:
- Kritische Prioritäten (zuerst die Benutzeroberfläche entsperren)
- Sicherheitsregeln (Prüfung, Geheimhaltung)
– Aktueller Status (welche Endpunkte erledigt sind, was blockiert die Benutzeroberfläche)
- Testbasislinie (wesentlich, um festzustellen, wann die Arbeit erledigt ist)

Während einer zweitägigen API-Implementierung mit mehr als 50 Börsen:
1. Die Kontextverdichtung erfolgt nach etwa 30 Austauschvorgängen
2. Beibehaltungsregeln erinnern den Agenten daran, zu überprüfen, ob die Tests bestanden wurden (nicht optional).
3. Statusfelder zeigen an, welche UI-Storys blockiert sind (Prioritätsprüfung)
4. Der Agent macht weiter, ohne an Schwung zu verlieren oder sich neu zu konzentrieren

## Alle Agentenkonfigurationen

### Kritische Priorität (2 Agenten)

**Mentor**
```yaml
priority: critical
preserve_rules:
  - "ALWAYS read expertise.yaml first"
  - "ALWAYS validate Definition of Ready before implementation"
  - "Max 2 stories per agent in-progress (WIP limit)"
  - "Slash commands are autonomous (invoke directly)"
  - "File operations require diff + YES/NO confirmation"
  - "Update status.json + bus/log.jsonl for all state changes"
state_fields:
  - current_story
  - story_status
  - wip_count
  - blockers
  - next_actions
```

**api**
```yaml
priority: critical
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/api/expertise.yaml"
  - "CHECK FOR AG-UI BLOCKERS: Search bus/log.jsonl for UI stories waiting"
  - "VERIFY TEST BASELINE: Session harness required"
  - "ONLY mark in-review if test_status:passing"
  - "DIFF-FIRST FOR FILE CHANGES: Show edits with confirmation"
  - "NEVER hardcode secrets - use environment variables"
state_fields:
  - current_story
  - endpoints_implemented
  - blocked_ui_stories
  - test_status_baseline
```

###Hohe Priorität (8 Agenten)

**ui**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/ui/expertise.yaml"
  - "CHECK DESIGN SYSTEM FIRST: Detect if design tokens exist"
  - "VERIFY SESSION HARNESS: Check environment.json and test_status"
  - "ONLY in-review if tests pass: test_status:passing required"
  - "CHECK FOR API DEPENDENCIES: Search status.json for blocked UI stories"
  - "APPLY UX LAWS: Jakob's, Hick's, Fitts's, Gestalt, Von Restorff, Peak-End"
  - "ACCESSIBILITY REQUIRED: WCAG 2.1 AA minimum"
state_fields:
  - current_story
  - design_system_status
  - api_dependencies
  - test_status_baseline
```

**Datenbank**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/database/expertise.yaml"
  - "NEVER CHANGE SCHEMA WITHOUT MIGRATION: All changes require reversible scripts"
  - "PLAN MODE FOR HIGH-RISK CHANGES: Design before implementing"
  - "VERIFY TEST BASELINE: Check test_status before starting"
  - "REQUIRED COLUMNS: Every table needs id, created_at, updated_at"
  - "COORDINATION WITH AG-API: Review their queries"
state_fields:
  - current_story
  - schema_changes_planned
  - migration_strategy
  - api_query_reviews
  - test_status_baseline
```

**Testen**
```yaml
priority: high
preserve_rules:
  - "LOAD EXPERTISE FIRST: Always read packages/cli/src/core/experts/testing/expertise.yaml"
  - "AAA PATTERN: All tests follow Arrange-Act-Assert"
  - "COVERAGE MINIMUM: 70% coverage required, 80%+ for critical paths"
  - "NO FLAKY TESTS: Eliminate randomness, timing issues"
  - "TEST ISOLATION: Unit tests mock, integration tests use real dependencies"
  - "VERIFY PASSES: Run /agileflow:verify before marking in-review"
state_fields:
  - current_story
  - coverage_percentage
  - critical_paths_count
  - flaky_tests_found
  - test_status_baseline
```

**CI, DevOps, Sicherheit, Dokumentation, Leistung** verwenden auch `priority: high` mit domänenspezifischen Regeln und Statusfeldern.

### Mittlere Priorität (15 Agenten)

Spezialisierte Agenten für Analysen, Integrationen, Mobilgeräte, Compliance, Design, Datenmigration, Qualitätssicherung, Barrierefreiheit, Überwachung, AdR-Autor, Forschung, Refactor, Readme-Updater.

Alle verwenden `priority: medium` mit domänenspezifischen Aufbewahrungsregeln und Statusfeldern.

## Wie Compact Context in der Praxis funktioniert

### Beispiel: 2-tägige API-Implementierung

**Tag 1 – Morgen**:
1. Agent lädt Fachwissen (2 Token)
2. Liest 30 KB Codebasiskontext (8 Token)
3. Implementiert den ersten Endpunkt (5 Börsen, 15 Token)
4. **Gesamt bisher: 25 Token mit einem Budget von 200.000**

**Tag 1 – Nachmittag**:
1. Weiter mit dem nächsten Endpunkt (8 Börsen, 24 Token)
2. Tests und Optimierung (6 Börsen, 18 Token)
3. **Komprimierungsschwelle nähert sich (~40 Token)**

**BefErzkomprimierung** (ohne compact_context):
- Agent lädt Fachwissen nach (2 Token)
– Agent liest Codebasis erneut (8 Token)
- Agent überprüft nicht blockierte Geschichten erneut (3 Token)
- **13 zusätzliche Token verschwendet, Schwung verloren**

**Mit Compact_context** (kritische Priorität):
- Erinnerung an Regeln beibehalten: Fachwissen laden, Blocker überprüfen, Tests überprüfen
- Zustandsfelder erinnern: Arbeit an US-0042, 3 Endpunkte erledigt, 2 UI-Storys blockiert
- Codebasiskontext vorübergehend komprimiert, aber wichtiges Wissen bleibt erhalten
- **Agent fährt sofort fort, ohne das Fachwissen noch einmal lesen zu müssen**

**Tag 2 – Morgen**:
1. Die Neukomprimierung des Kontexts erfolgt erneut
2. Agent erweitert Fachwissen erneut (1 Token – bereits geladen)
3. Lebensläufe mit vollständigem Kontextwissen:
   - Welche Geschichten sind gesperrt (Prioritätswissen)
   - Grundlegende Anforderungen testen (Sicherheitswissen)
   - Was bereits umgesetzt ist (Standwissen)
4. Weiter mit dem letzten Endpunkt (5 Börsen, 15 Token)
5. Abschließende Tests und Überprüfung (4 Umtausch, 12 Token)

**Effizienzgewinn**: ~20 TokenDas Bild wird gespeichert, der Fokus bleibt dauerhaft erhalten, es gibt keine Verzögerungen bei der Neufokussierung.

## Wenn eine Verdichtung stattfindet

Claude Code komprimiert den Kontext, wenn:
– Die Token-Nutzung nähert sich dem Modelllimit (~180.000 von 200.000 Budget)
- Konversation hat viele Austausche (komprimiert, um wichtige Teile zu bewahren)
- Lange Leerlaufzeiten (periodische Verdichtung für Neustart)
- Der Benutzer löst die Komprimierung manuell aus

## Kompakten Kontext implementieren

### Für bestehende Agenten

Zum Agenten-Frontmatter hinzufügen:

```yaml
---
name: agileflow-example
description: Example agent description
tools: Read, Write, Edit, Bash, Glob, Grep
model: haiku
compact_context:
  priority: high
  preserve_rules:
    - "CRITICAL RULE 1"
    - "CRITICAL RULE 2"
    - "CRITICAL RULE 3"
  state_fields:
    - current_story
    - critical_state_1
    - critical_state_2
---
```

### Best Practices

1. **Konzentrieren Sie sich auf die Beibehaltungsregeln**: maximal 5–7 Regeln
2. **Statusfelder als Kontext verwenden**: Fügen Sie keine Statusdetails in Aufbewahrungsregeln ein
3. **Referenzgutachtendateien**: Regeln sollten auf Fachwissen verweisen und es nicht duplizieren
4. **Status während der Arbeit aktualisieren**: Erwähnen Sie regelmäßig den aktuellen Status in Antworten
5. **Priorität an Auswirkung anpassen**: Höhere Auswirkung = höhere Priorität
6. **Dokument im Haupttext**: Erläutern Sie „compact_context“ in der Agentendokumentation

### Was man NICHT aufbewahren sollte

- Lange Verfahrensabläufe (diese können aus staß)
- Allgemeine Hintergrundinformationen (gehört zum Fachwissen)
- Codeausschnitte oder Beispiele (im Fachwissen oder in der Codebasis aufbewahrt)
- Ausführliche Erklärungen (verwenden Sie stattdessen prägnante Regeln)
- Redundante Informationen (Vermeidung von Duplikaten durch Beibehaltungsregeln)

## Agentenprioritätsmatrix

| Agent | Priorität | Auswirkungen bei Verlust | Wiederherstellbarkeit |
|-------|----------|---|---|
| Mentor | kritisch | Implementierung kann nicht koordiniert werden | Schwer – vollständiges Neuladen des Kontexts erforderlich |
| API | kritisch | Endpunkte können nicht abgeschlossen werden, blockiert die Benutzeroberfläche | Hart – Blocker-Tracking geht verloren |
| ui | hoch | Verliert den Design-Systemstatus | Mäßig – Fachwissen hat Muster |
| Datenbank | hoch | Verliert Schema-Design-Entscheidungen | Moderat – Migrationen in Git |
| testen | hoch | Verliert Deckungsstrategie | Moderat – Testdateien vorhanden |
| ci | hoch | Verliert Build-Konfiguration | Moderat – Skripte in Git |
| entwickelt | hoch | Verliert die Bereitstellungsstrategie | Moderat – Dokumente/Architektur vorhanden |
| Sicherheit | hoch | Verliert Bedrohungsmodell | Mäßig – Fachwissen hat Muster |
| TunKumentation | hoch | Verliert die Abdeckungsverfolgung | Mäßig – Fachwissen hat Muster |
| Leistung | hoch | Verliert Optimierungsziele | Moderat – Metriken im Code |
| Forschung | mittel | Verliert Forschungsnotizen | Einfach – Notizen in docs/10-research |
| Analytik | mittel | Verliert Instrumentierungsziele | Einfach – Anforderungen können neu analysiert werden |
| Integrationen | mittel | Verliert API-Integrationsdetails | Ganz einfach – Fachwissen hat Muster |
| mobil | mittel | Verliert plattformspezifische Entscheidungen | Ganz einfach – Fachwissen hat Muster |

## Häufige Compact_Context-Muster

### Muster 1: Sicherheitskritische Regeln

Für Agenten, die sensible Vorgänge verarbeiten (API, Sicherheit, Datenbank):

```yaml
preserve_rules:
  - "SAFETY RULE 1: Critical constraint"
  - "SAFETY RULE 2: Another critical constraint"
  - "VERIFICATION: How to verify the rule is followed"
```

### Muster 2: Koordinationsintensive Arbeit

Für Agenten, die andere entsperren (API, UI, Datenbank):

```yaml
preserve_rules:
  - "BLOCKER CHECK: What to look for"
  - "COORDINATION: How to notify blocked agents"
  - "PRIORITIZATION: How to rank blocking work"
state_fields:
  - blocked_stories
  - unblock_messages_sent
  - coordination_status
```

### Muster 3: Quality-Gate-Arbeit

Für Agenten, die den Teststatus (Tests, CI, Leistung) steuern:

```yaml
preserve_rules:
  - "BASELINE REQUIREMENT: test_status:passing needed"
  - "GATE FUNCTION: How to verify gates are met"
  - "OVERRIDE POLICY: How to document exceptions"
state_fields:
  - test_status_baseline
  - coverage_percentage
  - gate_status
```

### Muster 4: Langzeitfunktionen

Für Agenten, die an mehrtägigen Funktionen arbeiten (Mentor, API,ui):

```yaml
preserve_rules:
  - "EXPERTISE LOADING: Always load expertise first"
  - "WIP LIMITS: Max N stories in-progress per agent"
  - "STATE TRACKING: Update status/bus for every state change"
state_fields:
  - current_story
  - story_status
  - wip_count
  - next_actions
```

## Überwachung der Wirksamkeit des kompakten Kontexts

### Signs Compact Context funktioniert

– Agenten behalten nach der Kontextkomprimierung ein konsistentes Verhalten bei
- Keine Neufokussierung oder erneute Lesekompetenz nach der Komprimierung
- Tests werden weiterhin ohne Neustart bestanden
- Die Koordination zwischen den Agenten bleibt reibungslos
- Weniger Probleme mit dem „Kontextverlust“ bei langen Gesprächen

### Zeichen kompakter Kontext muss angepasst werden

– Der Agent vergisst, die Blocker nach der Komprimierung zu überprüfen
- Der Agent verliert mitten im Gespräch den Überblick über den Story-Status
- Kritische Regeln werden vergessen, aber in zukünftigen Austauschen darauf Bezug genommen
- Die Statusverfolgung wird inkonsistent
– Das Verhalten des Agenten ändert sich nach der Komprimierung merklich

### Debuggen des kompakten Kontexts

1. **Überprüfen Sie die Klarheit der Regeln**: Sind sie prägnant und umsetzbar?
2. **Statusfelder überprüfen**: Werden sie während der Arbeit tatsächlich aktualisiert?
3. **Anpassung der Überprüfungspriorität**: Ist die Agentenpriorität ihrer Wirkung angemessen?
4. **Test nach der Komprimierung**: Überprüfen Sie das Verhalten nach der Komprimierung manuell
5. **LesenExperten-Feedback**: Überprüfen Sie den Nachrichtenbus auf Koordinationsprobleme

## Verwandte Funktionen

- **Expertise-Dateien**: Langfristige Wissensdatenbank, die durch compact_context ergänzt wird
- **Schadenskontrolle**: Verhindert unbeabsichtigte Codeänderungen durch mehrstufige Bestätigung
- **Session Harness**: Validiert die Teststatus-Basislinie (im Compact_Context der meisten Agenten referenziert)
- **Skills-System**: Dynamische Agentenfunktionen werden bei Bedarf geladen

## Nächste Schritte

- Überprüfen Sie die `compact_context`-Konfiguration Ihres Agenten in `packages/cli/src/core/agents/`
– Wenn Sie neue Agenten erstellen, definieren Sie „compact_context“ mit der entsprechenden Prioritätsstufe
- Überwachen Sie bei Funktionen mit langer Laufzeit die Wirksamkeit der Kontextkomprimierung
- Aktualisieren Sie die Aufbewahrungsregeln, wenn Sie neue kritische Verhaltensmuster entdecken